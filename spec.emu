<!doctype html>
<meta charset="utf8">
<link rel="stylesheet" href="./spec.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">
<script src="./spec.js"></script>
<pre class="metadata">
title: Decimal
status: proposal
stage: 1
contributors: Jesse Alama
location: https://github.com/tc39/proposal-decimal/
</pre>

<emu-clause id="sec-scope">
  <h1>Scope</h1>
  <p>
    This is the spec text of the <a href="https://github.com/tc39/proposal-decimal/" title="Decimal proposal (GitHub)">Decimal proposal</a> in ECMAScript.
  </p>
</emu-clause>

<emu-clause id="sec-normative-references">
  <h1>Normative References</h1>
  <emu-clause id="ref-ieee-754-2019">
    <h1>IEEE 754-2019</h1>
    <p>"IEEE Standard for Floating-Point Arithmetic," in IEEE Std 754-2019 (Revision of IEEE 754-2008), pp. 1-84, 22 July 2019, doi: 10.1109/IEEESTD.2019.8766229.</p>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-data-types-and-values">
  <h1>ECMAScript Data Types and Values</h1>
  <emu-clause id="sec-ecmascript-specification-types">
    <h1>ECMAScript Specification Types</h1>
    <emu-clause id="sec-set-and-relation-specification-type">
      <h1>The Set and Relation Specification Types</h1>
      <p>A Relation *R* is said to be <dfn id="dfn-one-to-one-relation">one-to-one</dfn> provided that for every *a* in *R*'s domain, there exists exactly one *b* such that *(a, b)* is in *R*.</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-the-decimal-object">
  <h1>The Decimal128 Object</h1>
  <emu-intro id="sec-decimal-intro">
    <h1>Introduction</h1>
    <p>Decimal128 values, as specified here, are intended represent base-10 (decimal) numbers. ECMAScript, and many other languages, default to representing numbers in base-2 (binary). The conversion of a decimal digit string to a Number is usually inexact; the Number representing the initial decimal digit string is only approximately correct.</p>
    <p>An <dfn id="dfn-ieee-754-decimal128-value">IEEE 754 Decimal128 value</dfn> is an element of the universe of values specified by <emu-xref href="#ref-ieee-754-2019">IEEE 754</emu-xref> standard.</p>
    <p>Decimal128 values defined in this section are ECMAScript analogues of <emu-xref href="#ref-ieee-754-2019">IEEE-754 Decimal128 values</emu-xref>. The full spectrum of values defined by Decimal128 are available here, including NaN and positive and negative infinity. (NB: The values NaN and both infinities, available here, are distinct from the built-in *NaN*, *Infinity* and *-Infinity* values that arise from the 64-bit binarry IEEE arithmetic used outside of the Decimal128 universe.) Decimal128 is a floating-point format whose range of values allows up to 34 significant digits and an exponent ranging from -6143 to 6144.</p>
    <p>Essentially all of the entities defined by the IEEE-754 Decimal128 standard exist as Decimal128 objects, with one class of exceptions: NaN. Decimal128 supports NaN. All Decimal128-NaN values in IEEE 754 Decimal128 are mapped to a NaN Decimal128 value. There may be distinct NaN Decimal128 values in the sense of object identity, but they are all supposed to behave identically. Thus, when we refer to a <dfn id="dfn-decimal128-nan">Decimal128 NaN</dfn>, we mean any Decimal128 object whose <emu-xref href="#sec-decimal.prototype.isnan">*isNaN*</emu-xref> property is *true*. There is no Decimal128 analogue of IEEE 754 signalling NaNs. Any arithmetic operation defined here that takes a Decimal128-NaN argument will return a Decimal128-NaN. Depending on the the operation and its arguments, a Decimal128-NaN may be returned.</p>
    <p>A <dfn id="dfn-signed-exponential-digit-string">signed exponential digit string</dfn> is a List ¬´ *s*, *c*, *e* ¬ª, where *s* is a boolean, *c* is a non-empty sequence of digits, and *e* is an integer. In a signed exponential digit string ¬´ *s*, *c*, *e* ¬ª, we call *s* the <dfn id="dfn-signed-exponential-digit-string-sign">sign</dfn>, *c* the <dfn id="dfn-signed-exponential-digit-string-coefficient">coefficient</dfn>, and <dfn id="dfn-signed-exponential-digit-string-exponent">*e*</dfn> the exponent. All non-empty sequences of digits are permitted for the coefficient of a signed exponential digit string, including those that begin and end with multiple zeros. The exponent may be positive, negative, or zero.</p>
    <p>The <dfn id="dfn-mathematical-value-non-empty-list-of-digits">mathematical value of a non-empty List of digits</dfn> is the standard decimal interpretation of such Lists.</p>
    <p>A <dfn id="dfn-decimal128-digit-string">Decimal128 digit string</dfn> is a signed exponential digit string whose coefficient has length 34 and whose exponent is between -6143 and 6144, inclusive.</p>
    <p>There is a one-to-one Relation between the Set of finite, non-NaN IEEE-754 Decimal128 values and the set of Decimal128 digit strings.</p>
    <p>The <dfn id="dfn-signed-exponential-digit-string-mathematical-value">mathematical value of a signed exponential digit string</dfn> ¬´ *s*, *c*, *e* ¬ª is *s' √ó c'^10e*, where</p>
    <ul>
      <li>*s'* is 1 if *s* is *true* and -1 if *s* is *false*,</li>
      <li>*c'* is the <emu-xref href="#dfn-mathematical-value-non-empty-list-of-digits">mathematical value of *s*</emu-xref>.</li>
    </ul>
    <p>Thus, we grant ourselves a mapping <dfn id="dfn-map-from-ieee-754-decimal128">A</dfn> from the set of <emu-xref href="#dfn-ieee-754-decimal128-value">IEEE-754 Decimal128 values</emu-xref> to Decimal128 objects. Moreover, we grant ourselves a map <dfn id="dfn-map-to-ieee-754-decimal128">B</dfn> from Decimal128 objects to IEEE 754 Decimal128 values. We choose a canonical quiet NaN as the IEEE 754 Decimal128 representative for all Decimal128-NaN objects, and similarly for infinities. Apart from NaNs and infinities, the mappings A and B are one-to-one.</p>
    <p>A <dfn id="dfn-rounding-mode">rounding mode</dfn> is one of the values *"ceil"*, *"floor"*, *"expand"*, *"trunc"*, *"halfEven"*, *"halfExpand"*, *"halfCeil"*, *"halfFloor"*, and *"halfTrunc"*.</p>
    <p>The <dfn id="dfn-default-rounding-mode">default rounding mode</dfn> is the String value *halfEven*.</dfn></p>
    <p>A <dfn id="dfn-digit">digit</dfn> is one of the values *"0"*, *"1"*, *"2"*, *"3"*, *"4"*, *"5"*, *"6"*, *"7"*, *"8"*, and *"9"*</p>
    <p>A <dfn id="dfn-decimal-string">decimal string</dfn> is a string whose syntax is that of a sequence of digits followed by, optionally, a *"."* and a sequence of digits.</p>
    <p>A <dfn id="dfn-signed-decimal-string">signed decimal string</dfn> is a decimal string optionally preceded by a *"-"* (dash).</p>
    <p>An <dfn id="dfn-exponential-string">exponential string</dfn> is a string whose syntax is a decimal string whose mathematical value is at least 0 but less than 9, followed by an *"E"*, optionally a "-" (minus), and a sequence of digits.</p>
    <p>A <dfn id="dfn-signed-exponential-string">signed exponential string</dfn> is an exponential string optionally precided by a *"-"* (dash).</p>
    <p>The <dfn id="dfn-mathematical-value">mathematical value</dfn> of a Decimal128 object *d*, provided *d* is finite and not NaN, is the rational number *coefficient* of *d* multiplied by 10 raised to the power of the *exponent* of *d*. If *d* is infinite, the mathematical value of *d* is -‚àû is *d* is negative and ‚àû otherwise. If *d* is NaN, the mathematical value of *d* is undefined.</p>
    <p>A Decimal128 value is said to be <dfn id="dfn-normal">normal</dfn> if its coefficient either (zero and has an exponent of zero) or has an exponent that is not divisible by ten. Example: 1.2 is normal, but 1.20 is not normal. In terms of <emu-xref href="#dfn-decimal-string">decimal strings</emu-xref>, a normal value corresponds precisely to strings whose decimal part terminates with a sequence of zeros.</p>
  </emu-intro>
  <emu-clause id="sec-the-decimal-constructor">
    <h1>The Decimal128 Constructor</h1>
    <p>The constructor for the Decimal128 object takes a single argument. If the argument is not a String, throw a *TypeError*. The String argument must match one of the following four valid syntaxes:</p>
    <emu-grammar name="decimal-syntax">
      <emu-production name="DigitString" type="lexical">
	<emu-rhs><emu-prodref href="#prod-Decimal128Digit"></emu-prodref>+</emu-rhs>
      </emu-production>
      <emu-production name="UnsignedDecimal128DigitString" type="lexical" oneof>
	<emu-rhs><emu-prodref href="#prod-Decimal128Digits"></emu-prodref></emu-rhs>
	<emu-rhs><emu-prodref href="#prod-Decimal128Digits"></emu-prodref> "." <emu-prodref href="#prod-Decimal128Digits"></emu-prodref></emu-rhs>
      </emu-production>
      <emu-production name="SignedDecimal128DigitString" type="lexical" oneof>
	<emu-rhs>-? <emu-prodref name="UnsignedDecimal128DigitString"></emu-prodref></emu-rhs>
      </emu-production>
    </emu-grammar>
    <emu-grammar>
      <emu-production name="UnsignedDecimal128DigitString" type="lexical" oneof>
	<emu-rhs><emu-prodref href="#prod-Decimal128Digits"></emu-prodref></emu-rhs>
	<emu-rhs><emu-prodref href="#prod-Decimal128Digits"></emu-prodref> "." <emu-prodref href="#prod-Decimal128Digits"></emu-prodref></emu-rhs>
      </emu-production>
      <emu-production name="SignedDecimal128DigitString" type="lexical" oneof>
	<emu-rhs>[+-]? <emu-prodref name="UnsignedDigitString"></emu-prodref></emu-rhs>
      </emu-production>
    </emu-grammar>
    <emu-grammar name="exponential-syntax">
      <emu-production name="ExponentialDigitStringLHS" type="lexical" oneof>
	<emu-rhs><emu-prodref href="#prod-NonZeroDigit"></emu-prodref></emu-rhs>
	<emu-rhs><emu-prodref href="#prod-NonZeroDigit"></emu-prodref> "." <emu-prodref href="#prod-Decimal128Digits"></emu-prodref></emu-rhs>
      </emu-production>
      <emu-production name="ExponentialDigitStringRHS" type="lexical">
	<emu-rhs>[-+]? <emu-prodref href="#prod-Decimal128Digits"></emu-prodref></emu-rhs>
      </emu-production>
    </emu-grammar>
    <emu-grammar name="infinity" oneof>
      <emu-production>`-` ? `Inf` [> or any token that is an ASCII case-insensitive match]</emu-production>
      <emu-production>`-` ? `Infinity` [> or any token that is an ASCII case-insensitive match]</emu-production>
    </emu-grammar>
    <emu-grammar name="nan">
      <emu-production>("N" | "n") | ("A" | "a") | ("N" | "n")</emu-production>
    </emu-grammar>
    <p>If *_x_* does not match any of these syntaxes, throw a *SyntaxError*.</p>
    <p>Multiple leading zeros will be reduced to a single zero.</p>
  </emu-clause>
</emu-clause>
  <emu-clause id="sec-decimal-prototype-properties">
    <h1>Properties of the Decimal128 Prototype</h1>
    <emu-clause id="sec-decimal.prototype.isnan">
      <h1>Decimal128.prototype.isNaN</h1>
      <p>A property indicating whether *this* value represents a Decimal128 NaN value. The possible values are *true* and *false*.</p>
    </emu-clause>
    <emu-clause id="sec-decimal.prototype.add">
      <h1>Decimal128.prototype.add ( _x_ [ , _options_ ] )</h1>
      <p>Adds <emu-xref href="#dfn-map-to-ieee-754-decimal128">B</emu-xref> of *this* value and <emu-xref href="#dfn-map-to-ieee-754-decimal128">B</emu-xref> of *_x_* according to the rules specified in <emu-xref href="#dfn-ieee-754-decimal128-value">IEEE 754 Decimal128</emu-xref> and returns <emu-xref href="#dfn-map-from-ieee-754-decimal128">A</emu-xref> of the resulting Decimal128 value. Returns a fresh result, regardless of the mathematical value of *this* value or *_x_*. Neither *this* value nor *_x_* is modified. If, in the computation, more significant are generated than can be stored in an IEEE 754 Decimal128 value, consult [[_options_]][[roundingMode]] to determine the final significant digit. If [[_options_]][[roundingMode]] is not a <emu-xref href="#dfn-rounding-mode">rounding mode</emu-xref>, compute the final significant digit according to <emu-xref href="#dfn-default-rounding-mode">the default rounding mode</emu-xref>.</p>
      <emu-note>
	<p>If _x_ is not an instance of the Decimal128 object, then a *TypeError* will be thrown.</p>
	<p>Returns the result of adding the current Decimal128 value to _x_.</p>
	<p>If _options_ is specified and _roundingMode_ is a property of _options_, then Get(_options_, *roundingMode*) must be a <emu-xref href="#dfn-rounding-mode">rounding mode</emu-xref>. If Get(_options_, *roundingMode*) is not a <emu-xref href="#dfn-rounding-mode">rounding mode</emu-xref>, a *RangeError* will be thrown. The addition will be carried out according to the specified rounding mode.</p>
      </emu-note>
    </emu-clause>
    <emu-clause id="sec-decimal.prototype.subtract">
      <h1>Decimal128.prototype.subtract ( _x_ [ , _options_ ] )</h1>
      <p>Subtracts <emu-xref href="#dfn-map-to-ieee-754-decimal128">B</emu-xref> of *_x_* from <emu-xref href="#dfn-map-to-ieee-754-decimal128">B</emu-xref> of *this* value according to the rules for subtraction in the <emu-xref href="#dfn-ieee-754-decimal128-value">IEEE 754 Decimal128</emu-xref> specification and returns <emu-xref href="#dfn-map-from-ieee-754-decimal128">A</emu-xref> of the resulting IEEE Decimal128 value. Returns a fresh result, regardless of the mathematical value of *_x_*. Neither *this* value nor *_x_* is modified. If, in the computation, more significant are generated than can be stored in an IEEE 754 Decimal128 value, consult [[_options_]][[roundingMode]] to determine the final significant digit. If [[_options_]][[roundingMode]] is not a <emu-xref href="#dfn-rounding-mode">rounding mode</emu-xref>, compute the final significant digit according to <emu-xref href="#dfn-default-rounding-mode">the default rounding mode</emu-xref>.</p>
      <emu-note>
	<p>Returns the result of subtracting _x_ from the current Decimal128 value, which must be a Decimal128 object.</p>
	<p>If _options_ is specified and _roundingMode_ is a property of _options_, then Get(_options_, *roundingMode*) must be a <emu-xref href="#dfn-rounding-mode">rounding mode</emu-xref>. If Get(_options_, *roundingMode*) is not a <emu-xref href="#dfn-rounding-mode">rounding mode</emu-xref>, throw a *RangeError* exception. The subtraction will be carried out according to the specified rounding mode.</p>
      </emu-note>
    </emu-clause>
    <emu-clause id="sec-decimal.prototype.multiply">
      <h1>Decimal128.prototype.multiply ( _x_ [ , _options_ ] )</h1>
      <p>Multiplies <emu-xref href="#dfn-map-to-ieee-754-decimal128">B</emu-xref> of *this* value by <emu-xref href="#dfn-map-to-ieee-754-decimal128">B</emu-xref> of *_x_* according to the rules of the IEEE 754 Decimal128 specification and returns <emu-xref href="#dfn-map-from-ieee-754-decimal128">A</emu-xref> of the resulting Decimal128 value. Returns a fresh result, regardless of the mathematical value of *this* value or that of *_x_*. Neither argument is modified. If, in the computation, more significant are generated than can be stored in an IEEE 754 Decimal128 value, consult [[_options_]][[roundingMode]] to determine the final significant digit. If [[_options_]][[roundingMode]] is not a <emu-xref href="#dfn-rounding-mode">rounding mode</emu-xref>, compute the final significant digit according to <emu-xref href="#dfn-default-rounding-mode">the default rounding mode</emu-xref>.</p>
      <emu-note>
	<p>Returns the result of multiplying *this* value with _x_, which must be a Decimal128 object.</p>
	<p>If _options_ is specified and _roundingMode_ is a property of _options_, then Get(_options_, *roundingMode*) must be a <emu-xref href="#dfn-rounding-mode">rounding mode</emu-xref>. If Get(_options_, *roundingMode*) is not a <emu-xref href="#dfn-rounding-mode">rounding mode</emu-xref>, a *RangeError* will be thrown. The multiplication will be carried out according to the specified rounding mode.</p>
      </emu-note>
    </emu-clause>
    <emu-clause id="sec-decimal.prototype.divide">
      <h1>Decimal128.prototype.divide ( _x_ [ , _options_ ] )</h1>
      <p>Divides <emu-xref href="#dfn-map-to-ieee-754-decimal128">B</emu-xref> of *this* value by <emu-xref href="#dfn-map-to-ieee-754-decimal128">B</emu-xref> of *_y_* according to the rules of the IEEE 754 Decimal128 specification and returns <emu-xref href="#dfn-map-from-ieee-754-decimal128">A</emu-xref> of the resulting Decimal128 value. Returns a fresh result. Neither *this* value nor *_x_* is modified. If, in the computation, more significant are generated than can be stored in an IEEE 754 Decimal128 value, consult [[_options_]][[roundingMode]] to determine the final significant digit. If [[_options_]][[roundingMode]] is not a <emu-xref href="#dfn-rounding-mode">rounding mode</emu-xref>, compute the final significant digit according to <emu-xref href="#dfn-default-rounding-mode">the default rounding mode</emu-xref>.</p>
      <emu-note>
	<p>Returns the result of multiplying _x_ from the current Decimal128 value, which must be a Decimal128 object.</p>
	<p>If _options_ is specified and _roundingMode_ is a property of _options_, then Get(_options_, *roundingMode*) must be a <emu-xref href="#dfn-rounding-mode">rounding mode</emu-xref>. If Get(_options_, *roundingMode*) is not a <emu-xref href="#dfn-rounding-mode">rounding mode</emu-xref>, a *RangeError* will be thrown. The multiplication will be carried out according to the specified rounding mode.</p>
      </emu-note>
    </emu-clause>
    <emu-clause id="sec-decimal.prototype.remainder">
      <h1>Decimal128.prototype.remainder ( _x_ [ , _options_ ] )</h1>
      <p>Computes the remainder of dividing <emu-xref href="#dfn-map-to-ieee-754-decimal128">B</emu-xref> of *this_ value by <emu-xref href="#dfn-map-to-ieee-754-decimal128">B</emu-xref> of *_x_* according to the rules of the IEEE 754 Decimal128 specification and returns <emu-xref href="#dfn-map-from-ieee-754-decimal128">A</emu-xref> of the resulting Decimal128 value. The sign of the result is the sign of *this* value. Returns a fresh result. If, in the computation, more significant are generated than can be stored in an IEEE 754 Decimal128 value, consult [[_options_]][[roundingMode]] to determine the final significant digit. If [[_options_]][[roundingMode]] is not a <emu-xref href="#dfn-rounding-mode">rounding mode</emu-xref>, compute the final significant digit according to <emu-xref href="#dfn-default-rounding-mode">the default rounding mode</emu-xref>.</p>
    </emu-clause>
    <emu-clause id="sec-decimal.prototype.cmp">
      <h1>Decimal128.prototype.cmp ( _x_ [ , _options_ ] )</h1>
      <p>Compares the <emu-xref href="#dfn-mathematical-value">mathematical value</emu-xref> of *this* value with the mathematical value of *_x_*, which is supposed to be a Decimal128 object. If *_x_* is not a Decimal128 object, throws a *TypeError*. Return *-1*<sub>ùîΩ</sub>, *+0*<sub>ùîΩ</sub>, or *1*<sub>ùîΩ</sub> is the mathematical value of the *this* value value is, respectively, less than, equal to, or strictly greater than the mathematical value of *_x_*.</p>
      <emu-alg>
	1. If _x_ is not a Decimal128 object, then
	  1. throw a *TypeError* exception.
	1. If [*this*][[isNaN]] or [*_x_*][[isNaN]] is *true*, then
	  1. return *undefined*.
      </emu-alg>
    </emu-clause>
    <emu-clause id="sec-decimal-method-round">
      <h1>Decimal128.prototype.round ( _numFractionalDigits_ [ , _mode_ ] )</h1>
      <p>Rounds *this* value according to the specified rounding mode, returning a fresh result. The result will have at most _numFractionalDigits_ after the decimal point.</p>
      <emu-note>
	<p>If _mode_ is neither *undefined* nor a String, throw a *TypeError* exception.</p>
	<p>If _mode_ is not a <emu-xref href="#dfn-rounding-mode">rounding mode</emu-xref>, throw a *RangeError* exception.</p>
      </emu-note>
    </emu-clause>
    <emu-clause id="sec-decimal.prototype.tostring">
      <h1>Decimal128.prototype.toString ( [ _options_ ] )</h1>
      <p>Renders *this* value as a <emu-xref href="#dfn-signed-decimal-string">signed decimal string</emu-xref>. _options_, is defined, is supposed to be a plain object. If _options_ has the property *numDecimal128Digits* and the value of that property is a non-negative Number, the return value will be a string that has exactly that many digits after the decimal point, possibly with the addition of trailing zeros.</p>
      <emu-alg>
	1. Let _roundingMode_ be [[_options_]][roundingMode]].
	1. If _roundingMode_ is not one of *"ceil"*, *"floor"*, *"expand"*, *"trunc"*, *"halfEven"*, *"halfExpand"*, *"halfCeil"*, *"halfFloor"*, or *"halfTrunc"*, then
	  1. set _roundingMode_ to *"halfEven"*.
	1. Let _format_ be [[_options_]][format]].
	1. If _format_ is not one of *"decimal"* or *"exponential"*, then
	  1. set _format_ to *"decimal"*.
	1. If _format_ is *"decimal*", then
	  1. return the result of calling IEEE 754's convertToDecimalCharacter with a second argument ensuring that a <emu-xref href="#dfn-signed-decimal-string">signed decimal string</emu-xref> is generated.
	1. Return the result of calling IEEE 754's convertToDecimalCharacter. with a second argument ensuring that a <emu-xref href="#dfn-signed-exponential-string">signed exponential string</emu-xref> is generated.
      </emu-alg>
    </emu-clause>
    <emu-clause id="sec-decimal.prototype.valueof">
      <h1>Decimal128.prototype.valueOf ( _x_ )</h1>
      <p>Throw *TypeError*.</p>
    </emu-clause>
  </emu-clause>
</emu-clause>
