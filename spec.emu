<!doctype html>
<meta charset="utf8">
<link rel="stylesheet" href="./spec.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">
<script src="./spec.js"></script>
<pre class="metadata">
title: Decimal
status: proposal
stage: 1
contributors: Jesse Alama
location: https://github.com/tc39/proposal-decimal/
</pre>

<emu-clause id="sec-scope">
  <h1>Scope</h1>
  <p>
    This is the spec text of the <a href="https://github.com/tc39/proposal-decimal/" title="Decimal proposal (GitHub)">Decimal proposal</a> in ECMAScript.
  </p>
</emu-clause>

<emu-clause id="sec-the-decimal-object">
  <h1>The Decimal128 Object</h1>
  <emu-intro id="sec-decimal-intro">
    <h1>Introduction</h1>
    <p>Decimal128 values, as specified here, are intended represent base-10 (decimal) numbers. ECMAScript, and many other languages, default to representing numbers in base-2 (binary). The conversion of a decimal digit string to a Number is usually inexact; the Number representing the initial decimal digit string is only approximately correct.</p>
    <p>An <dfn id="dfn-ieee-754-decimal128-value">IEEE 754 Decimal128 value</dfn> is an element of the universe of values specified by <emu-xref href="#sec-bibliography">IEEE 754</emu-xref> standard.</p>
    <p>Decimal128 values defined in this section are ECMAScript analogues of <emu-xref href="#sec-bibliography">IEEE-754 Decimal128 values</emu-xref>. The full spectrum of values defined by Decimal128 are available here, including NaN and positive and negative infinity. (NB: The values NaN and both infinities, available here, are distinct from the built-in *NaN*, *Infinity* and *-Infinity* values that arise from the 64-bit binarry IEEE arithmetic used outside of the Decimal128 universe.) Decimal128 is a floating-point format whose range of values allows up to 34 significant digits and an exponent ranging from -6143 to 6144.</p>
    <p>Essentially all of the entities defined by the IEEE 754 Decimal128 standard exist as Decimal128 objects, with one class of exceptions: NaN. Decimal128 supports NaN. All Decimal128-NaN values in IEEE 754 Decimal128 are mapped to a NaN Decimal128 value. There may be distinct NaN Decimal128 values in the sense of object identity, but they are all supposed to behave identically. Thus, when we refer to a <dfn id="dfn-decimal128-nan">Decimal128 NaN</dfn>, we mean any Decimal128 object whose <emu-xref href="#sec-decimal.prototype.isnan">*isNaN*</emu-xref> property is *true*. There is no Decimal128 analogue of IEEE 754 signalling NaNs. Any arithmetic operation defined here that takes a Decimal128-NaN argument will return a Decimal128-NaN. Depending on the the operation and its arguments, a Decimal128-NaN may be returned.</p>
    <p>Thus, we grant ourselves a mapping <dfn id="dfn-map-from-ieee-754-decimal128">A</dfn> from the set of <emu-xref href="#dfn-ieee-754-decimal128-value">IEEE Decimal128 values</emu-xref> to Decimal128 objects. Moreover, we grant ourselves a map <dfn id="dfn-map-to-ieee-754-decimal128">B</dfn> from Decimal128 objects to IEEE 754 Decimal128 values. We choose a canonical quiet NaN as the IEEE 754 Decimal128 representative for all Decimal128-NaN objects, and similarly for infinities. Apart from NaNs and infinities, the mappings A and B are one-to-one.</p>
    <p>A <dfn id="dfn-rounding-mode">rounding mode</dfn> is one of the values *"ceil"*, *"floor"*, *"expand"*, *"trunc"*, *"halfEven"*, *"halfExpand"*, *"halfCeil"*, *"halfFloor"*, and *"halfTrunc"*.</p>
    <p>The <dfn id="dfn-default-rounding-mode">default rounding mode</dfn> is the String value *halfEven*.</dfn></p>
    <p>A <dfn id="dfn-digit">digit</dfn> is one of the values *"0"*, *"1"*, *"2"*, *"3"*, *"4"*, *"5"*, *"6"*, *"7"*, *"8"*, and *"9"*</p>
    <p>A <dfn id="dfn-decimal-string">decimal string</dfn> is a string whose syntax is that of a sequence of digits followed by, optionally, a *"."* and a sequence of digits.</p>
    <p>A <dfn id="dfn-signed-decimal-string">signed decimal string</dfn> is a decimal string optionally preceded by a *"-"* (dash).</p>
    <p>An <dfn id="dfn-exponential-string">exponential string</dfn> is a string whose syntax is a decimal string whose mathematical value is at least 0 but less than 9, followed by an *"E"*, optionally a "-" (minus), and a sequence of digits.</p>
    <p>A <dfn id="dfn-signed-exponential-string">signed exponential string</dfn> is an exponential string optionally precided by a *"-"* (dash).</p>
    <p>The <dfn id="dfn-mathematical-value">mathematical value</dfn> of a Decimal128 object *d*, provided *d* is finite and not NaN, is the rational number *coefficient* of *d* multiplied by 10 raised to the power of the *exponent* of *d*. If *d* is infinite, the mathematical value of *d* is -∞ is *d* is negative and ∞ otherwise. If *d* is NaN, the mathematical value of *d* is undefined.</p>
    <p>A Decimal128 value is said to be <dfn id="dfn-normal">normal</dfn> if its coefficient either (zero and has an exponent of zero) or has an exponent that is not divisible by ten. Example: 1.2 is normal, but 1.20 is not normal. In terms of <emu-xref href="#dfn-decimal-string">decimal strings</emu-xref>, a normal value corresponds precisely to strings whose decimal part terminates with a sequence of zeros.</p>
  </emu-intro>
  <emu-clause id="sec-decimal-abstract-ops">
    <h1>Abstract Operations</h1>
    <emu-clause id="sec-isintegraldecimal128" type="abstract operation">
      <h1>
        IsIntegralDecimal128 (
          _argument_: an ECMAScript language value,
        ): a Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It determines if _argument_ is a finite integral Decimal128 value.</dd>
      </dl>
      <emu-alg>
        1. If _argument_ is not a Decimal128 object, return *false*.
        1. If [_argument_].[[isNaN]] is *true*, return *false*.
        1. If [_argument_].[[isFinite]] is *false*, return *false*.
        1. Let _rounded_ be the result of ! Call ([_argument_].[[round]], 0, *"trunc"*).
        1. Return the result of Call ([_argument_].[[equals]], _rounded_).
      </emu-alg>
    </emu-clause>
  </emu-clause>
  <emu-clause id="sec-the-decimal-constructor">
    <h1>The Decimal128 Constructor</h1>
    <p>The constructor for the Decimal128 object takes a single argument. If the argument is not a String, throw a *TypeError*. The String argument must match one of the following four valid syntaxes:</p>
    <emu-grammar name="decimal-syntax">
      <emu-production name="DigitString" type="lexical">
        <emu-rhs><emu-prodref href="#prod-Decimal128Digit"></emu-prodref>+</emu-rhs>
      </emu-production>
      <emu-production name="UnsignedDecimal128DigitString" type="lexical" oneof>
        <emu-rhs><emu-prodref href="#prod-Decimal128Digits"></emu-prodref></emu-rhs>
        <emu-rhs><emu-prodref href="#prod-Decimal128Digits"></emu-prodref> "." <emu-prodref href="#prod-Decimal128Digits"></emu-prodref></emu-rhs>
      </emu-production>
      <emu-production name="SignedDecimal128DigitString" type="lexical" oneof>
        <emu-rhs>-? <emu-prodref name="UnsignedDecimal128DigitString"></emu-prodref></emu-rhs>
      </emu-production>
    </emu-grammar>
    <emu-grammar>
      <emu-production name="UnsignedDecimal128DigitString" type="lexical" oneof>
        <emu-rhs><emu-prodref href="#prod-Decimal128Digits"></emu-prodref></emu-rhs>
        <emu-rhs><emu-prodref href="#prod-Decimal128Digits"></emu-prodref> "." <emu-prodref href="#prod-Decimal128Digits"></emu-prodref></emu-rhs>
      </emu-production>
      <emu-production name="SignedDecimal128DigitString" type="lexical" oneof>
        <emu-rhs>[+-]? <emu-prodref name="UnsignedDigitString"></emu-prodref></emu-rhs>
      </emu-production>
    </emu-grammar>
    <emu-grammar name="exponential-syntax">
      <emu-production name="ExponentialDigitStringLHS" type="lexical" oneof>
        <emu-rhs><emu-prodref href="#prod-NonZeroDigit"></emu-prodref></emu-rhs>
        <emu-rhs><emu-prodref href="#prod-NonZeroDigit"></emu-prodref> "." <emu-prodref href="#prod-Decimal128Digits"></emu-prodref></emu-rhs>
      </emu-production>
      <emu-production name="ExponentialDigitStringRHS" type="lexical">
        <emu-rhs>[-+]? <emu-prodref href="#prod-Decimal128Digits"></emu-prodref></emu-rhs>
      </emu-production>
    </emu-grammar>
    <emu-grammar name="infinity" oneof>
      <emu-production>`-` ? `Inf` [> or any token that is an ASCII case-insensitive match]</emu-production>
      <emu-production>`-` ? `Infinity` [> or any token that is an ASCII case-insensitive match]</emu-production>
    </emu-grammar>
    <emu-grammar name="nan">
      <emu-production>("N" | "n") | ("A" | "a") | ("N" | "n")</emu-production>
    </emu-grammar>
    <p>If *_x_* does not match any of these syntaxes, throw a *SyntaxError*.</p>
    <p>Multiple leading zeros will be reduced to a single zero.</p>
  </emu-clause>
</emu-clause>
  <emu-clause id="sec-decimal-prototype-properties">
    <h1>Properties of the Decimal128 Prototype</h1>
    <emu-clause id="sec-decimal.prototype.isnan">
      <h1>Decimal128.prototype.isNaN</h1>
      <p>A property indicating whether *this* value represents a Decimal128 NaN value. The possible values are *true* and *false*.</p>
    </emu-clause>
    <emu-clause id="sec-decimal.prototype.isfinite">
      <h1>Decimale128.prototype.isFinite</h1>
      <p>A property indicating whether *this* value represents a finite value. The possible values are *true* and *false*. Decimal128 NaN values are considered finite.</p>
    </emu-clause>
    <emu-clause id="sec-decimal.prototype.significand">
      <h1>Decimale128.prototype.significand</h1>
      <p>A property that stores the significand of *this* value. Its type is BigInt. This property should be a BigInt even if *this* value is NaN or infinite.</p>
    </emu-clause>
    <emu-clause id="sec-decimal.prototype.exponent">
      <h1>Decimale128.prototype.exponent</h1>
      <p>A property that stores the exponent of *this* value. Its type is Number. It should always be an integer. This property should be a Number even if *this* value is NaN or infinite.</p>
    </emu-clause>
    <emu-clause id="sec-decimal.prototype.abs">
      <h1>Decimal128.prototype.abs ( )</h1>
      <p>Computes the absolute value of <emu-xref href="#dfn-map-to-ieee-754-decimal128">B</emu-xref> of *this* value according to the rules specified in <emu-xref href="#dfn-ieee-754-decimal128-value">IEEE 754 Decimal128</emu-xref> and returns <emu-xref href="#dfn-map-from-ieee-754-decimal128">A</emu-xref> of the resulting IEEE 754 Decimal128 value. Returns a fresh result, regardless of the mathematical value of *this* value. *this* value is not modified.</p>
    </emu-clause>
    <emu-clause id="sec-decimal.prototype.neg">
      <h1>Decimal128.prototype.neg ( )</h1>
      <p>Computes the negation of <emu-xref href="#dfn-map-to-ieee-754-decimal128">B</emu-xref> of *this* value Returns a fresh result, regardless of the mathematical value of *this* value. *this* value is not modified.</p>
    </emu-clause>
    <emu-clause id="sec-decimal.prototype.add">
      <h1>Decimal128.prototype.add ( _x_ [ , _options_ ] )</h1>
      <p>Adds <emu-xref href="#dfn-map-to-ieee-754-decimal128">B</emu-xref> of *this* value and <emu-xref href="#dfn-map-to-ieee-754-decimal128">B</emu-xref> of *_x_* according to the rules specified in <emu-xref href="#dfn-ieee-754-decimal128-value">IEEE 754 Decimal128</emu-xref> and returns <emu-xref href="#dfn-map-from-ieee-754-decimal128">A</emu-xref> of the resulting Decimal128 value. Returns a fresh result, regardless of the mathematical value of *this* value or *_x_*. Neither *this* value nor *_x_* is modified. If, in the computation, more significant are generated than can be stored in an IEEE 754 Decimal128 value, consult [[_options_]][[roundingMode]] to determine the final significant digit. If [[_options_]][[roundingMode]] is not a <emu-xref href="#dfn-rounding-mode">rounding mode</emu-xref>, compute the final significant digit according to <emu-xref href="#dfn-default-rounding-mode">the default rounding mode</emu-xref>.</p>
      <emu-note>
        <p>If _x_ is not an instance of the Decimal128 object, then a *TypeError* will be thrown.</p>
        <p>Returns the result of adding the current Decimal128 value to _x_.</p>
        <p>If _options_ is specified and _roundingMode_ is a property of _options_, then Get(_options_, *roundingMode*) must be a <emu-xref href="#dfn-rounding-mode">rounding mode</emu-xref>. If Get(_options_, *roundingMode*) is not a <emu-xref href="#dfn-rounding-mode">rounding mode</emu-xref>, a *RangeError* will be thrown. The addition will be carried out according to the specified rounding mode.</p>
      </emu-note>
    </emu-clause>
    <emu-clause id="sec-decimal.prototype.subtract">
      <h1>Decimal128.prototype.subtract ( _x_ [ , _options_ ] )</h1>
      <p>Subtracts <emu-xref href="#dfn-map-to-ieee-754-decimal128">B</emu-xref> of *_x_* from <emu-xref href="#dfn-map-to-ieee-754-decimal128">B</emu-xref> of *this* value according to the rules for subtraction in the <emu-xref href="#dfn-ieee-754-decimal128-value">IEEE 754 Decimal128</emu-xref> specification and returns <emu-xref href="#dfn-map-from-ieee-754-decimal128">A</emu-xref> of the resulting IEEE Decimal128 value. Returns a fresh result, regardless of the mathematical value of *_x_*. Neither *this* value nor *_x_* is modified. If, in the computation, more significant are generated than can be stored in an IEEE 754 Decimal128 value, consult [[_options_]][[roundingMode]] to determine the final significant digit. If [[_options_]][[roundingMode]] is not a <emu-xref href="#dfn-rounding-mode">rounding mode</emu-xref>, compute the final significant digit according to <emu-xref href="#dfn-default-rounding-mode">the default rounding mode</emu-xref>.</p>
      <emu-note>
        <p>Returns the result of subtracting _x_ from the current Decimal128 value, which must be a Decimal128 object.</p>
        <p>If _options_ is specified and _roundingMode_ is a property of _options_, then Get(_options_, *roundingMode*) must be a <emu-xref href="#dfn-rounding-mode">rounding mode</emu-xref>. If Get(_options_, *roundingMode*) is not a <emu-xref href="#dfn-rounding-mode">rounding mode</emu-xref>, throw a *RangeError* exception. The subtraction will be carried out according to the specified rounding mode.</p>
      </emu-note>
    </emu-clause>
    <emu-clause id="sec-decimal.prototype.multiply">
      <h1>Decimal128.prototype.multiply ( _x_ [ , _options_ ] )</h1>
      <p>Multiplies <emu-xref href="#dfn-map-to-ieee-754-decimal128">B</emu-xref> of *this* value by <emu-xref href="#dfn-map-to-ieee-754-decimal128">B</emu-xref> of *_x_* according to the rules of the IEEE 754 Decimal128 specification and returns <emu-xref href="#dfn-map-from-ieee-754-decimal128">A</emu-xref> of the resulting Decimal128 value. Returns a fresh result, regardless of the mathematical value of *this* value or that of *_x_*. Neither argument is modified. If, in the computation, more significant are generated than can be stored in an IEEE 754 Decimal128 value, consult [[_options_]][[roundingMode]] to determine the final significant digit. If [[_options_]][[roundingMode]] is not a <emu-xref href="#dfn-rounding-mode">rounding mode</emu-xref>, compute the final significant digit according to <emu-xref href="#dfn-default-rounding-mode">the default rounding mode</emu-xref>.</p>
      <emu-note>
        <p>Returns the result of multiplying *this* value with _x_, which must be a Decimal128 object.</p>
        <p>If _options_ is specified and _roundingMode_ is a property of _options_, then Get(_options_, *roundingMode*) must be a <emu-xref href="#dfn-rounding-mode">rounding mode</emu-xref>. If Get(_options_, *roundingMode*) is not a <emu-xref href="#dfn-rounding-mode">rounding mode</emu-xref>, a *RangeError* will be thrown. The multiplication will be carried out according to the specified rounding mode.</p>
      </emu-note>
    </emu-clause>
    <emu-clause id="sec-decimal.prototype.divide">
      <h1>Decimal128.prototype.divide ( _x_ [ , _options_ ] )</h1>
      <p>Divides <emu-xref href="#dfn-map-to-ieee-754-decimal128">B</emu-xref> of *this* value by <emu-xref href="#dfn-map-to-ieee-754-decimal128">B</emu-xref> of *_y_* according to the rules of the IEEE 754 Decimal128 specification and returns <emu-xref href="#dfn-map-from-ieee-754-decimal128">A</emu-xref> of the resulting Decimal128 value. Returns a fresh result. Neither *this* value nor *_x_* is modified. If, in the computation, more significant are generated than can be stored in an IEEE 754 Decimal128 value, consult [[_options_]][[roundingMode]] to determine the final significant digit. If [[_options_]][[roundingMode]] is not a <emu-xref href="#dfn-rounding-mode">rounding mode</emu-xref>, compute the final significant digit according to <emu-xref href="#dfn-default-rounding-mode">the default rounding mode</emu-xref>.</p>
      <emu-note>
        <p>Returns the result of multiplying _x_ from the current Decimal128 value, which must be a Decimal128 object.</p>
        <p>If _options_ is specified and _roundingMode_ is a property of _options_, then Get(_options_, *roundingMode*) must be a <emu-xref href="#dfn-rounding-mode">rounding mode</emu-xref>. If Get(_options_, *roundingMode*) is not a <emu-xref href="#dfn-rounding-mode">rounding mode</emu-xref>, a *RangeError* will be thrown. The multiplication will be carried out according to the specified rounding mode.</p>
      </emu-note>
    </emu-clause>
    <emu-clause id="sec-decimal.prototype.remainder">
      <h1>Decimal128.prototype.remainder ( _x_ )</h1>
      <p>Computes the remainder of dividing *this* value by *_x_*. Exact division of *this* by *_x_* is carried out until the computation stops; the residue of that computation is returned. The sign of the result is the sign of *this* value. Returns a fresh result.</p>
      <emu-note>
        <p>The remainder operation specified here deviates from the IEEE 754 remainder operation. We follow the <emu-xref href="#sec-numeric-types-number-remainder">the remainder operation for Number</emu-xref> rather than IEEE 754, which specifies that, for example, the remainder 46 and 10 is -4 rather than 6.</p>
      </emu-note>
    </emu-clause>
    <emu-clause id="sec-decimal.prototype.equals">
      <h1>Decimal128.prototype.equals ( _x_ )</h1>
      <p>Compares the <emu-xref href="#dfn-mathematical-value">mathematical value</emu-xref> of *this* value with the mathematical value of *_x_*, which is supposed to be a Decimal128 object. If *_x_* is not a Decimal128 object, throws a *TypeError*. Returns *true* or *false*.</p>
      <emu-alg>
        1. If _x_ is not a Decimal128 object, then
          1. throw a *TypeError* exception.
        1. If [*this*][[isNaN]], then
          1. If [*_x_*][[isNaN]] is *true*, return *true*.
          1. Return *false*.
        1. If [*_x_*][[isNaN]] is *true*, return *false*.
        1. Let *_c_* be the result of calling the IEEE 754 Decimal128 compare_total procedure on *this* value and *_x_*.
        1. If *_c_* is 0, return *true*, else return *false*.
      </emu-alg>
    </emu-clause>
    <emu-clause id="sec-decimal.prototype.lessthan">
      <h1>Decimal128.prototype.lessThan ( _x_ )</h1>
      <p>Compares the <emu-xref href="#dfn-mathematical-value">mathematical value</emu-xref> of *this* value with the mathematical value of *_x_*, which is supposed to be a Decimal128 object. If *_x_* is not a Decimal128 object, throws a *TypeError*. Returns *true* or *false* according as the mathematical value of *this* value is strictly less than the mathematical value of *_x_*.</p>
      <emu-alg>
        1. If _x_ is not a Decimal128 object, then
          1. throw a *TypeError* exception.
        1. If [*this*][[isNaN]], throw a *RangeError* exception.
        1. If [*_x_*][[isNaN]], throw a *RangeError* exception.
        1. Let *_c_* be the result of calling the IEEE 754 Decimal128 compare procedure on *this* value and *_x_*.
        1. If *_c_* is -1, return *true*, else return *false*.
      </emu-alg>
    </emu-clause>
    <emu-clause id="sec-decimal.prototype.compare">
      <h1>Decimal128.prototype.compare ( _x_ )</h1>
      <p>Compares *this* value with of *_x_* according to the specification of the IEEE 754 <code>compare_total</code> operation. Returns -1, 0, or 1 according as *this* value is greater than, equal, or less than *_x_* according to the ordering specified by IEEE 754's <code>compare_total</code> operation.</p>
      <emu-alg>
        1. If _x_ is not a Decimal128 object, then
          1. throw a *TypeError* exception.
        1. Let *_c_* be the result of calling the IEEE 754 Decimal128 compare_total procedure on *this* value and *_x_*.
        1. Assert: *_c_* is in « -1, 0, 1 ».
        1. Return *_c_*.
      </emu-alg>
      <emu-note>
        <p>This operation compares Decimal128 values as digit strings. Thus, for example, 1.2 and 1.20 are considered distinct values for this operation. To compare by mathematical value, see <emu-xref href="#sec-decimal.prototype.lessthan">lessThan</emu-xref> and <emu-xref href="#sec-decimal.prototype.equals">equals</emu-xref>.</p>
      </emu-note>
    </emu-clause>
    <emu-clause id="sec-decimal-method-round">
      <h1>Decimal128.prototype.round ( _numFractionalDigits_ [ , _mode_ ] )</h1>
      <p>Rounds *this* value according to the specified rounding mode, returning a fresh result. The result will have at most _numFractionalDigits_ after the decimal point.</p>
      <emu-note>
        <p>If _mode_ is neither *undefined* nor a String, throw a *TypeError* exception.</p>
        <p>If _mode_ is not a <emu-xref href="#dfn-rounding-mode">rounding mode</emu-xref>, throw a *RangeError* exception.</p>
      </emu-note>
    </emu-clause>
    <emu-clause id="sec-decimal.prototype.tostring">
      <h1>Decimal128.prototype.toString ( [ _options_ ] )</h1>
      <p>Renders *this* value as a <emu-xref href="#dfn-signed-decimal-string">signed decimal string</emu-xref>. _options_, is defined, is supposed to be a plain object. If _options_ has the property *numDecimal128Digits* and the value of that property is a non-negative Number, the return value will be a string that has exactly that many digits after the decimal point, possibly with the addition of trailing zeros.</p>
      <emu-alg>
        1. Let _roundingMode_ be [[_options_]][roundingMode]].
        1. If _roundingMode_ is not one of *"ceil"*, *"floor"*, *"expand"*, *"trunc"*, *"halfEven"*, *"halfExpand"*, *"halfCeil"*, *"halfFloor"*, or *"halfTrunc"*, then
          1. set _roundingMode_ to *"halfEven"*.
        1. Let _format_ be [[_options_]][format]].
        1. If _format_ is not one of *"decimal"* or *"exponential"*, then
          1. set _format_ to *"decimal"*.
        1. If _format_ is *"decimal*", then
          1. return the result of calling IEEE 754's convertToDecimalCharacter with a second argument ensuring that a <emu-xref href="#dfn-signed-decimal-string">signed decimal string</emu-xref> is generated. TODO convertToDecimalCharacter is unspecified, so we need to do that work here.
        1. Return the result of calling IEEE 754's convertToDecimalCharacter with a second argument ensuring that a <emu-xref href="#dfn-signed-exponential-string">signed exponential string</emu-xref> is generated. TODO convertToDecimalCharacter is unspecified, so we need to do that work here.
      </emu-alg>
    </emu-clause>
    <emu-clause id="sec-decimal.prototype.valueof">
      <h1>Decimal128.prototype.valueOf ( _x_ )</h1>
      <p>Throw *TypeError*.</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-numbers-and-dates">
  <h1>Numbers and Dates</h1>
  <emu-clause id="sec-number-objects">
    <h1>Number Objects</h1>
    <emu-clause id="sec-number-constructor">
      <h1>The Number Constructor</h1>
      <emu-clause id="sec-number-constructor-number-value">
	<h1>Number ( _value_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If _value_ is present, then
            1. Let _serialized_ be the result of ! Call([_value_].[[toString]], _value_).
            1. If _value_ is a Decimal128 object, return ! ToNumber(_serialized_).
            1. Let _prim_ be ? ToNumeric(_value_).
            1. If _prim_ is a BigInt, let _n_ be 𝔽(ℝ(_prim_)).
            1. Otherwise, let _n_ be _prim_.
          1. Else,
            1. Let _n_ be *+0*<sub>𝔽</sub>.
          1. If NewTarget is *undefined*, return _n_.
          1. Let _O_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%Number.prototype%"*, « [[NumberData]] »).
          1. Set _O_.[[NumberData]] to _n_.
          1. Return _O_.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
  <emu-clause id="sec-bigint-objects">
    <h1>BigInt Objects</h1>
    <emu-clause id="sec-bigint-constructor">
      <h1>The BigInt Constructor</h1>
      <emu-clause id="sec-bigint-constructor-number-value">
        <h1>BigInt ( _value_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If NewTarget is not *undefined*, throw a *TypeError* exception.
          1. <ins>If _value_ is a Decimal128 object, return ? Decimal128ToBigInt(_value_).</ins>
          1. Let _prim_ be ? ToPrimitive(_value_, ~number~).
          1. If _prim_ is a Number, return ? NumberToBigInt(_prim_).
          1. Otherwise, return ? <emu-meta suppress-effects="user-code">ToBigInt(_prim_)</emu-meta>.
        </emu-alg>

         <emu-clause id="sec-numbertobigint" type="abstract operation">
          <h1>
            <ins>Decimal128ToBigInt (
            _number_: a Decimal128 object,
            ): either a normal completion containing a BigInt or a throw completion</ins>
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. If IsIntegralDecimal128(_number_) is *false*, throw a *RangeError* exception.
            1. Return ℤ(ℝ(_number_)).
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>
