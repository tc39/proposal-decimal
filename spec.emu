<!DOCTYPE html>
<meta charset="utf-8">
<link rel="stylesheet" href="./spec.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">
<script src="./spec.js"></script>
<pre class="metadata">
title: Decimal
status: proposal
stage: 1
contributors: Jesse Alama, Waldemar Horwat
location: https://github.com/tc39/proposal-decimal/
</pre>

<emu-intro id="sec-decimal-intro-">
  <h1>Introduction</h1>
  <p>This specification consists of two parts:</p>
  <ul>
    <li>The specification of the <a href="https://github.com/tc39/proposal-decimal/" title="Decimal proposal (GitHub)">Decimal proposal</a> and everything related to it, proposed to be added to ECMA-262 in new sections;</li>
    <li>A list of amendments to be made to ECMA-402.</li>
  </ul>
</emu-intro>

<emu-clause id="sec-the-decimal-object">
  <h1>The Decimal128 Object</h1>

  <emu-intro id="sec-decimal-intro">
    <h1>Introduction</h1>
    <p>Decimal128 values, as specified here, are intended to represent base-10 (decimal) numbers as specified in <emu-xref href="#sec-bibliography">IEEE 754-2019 Decimal128</emu-xref>. Only a subset of the values specified in IEEE 754-2019 Decimal128 are modeled here, namely, the set of *canonicalized* values, which can be intuitively understood as decimal numbers without trailing zeroes. A Decimal128 value, as specified here, is one of the following six kinds of values:</p>

    <ul>
      <li>*NaN*<sub>𝔻</sub>, represending a decimal not-a-number</li>
      <li>*+∞*<sub>𝔻</sub>, representing positive infinity as a decimal,</li>
      <li>*-∞*<sub>𝔻</sub>, representing negative infinity as a decimal,</li>
      <li>*+0*<sub>𝔻</sub>, represending non-negative zero as a decimal value</li>
      <li>*−0*<sub>𝔻</sub>, representing negative zero as a decimal value, or</li>
      <li>a mathematical value _v_ for which there exists an integer _q_ satisfing the following conditions:</li>
      <ul>
        <li>-6176 ≤ _q_ ≤ 6111,</li>
        <li>v × 10<sup>−_q_</sup> is an integer _n_ such that 0 < abs(_n_) < 10<sup>34</sup></li>
      </ul>
    </ul>
    <emu-note>
      <p>A Decimal128 value is not an ECMAScript language value.</p>
    </emu-note>
    <p>A Decimal128 value is said to be <dfn id="dfn-decimal128-finite">finite</dfn> if it is either a mathematical value, *+0*<sub>𝔻</sub> or *-0*<sub>𝔻</sub>. A <dfn id="dfn-decimal128-zero">zero</dfn> Decimal128 value is one of *+0*<sub>𝔻</sub> or *-0*<sub>𝔻</sub>. A finite non-zero Decimal128 value is a mathematical value satisfying the conditions listed above.</p>
    <p>The <dfn id="decimal128-mathematical-value">mathematical value</dfn> <emu-eqn id="dfn-decimal128-mv" aoid="MV">MV(_x_)</emu-eqn> of a finite Decimal128 value _x_ is defined as follows:</p>
    <ul>
      <li>MV(*+0*<sub>𝔻</sub>) = 0</li>
      <li>MV(*-0*<sub>𝔻</sub>) = 0</li>
      <li>MV(_v_) = _v_ (provided _v_ is neither *+0*<sub>𝔻</sub> nor *-0*<sub>𝔻</sub>)</li>
    </ul>
    <p>Decimal128 values defined in this section are ECMAScript analogues of <emu-xref href="#sec-bibliography">IEEE 754-2019 Decimal128 values</emu-xref>. It is important to note that the full spectrum of values defined by IEEE 754-2019 Decimal128 are not available here, namely non-canonical Decimal128 values, which can be underdtood as values containing trailing zeroes. Also, this specification simplifies IEEE 754-2019 Decimal128 in a further way: there is only one Decimal128 value, NaN<sub>𝔻</sub>, representing all possible IEEE 754-2019 Decimal128 NaN values.</p>
    <p>A <dfn id="dfn-decimal128-rounding-mode">Decimal128 rounding mode</dfn> is one of the String values *"ceil"*, *"floor"*, *"trunc"*, *"halfExpand"*, and *"halfEven"*. The <dfn id="dfn-decimal128-default-rounding-mode">default rounding mode</dfn> is the String value *"halfEven"*.</p>
    <emu-table id="table-decimal128-rounding-modes">
      <emu-caption>Rounding modes in Decimal128 compared to IEEE 754-2019 rounding modes</emu-caption>
      <table class="real-table">
        <thead>
          <tr>
            <th>Decimal128 rounding mode</th>
            <th>Description</th>
            <th>IEEE 754-2019 rounding mode</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>*"ceil"*</td>
            <td>Toward positive infinity</td>
            <td>*"roundTowardPositive"*</td>
          </tr>
          <tr>
            <td>*"floor"*</td>
            <td>Toward negative infinity</td>
            <td>*"roundTowardNegative"*</td>
          </tr>
          <tr>
            <td>*"trunc"*</td>
            <td>Toward zero</td>
            <td>*"roundTowardZero"*</td>
          </tr>
          <tr>
            <td>*"halfExpand"*</td>
            <td>Ties away from zero</td>
            <td>*"roundTiesToAway"*</td>
          </tr>
          <tr>
            <td>*"halfEven"*</td>
            <td>Ties toward an even rounding increment multiple</td>
            <td>*"roundTiesToEven"*</td>
          </tr>
        </tbody>
      </table>
      <emu-note>The above five rounding modes are defined in IEEE 754-2019. This table is offered for implementors who may need to convert the Decimal128 rounding modes defined here into a library that may use the official IEEE 754-2019 rounding mode names. Additional rounding modes are used elsewhere in this specification, such as in <emu-xref href="#table-intl-rounding-modes">Intl.NumberFormat</emu-xref>.</emu-note>
    </emu-table>
    <p>For every non-NaN Decimal128 value, we define its <emu-eqn id="dfn-decimal128-sign" aoid="sign">sign</emu-eqn> as follows:</p>
    <ul>
      <li>sign(*+∞*<sub>𝔻</sub>) = 1</li>
      <li>sign(*-∞*<sub>𝔻</sub>) = -1</li>
      <li>sign(*+0*<sub>𝔻</sub>) = 1</li>
      <li>sign(*−0*<sub>𝔻</sub>) = -1</li>
      <li>sign(_v_) = _v_ / abs(_v_) for all other Decimal128 values _v_</li>
    </ul>
    <p>For every finite non-zero Decimal128 value _v_ there exists a unique integer _e_ and mathematical value _s_ such that</p>
    <ol>
      <li>_v_ = _s_ × 10<sup>_e_</sup></li>
      <li>1 ≤ abs(_s_) < 10</li>
    </ol>
    <p>We call _e_ the <dfn id="dfn-decimal128-exponent">exponent</dfn> and _s_ the <dfn id="dfn-decimal128-significand">significand</dfn> of _v_. The exponent and significand are undefined for NaN, non-finite, and zero Decimal128 values.</p>
    <emu-note>
      <p>The significand of a finite non-zero Decimal128 value is a rational number.</p>
    </emu-note>
    <emu-note>
      <p>The exponent _e_ of finite non-zero Decimal128 values is an integer satisfying 6144 ≥ _e_ ≥ -6176.</p>
    </emu-note>
    <p>A finite non-zero Decimal128 value is <dfn id="dfn-decimal128-normalized">normalized</dfn> if its exponent _e_ satisfies 6144 ≥ _e_ ≥ -6143. A finite non-zero Decimal128 value is <dfn id="dfn-decimal128-denormalized-">denormalized</dfn> if its exponent _e_ satisfies -6144 ≥ _e_ ≥ -6176.</p>
    <p>For a proper discussion of rounding, we need to separate how rounding occurs with normalized compared with denormlized values. For a normalized Decimal128 value we define its <dfn>truncated exponent</dfn> as equal to its exponent. For zero or denormalized Decimal128 values we define the truncated exponent as the constant -6143. Given this, we define the <dfn>scaled significand</dfn> of a finite Decimal128 value as follows:</p>
    <ul>
      <li>The scaled significand of a zero Decimal128 value is 0.</li>
      <li>The scaled significand of a non-zero Decimal128 value _v_ is _v_ × 10<sup>33</sup> − _te_</sup>, where _te_ is the truncated exponent of _x_.</li>
    </ul>
    <emu-note>
      <p>The scaled significand of a finite Decimal128 value is always an integer whose absolute value is less than 10<sup>34</sup>.</p>
    </emu-note>
  </emu-intro>
  <emu-clause id="sec-decimal-abstract-ops">
    <h1>Abstract Operations</h1>

    <emu-clause id="sec-decimal128-roundtodecimal128domain" type="abstract operation">
      <h1>RoundToDecimal128Domain(
        _v_: a mathematical value,
        optional _roundingMode_: a Decimal128 rounding mode
      ): *+∞*<sub>𝔻</sub>, *-∞*<sub>𝔻</sub>, *+0*<sub>𝔻</sub>, *−0*<sub>𝔻</sub>, or a mathematical value
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It computes the closest approximation to a given mathematical value, rounded according to the given rounding mode, that is available within the limits of Decimal128.</dd>
      </dl>
      <emu-alg>
        1. If _v_ = 0, return *+0*<sub>𝔻</sub>.
        1. If v < 0, then
          1. Let _reverseRoundingMode_ be _roundingMode_.
          1. If _roundingMode_ is *"floor"*, set _reverseRoundingMode_ to *"ceil"*.
          1. If _roundingMode_ is *"ceil"*, set _reverseRoundingMode_ to *"floor"*.
          1. Let _d_ be RoundToDecimal128Domain(–_v_, _reverseRoundingMode_).
          1. If _d_ is *+∞*<sub>𝔻</sub>, return *–∞*<sub>𝔻</sub>.
          1. If _d_ is *+0*<sub>𝔻</sub>, return *−0*<sub>𝔻</sub>.
          1. Assert: _d_ is a mathematical value.
          1. Return –_d_.
        1. Let _e_ be the unique integer such that 10<sup>_e_</sup> ≤ _v_ < 10<sup>_e_+1</sup>.
        1. Let _te_ be _e_ − 33.
        1. If _te_ < –6176, set _te_ to –6176.
        1. Let _m_ be _v_ × 10<sup>–_te_</sup>.
        1. Let _rounded_ be ApplyRoundingModeToPositive(_m_, _roundingMode_).
        1. If _rounded_ = 10<sup>34</sup>, then
          1. Set _te_ to _te_ + 1.
          1. Set _rounded_ = to 10<sup>33</sup>.
        1. If _te_ > 6111, return *+∞*<sub>𝔻</sub>.
        1. If _rounded_ = 0, return *+0*<sub>𝔻</sub>.
        1. Return _rounded_ × 10<sup>_te_</sup>.
      </emu-alg>

      <emu-clause id="sec-decimal128-applyroundingmodetopositive" type="abstract operation">
        <h1>ApplyRoundingModeToPositive(
          _m_: a positive mathematical value,
          _roundingMode_: a Decimal128 rounding mode
        ): an integer
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It computes the closest integer approximation to a given positive mathematical value, rounded according to the given rounding mode.</dd>
        </dl>
        <emu-alg>
          1. Let _mLow_ be floor(_m_).
          1. Let _fraction_ be _m_ – _mLow_.
          1. If _fraction_ = 0, return _mLow_.
          1. Let _mHigh_ be _mLow_ + 1.
          1. If _roundingMode_ is *"floor"* or *"trunc"*, return _mLow_.
          1. If _roundingMode_ is *"ceil"*, return _mHigh_.
          1. If _fraction_ < 0.5, return _mLow_.
          1. If _fraction_ > 0.5, return _mHigh_.
          1. If _roundingMode_ is *"halfExpand"*, return _mHigh_.
          1. If _mLow_ is an even integer, return _mLow_.
          1. Return _mHigh_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-decimal128-abs" type="abstract operation">
      <h1>
        Decimal128Abs (
          _argument_ : a Decimal128 value
        ): a Decimal128 value
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It computes the absolute value of a Decimal128 value</dd>
      </dl>
      <emu-alg>
        1. If _argument_ is *NaN*<sub>𝔻</sub>, return *NaN*<sub>𝔻</sub>.
        1. If _argument_ is *+∞*<sub>𝔻</sub> or *-∞*<sub>𝔻</sub>, return *+∞*<sub>𝔻</sub>.
        1. If _argument_ is *+0*<sub>𝔻</sub> or *−0*<sub>𝔻</sub>, return *+0*<sub>𝔻</sub>.
        1. Otherwise, return abs(_argument_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-decimal128-negate" type="abstract operation">
      <h1>
        Decimal128Negate (
          _argument_ : a Decimal128 value
        ): a Decimal128 value
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It computes the negation of a Decimal128 value</dd>
      </dl>
      <emu-alg>
        1. If _argument_ is *NaN*<sub>𝔻</sub>, return *NaN*<sub>𝔻</sub>.
        1. If _argument_ is *+∞*<sub>𝔻</sub>, return *-∞*<sub>𝔻</sub>.
        1. If _argument_ is *-∞*<sub>𝔻</sub>, return *+∞*<sub>𝔻</sub>.
        1. If _argument_ is *+0*<sub>𝔻</sub>, return *−0*<sub>𝔻</sub>.
        1. If _argument_ is *−0*<sub>𝔻</sub>, return *+0*<sub>𝔻</sub>.
        1. Otherwise, return −_argument_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-decimal128-canonicalizedecimalstring" type="abstract operation">
      <h1>
        CanonicalizeDecimalString (
          _digits_ : a String
        ): a String
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It removes trailing zeroes, if any, from _digits_, which is assumed to be a string of digits, possibily followed by a *"."* and a non-empty sequence of digits.</dd>
      </dl>
      <emu-alg>
        1. If _digits_ does not contain the substring *"."*, return _digits_.
        1. If the final code unit of _digits_ is not the code unit 0x0030 (DIGIT ZERO), return _digits_.
        1. Let _lhs_ be the substring of _digits_ up to the first occurrence of the string *"."*.
        1. Let _rhs_ be the substring of _digits_ starting at the first code point after the first occurrence of the string *"."*.
        1. Let _noTrailingZeroes_ be the shortest substring of _rhs_ that does not terminate with a sequence of the code point 0x0030 (DIGIT ZERO).
        1. If _noTrailingZeroes_ is *""*, return _lhs_.
        1. Otherwise, return the concatenation of _lhs_, *"."*, and _noTrailingZeroes_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-decimal128-decimal128todecimalstring" type="abstract operation">
      <h1>
        Decimal128ToDecimalString (
          _argument_ : a Decimal128 value
        ): a String
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It renders _argument_ as a string in decimal notation, regardless of how many decimal digits would be required.</dd>
      </dl>
      <emu-alg>
        1. If _argument_ is *NaN*<sub>𝔻</sub>, return *"NaN"*.
        1. If _argument_ is *+∞*<sub>𝔻</sub>, return *"Infinity"*.
        1. If _argument_ is *-∞*<sub>𝔻</sub>, return *"-Infinity"*.
        1. Let _sign_ be sign(_argument_).
        1. If _sign_ = -1, let _prefix_ be *"-"*, else let _prefix_ be *""*.
        1. Let _argument_ be Decimal128Abs(_argument_).
        1. If _argument_ is *+0*<sub>𝔻</sub>, return the string concatenation of _prefix_ and *"0"*.
        1. Let _q_ be the smallest integer such that _argument_ × 10<sup>−_q_</sup> is an integer.
        1. Let _n_ be _argument_ × 10<sup>−_q_</sup>.
        1. Assert: 0 < _n_ < 10<sup>34</sup>.
        1. Let _digits_ be the unique decimal string representation of _n_ without leading zeroes.
        1. Let _numDigits_ be the length of _digits_.
        1. Let _integerPart_ be the substring of _digits_ from 0 to _numDigits_.
        1. If _argument_ is an integer, then
          1. Assert: _integerPart_ is not *""*.
          1. Return _integerPart_.
        1. If _integerPart_ is *""*, set _integerPart_ to *"0"*.
        1. Let _nonIntegerPart_ be the substring of _digits_ from _numDigits_.
        1. Let _renderedAbsoluteValue_ be the concatenation of _integerPart, *"."*, and _nonIntegerPart_.
        1. Let _s_ be the concatenation of _prefix and _renderedAbsoluteValue_.
        1. Return CanonicalizeDecimalString(_s_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-decimal128toexponentialstring" type="abstract operation">
      <h1>
        Decimal128ToExponentialString (
          _argument_ : a Decimal128 value
        ): a String
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It renders _argument_ in exponential notation.</dd>
      </dl>
      <emu-alg>
        1. If _argument_ is *NaN*<sub>𝔻</sub>, return *"NaN"*.
        1. If _argument_ is *+∞*<sub>𝔻</sub>, return *"Infinity"*.
        1. If _argument_ is *-∞*<sub>𝔻</sub>, return *"-Infinity"*.
        1. Let _sign_ be sign(_argument_).
        1. Let _argument_ be Decimal128Abs(_argument_).
        1. If _sign_ = -1, let _prefix_ be *"-"*, else let _prefix_ be *""*.
        1. If _argument_ is *+0*<sub>𝔻</sub> or *−0*<sub>𝔻</sub>, return the string concatenation of _prefix_ and *"0e+0".
        1. Let _q_ be the smallest integer such that _argument_ × 10<sup>−_q_</sup> is an integer.
        1. Let _n_ be _argument_ × 10<sup>−_q_</sup>.
        1. Assert: 0 < _n_ < 10<sup>34</sup>.
        1. Let _coefficientStr_ be the unique decimal string representation of _n_ without leading zeroes.
        1. Let _e_ be the unique integer for which 1 ≤ _n_ × 10<sup>_e_</sup> < 10.
        1. Let _adjustedExp_ be -_e_.
        1. Let _adjustedExpStr_ be the unique decimal string representation of _adjustedExp_ without leading zeroes.
        1. Let _firstDigit_ be the substring of _coefficientStr_ from 0 to 1.
        1. Let _remainingDigits_ be the substring of _coefficientStr_ starting at 1.
        1. Return the concatenation of _prefix_, _firstDigit_, *"."*, _remainingDigits_, *"e"*, and _adjustedExpStr_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-decimal128-value-to-object" type="abstract operation">
      <h1>
        Decimal128ValueToObject (
          _argument_ : a Decimal128 value
        ): a Decimal128 object
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It converts a Decimal128 value to a Decimal128 object.</dd>
      </dl>
      <emu-alg>
        1. Let _O_ be ! OrdinaryCreateFromConstructor(%Decimal128%, *"%Decimal128.prototype%"*, « [[Decimal128Data]] »).
        1. Set _O_.[[Decimal128Data]] to _argument_.
        1. Return _O_.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-the-decimal-constructor">
    <h1>The Decimal128 Constructor</h1>
    <p>The Decimal128 constructor:</p>
    <ul>
      <li>is <dfn>%Decimal128%</dfn>.</li>
      <li>is the initial value of the the *"Decimal128"* property of the global object.</li>
      <li>creates and initializes a new Decimal128 object when called as a constructor</li>
      <li>may be used as the value of an *extends* clause of a class definition. Subclass constructors that intend to inherit the specified Decimal128 behaviour must include a *super* call to the Decimal128 constructor to create and initialize the subclass instance with a [[Decimal128Data]] internal slot.</li>
    </ul>
    <emu-clause id="sec-the-decimal128-constructor-value">
      <h1>Decimal128 ( _x_ )</h1>
      <emu-alg>
        1. If NewTarget is *undefined*, throw a *TypeError* exception.
        1. Let _toParse_ be *undefined*.
        1. If _x_ is a BigInt, set _toParse_ to BigInt::toString(_x_, 10).
        1. Otherwise, if _x_ is a Number, set _toParse_ to ! Call(%Number.prototype.toExponential%, _x_, « »).
        1. Otherwise, if _x_ is a String, set _toParse_ to _x_.
        1. If _toParse_ is not a String, throw a *TypeError* exception.
        1. Let _O_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%Decimal128.prototype%"*, « [[Decimal128Data]] »).
        1. If _toParse_ is *"NaN"*, then
          1. Set _O_.[[Decimal128Data]] to *NaN*<sub>𝔻</sub>.
        1. Else,
          1. Let _parseResult_ be ParseText(_toParse_, |StrDecimalLiteral|).
          1. If _parseResult_ is a List of errors, throw a *SyntaxError* exception.
          1. Let _decimalValue_ be ? StringDecimalValue of _parseResult_.
          1. Set _O_.[[Decimal128Data]] to _decimalValue_.
        1. Return _O_.
      </emu-alg>
      <emu-note>
        <p>Given a Number argument, the constructor converts it to a String using the <emu-xref href="#sec-number.prototype.tostring">toString</emu-xref> method (with no arguments). In some cases, this may not be desited. In some use cases, given a Number, one may wish to call the Decimal128 constructor not with the number but rather with, for instance, the result of calling <emu-xref href="#sec-number.prototype.tofixed">toFixed</emu-xref> or <emu-xref href="#sec-number.prototype.toprecision">toPrecision</emu-xref> on the Number, thereby ensuring a certain level of precision that may get lost when using Number’s toString.</p>
      </emu-note>
      <emu-clause id="sec-runtime-semantics-stringdecimalvalue" type="sdo">
        <h1>Runtime Semantics: StringDecimalValue ( ): either a normal completion containing a Decimal128 value or a throw completion</h1>
        <dl class="header">
        </dl>
        <emu-grammar>StrDecimalLiteral ::: `-` StrUnsignedDecimalLiteral</emu-grammar>
        <emu-alg>
          1. Let _a_ be ? StringDecimalValue of |StrUnsignedDecimalLiteral|.
          1. If _a_ is *+∞*<sub>𝔻</sub>, return *-∞*<sub>𝔻</sub>.
          1. Assert: _a_ is finite.
          1. If _a_ is *+0*<sub>𝔻</sub>, return *−0*<sub>𝔻</sub>.
          1. Return −_a_.
        </emu-alg>
        <emu-grammar>StrUnsignedDecimalLiteral ::: `Infinity`</emu-grammar>
        <emu-alg>
          1. Return *+∞*<sub>𝔻</sub>.
        </emu-alg>
        <emu-grammar>StrUnsignedDecimalLiteral ::: DecimalDigits `.` DecimalDigits? ExponentPart?</emu-grammar>
        <emu-alg>
          1. Let _a_ be MV of the first |DecimalDigits|.
          1. If the second |DecimalDigits| is present, then
            1. Let _b_ be MV of the second |DecimalDigits|.
            1. Let _n_ be the number of code points in the second |DecimalDigits|.
          1. Else,
            1. Let _b_ be 0.
            1. Let _n_ be 0.
          1. If |ExponentPart| is present, let _e_ be MV of |ExponentPart|. Otherwise, let _e_ be 0.
          1. Return RoundToDecimal128Domain((_a_ + (_b_ × 10<sup>−_n_</sup>)) × 10<sup>_e_</sup>).
        </emu-alg>
        <emu-grammar>StrUnsignedDecimalLiteral ::: `.` DecimalDigits ExponentPart?</emu-grammar>
        <emu-alg>
          1. Let _b_ be MV of |DecimalDigits|.
          1. If |ExponentPart| is present, let _e_ be MV of |ExponentPart|. Otherwise, let _e_ be 0.
          1. Let _n_ be the number of code points in |DecimalDigits|.
          1. Let _newValue_ be _b_ × 10<sup>_e_ − _n_</sup>.
          1. Return RoundToDecimal128Domain(_newValue_).
        </emu-alg>
        <emu-grammar>StrUnsignedDecimalLiteral ::: DecimalDigits ExponentPart?</emu-grammar>
        <emu-alg>
          1. Let _a_ be MV of |DecimalDigits|.
          1. If |ExponentPart| is present, let _e_ be MV of |ExponentPart|. Otherwise, let _e_ be 0.
          1. Return RoundToDecimal128Domain(_a_ × 10<sup>_e_</sup>).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-decimal-prototype-properties">
  <h1>Properties of the Decimal128 Prototype</h1>

  <emu-clause id="sec-decimal128.prototype.isnan">
    <h1>Decimal128.prototype.isNaN ( )</h1>
    <p>This method returns a Boolean value indicating whether a Decimal128 object represents *NaN*<sub>𝔻</sub>.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Let _d_ be _O_.[[Decimal128Data]].
      1. If _d_ is *NaN*<sub>𝔻</sub>, return *true*.
      1. Otherwise, return *false*.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-decimal128.prototype.isfinite">
    <h1>Decimal128.prototype.isFinite ( )</h1>
    <p>This method returns a Boolean value indicating whether a Decimal128 object represents *+∞*<sub>𝔻</sub> or *-∞*<sub>𝔻</sub>.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Let _d_ be _O_.[[Decimal128Data]].
      1. If _d_ is *NaN*<sub>𝔻</sub>, *+∞*<sub>𝔻</sub> or *-∞*<sub>𝔻</sub>, return *false*.
      1. Otherwise, return *true*.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-decimal128.prototype.exponent">
    <h1>Decimal128.prototype.exponent ( )</h1>
    <p>This method returns a Number value represents the <emu-xref href="#dfn-decimal128-exponent">exponent</emu-xref>, which is the integer _n_ for which the current Decimal128 object, _v_, there exists a mathematical value _s_ such that _v_ = _s_ × 10<sup>_e_</sup> and 1 ≤ abs(_s_) < 10. If the current Decimal128 object is infinite, it returns *+∞*. If the current Decimal128 object is a zero, it returns *-∞*.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Let _d_ be _O_.[[Decimal128Data]].
      1. If _d_ is *NaN*<sub>𝔻</sub>, return *NaN*<sub>𝔽</sub>.
      1. If _d_ is *+∞*<sub>𝔻</sub> or *-∞*<sub>𝔻</sub>, return *+∞*<sub>𝔽</sub>.
      1. If _d_ is *+0*<sub>𝔻</sub> or *−0*<sub>𝔻</sub>, return *-∞*<sub>𝔽</sub>.
      1. Let _e_ be the unique integer for which there exists a mathematical value _s_ such that _d_ = _s_ × 10<sup>_e_</sup> and 1 ≤ abs(_s_) < 10.
      1. Return 𝔽(_e_).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-decimal128.prototype.mantissa">
    <h1>Decimal128.prototype.mantissa ( )</h1>
    <p>This method returns a Decimal128 value representing the <emu-xref href="#dfn-decimal128-significand">significand</emu-xref> of the current Decimal128 object, which is the mathematical value _n_ for which the current Decimal128 object, _v_, there exists an integer _e_ such such that _v_ = _s_ × 10<sup>_e_</sup> and 1 ≤ abs(_s_) < 10. IF the current Decimal128 object is a zero, it returns a zero.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Let _d_ be _O_.[[Decimal128Data]].
      1. If _d_ is *NaN*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔽</sub>).
      1. If _d_ is *+∞*<sub>𝔻</sub> or *-∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*+∞*<sub>𝔽</sub>).
      1. If _d_ is *+0*<sub>𝔻</sub>, return Decimal128ValueToObject(*+0*<sub>𝔻</sub>).
      1. If _d_ is *−0*<sub>𝔻</sub>, return Decimal128ValueToObject(*-0*<sub>𝔻</sub>).
      1. Let _e_ be the truncated exponent of _d_.
      1. Let _s_ be the unique mathematical value such that _d_ = _s_ × 10<sup>_e_</sup> and 1 ≤ abs(_s_) < 10.
      1. Return Decimal128ValueToObject(_s_).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-decimal128.prototype.abs">
    <h1>Decimal128.prototype.abs ( )</h1>
    <p>This method computes the absolute value of a Decimal128 object.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Let _d_ be _O_.[[Decimal128Data]].
      1. Return Decimal128ValueToObject(Decimal128Abs(_d_)).
    </emu-alg>
    <emu-note>
      <p>This operation follows the specification in Section 5.5.1 of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal128.prototype.negate">
    <h1>Decimal128.prototype.negate ( )</h1>
    <p>This method inverts the sign of a Decimal128 object.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Let _d_ be _O_.[[Decimal128Data]].
      1. Return Decimal128ValueToObject(Decimal128Negate(_d_)).
    </emu-alg>
    <emu-note>
      <p>This operation follows the specification in Section 5.5.1 of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal128.prototype.add">
    <h1>Decimal128.prototype.add ( _x_ )</h1>
    <p>This method computes the addition of a Decimal128 object with another one. The computation proceeds as though infinite precision and unbounded range were available, rounding, if necessary.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Perform ? RequireInternalSlot(_x_, [[Decimal128Data]]).
      1. Let _d1_ be _O_.[[Decimal128Data]].
      1. Let _d2_ be _x_.[[Decimal128Data]].
      1. If _d1_ or _d2_ is *NaN*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
      1. If _d1_ is *+∞*<sub>𝔻</sub> or _d2_ is *+∞*<sub>𝔻</sub>, then
        1. If _d1_ is *-∞*<sub>𝔻</sub> or _d2_ is *-∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
        1. Return Decimal128ValueToObject(*+∞*<sub>𝔻</sub>).
      1. If _d1_ is *-∞*<sub>𝔻</sub> or _d2_ is *-∞*<sub>𝔻</sub>, then
        1. Assert: _d1_ is not *+∞*<sub>𝔻</sub> and _d2_ is not *+∞*<sub>𝔻</sub>.
        1. Return Decimal128ValueToObject(*-∞*<sub>𝔻</sub>).
      1. If _d1_ is *−0*<sub>𝔻</sub>, return Decimal128ValueToObject(_d2_).
      1. If _d2_ is *−0*<sub>𝔻</sub>, return Decimal128ValueToObject(_d1_).
      1. If _d1_ is *+0*<sub>𝔻</sub>, set _d1_ to 0.
      1. If _d2_ is *+0*<sub>𝔻</sub>, set _d2_ to 0.
      1. Let _sum_ be _d1_ + _d2_.
      1. Return Decimal128ValueToObject(RoundToDecimal128Domain(_sum_)).
    </emu-alg>
    <emu-note>
      <p>This operation follows the specification in Section 5.4.1 of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal128.prototype.subtract">
    <h1>Decimal128.prototype.subtract ( _x_ )</h1>
    <p>This method computes subtracts the given Decimal128 object from the current one. The computation proceeds as though infinite precision and unbounded range were available, rounding, if necessary.</p>
    <p>It performs the following steps when called:</p>
      <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Perform ? RequireInternalSlot(_x_, [[Decimal128Data]]).
      1. Let _d1_ be _O_.[[Decimal128Data]].
      1. Let _d2_ be _x_.[[Decimal128Data]].
      1. If _d1_ or _d2_ is *NaN*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
      1. If _d1_ is *+∞*<sub>𝔻</sub> or *-∞*<sub>𝔻</sub>, then
        1. If _d2_ is _d1_, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
        1. Return Decimal128ValueToObject(_d1_).
      1. If _d2_ is *+∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*-∞*<sub>𝔻</sub>).
      1. If _d2_ is *-∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*+∞*<sub>𝔻</sub>).
      1. If _d1_ is *−0*<sub>𝔻</sub> and _d2_ is *+0*<sub>𝔻</sub>, return Decimal128ValueToObject((*−0*<sub>𝔻</sub>)).
      1. If _d1_ is *+0*<sub>𝔻</sub> or *−0*<sub>𝔻</sub>, set _d1_ to 0.
      1. If _d2_ is *+0*<sub>𝔻</sub> or *−0*<sub>𝔻</sub>, set _d2_ to 0.
      1. Let _difference_ be _d1_ − _d2_.
      1. Return Decimal128ValueToObject(RoundToDecimal128Domain(_difference_)).
    </emu-alg>
    <emu-note>
      <p>This operation follows the specification in Section 5.4.1 of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal128.prototype.multiply">
    <h1>Decimal128.prototype.multiply ( _x_ )</h1>
    <p>This method computes multiplies the current Decimal128 object by another one. The computation proceeds as though infinite precision and unbounded range were available, rounding, if necessary.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Perform ? RequireInternalSlot(_x_, [[Decimal128Data]]).
      1. Let _d1_ be _O_.[[Decimal128Data]].
      1. Let _d2_ be _x_.[[Decimal128Data]].
      1. If _d1_ or _d2_ is *NaN*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
      1. If _d1_ or _d2_ is *+∞*<sub>𝔻</sub>, then
        1. If _d1_ or _d2_ is a zero Decimal128 value, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
        1. If sign(_d1_) = -1 or sign(_d2_) = -1, return Decimal128ValueToObject(*-∞*<sub>𝔻</sub>).
        1. Return Decimal128ValueToObject(*+∞*<sub>𝔻</sub>).
      1. If _d1_ or _d2_ is *-∞*<sub>𝔻</sub>, then
        1. If _d1_ or _d2_ is a zero Decimal128 value, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
        1. If sign(_d1_) = -1 and sign(_d2_) = -1, return Decimal128ValueToObject(*+∞*<sub>𝔻</sub>).
        1. Return Decimal128ValueToObject(*-∞*<sub>𝔻</sub>).
      1. If _d1_ or _d2_ is *+0*<sub>𝔻</sub>, then
        1. If sign(_d1_) = -1 or sign(_d2_) = -1, return Decimal128ValueToObject(*−0*<sub>𝔻</sub>).
        1. Return Decimal128ValueToObject(*+0*<sub>𝔻</sub>).
      1. If _d1_ or _d2_ is *−0*<sub>𝔻</sub>, then
        1. If sign(_d1_) = -1 and sign(_d2_) = -1, return Decimal128ValueToObject(*+0*<sub>𝔻</sub>_).
        1. Return Decimal128ValueToObject(*−0*<sub>𝔻</sub>).
      1. Let _product_ be _d1_ × _d2_.
      1. Assert: _product_ ≠ 0.
      1. Return Decimal128ValueToObject(RoundToDecimal128Domain(_product_)).
    </emu-alg>
    <emu-note>
      <p>This operation follows the specification in Section 5.4.1 of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal128.prototype.divide">
    <h1>Decimal128.prototype.divide ( _x_ )</h1>
    <p>This method computes divides the current Decimal128 object by another one. The computation proceeds as though infinite precision and unbounded range were available, rounding, if necessary.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Perform ? RequireInternalSlot(_x_, [[Decimal128Data]]).
      1. Let _d1_ be _O_.[[Decimal128Data]].
      1. Let _d2_ be _x_.[[Decimal128Data]].
      1. If _d1_ or _d2_ is *NaN*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
      1. If _d1_ is *+∞*<sub>𝔻</sub>, then
        1. If _d2_ is *+∞*<sub>𝔻</sub> or *-∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
        1. If sign(_d2_) = -1, return Decimal128ValueToObject(*-∞*<sub>𝔻</sub>).
        1. Otherwise, return Decimal128ValueToObject(*+∞*<sub>𝔻</sub>).
      1. If _d1_ is *-∞*<sub>𝔻</sub>, then
        1. If _d2_ is *+∞*<sub>𝔻</sub> or *-∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
        1. If sign(_d2_) = -1, return Decimal128ValueToObject(*+∞*<sub>𝔻</sub>).
        1. Otherwise, return Decimal128ValueToObject(*-∞*<sub>𝔻</sub>).
      1. If _d2_ is *+∞*<sub>𝔻</sub>, then
        1. If sign(_d1_) = -1, return Decimal128ValueToObject(*−0*<sub>𝔻</sub>).
        1. Otherwise, return Decimal128ValueToObject(*+0*<sub>𝔻</sub>).
      1. If _d2_ is *-∞*<sub>𝔻</sub>, then
        1. If sign(_d1_) = -1, return Decimal128ValueToObject(*+0*<sub>𝔻</sub>).
        1. Otherwise, return Decimal128ValueToObject(*−0*<sub>𝔻</sub>).
      1. If _d2_ is *+0*<sub>𝔻</sub>, then
        1. If _d1_ is *+0*<sub>𝔻</sub> or *-0*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
        1. If _d1_ < 0, return Decimal128ValueToObject(*-∞*<sub>𝔻</sub>).
        1. Otherwise, return Decimal128ValueToObject(*+∞*<sub>𝔻</sub>).
      1. If _d2_ is *−0*<sub>𝔻</sub>, then
        1. If _d1_ is *+0*<sub>𝔻</sub> or *-0*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
        1. If _d1_ < 0, return Decimal128ValueToObject(*+∞*<sub>𝔻</sub>).
        1. Otherwise, return Decimal128ValueToObject(*-∞*<sub>𝔻</sub>).
      1. If _d1_ is *+0*<sub>𝔻</sub>, then
        1. If _d2_ < 0, return Decimal128ValueToObject(*−0*<sub>𝔻</sub>).
        1. Otherwise, return Decimal128ValueToObject(*+0*<sub>𝔻</sub>).
      1. If _d1_ is *−0*<sub>𝔻</sub>, then
        1. If _d2_ < 0, return Decimal128ValueToObject(*+0*<sub>𝔻</sub>).
        1. Otherwise, return Decimal128ValueToObject(*−0*<sub>𝔻</sub>).
      1. Let _quotient_ be _d1_ / _d2_.
      1. Return Decimal128ValueToObject(RoundToDecimal128Domain(_quotient_)).
    </emu-alg>
    <emu-note>
      <p>This operation follows the specification in Section 5.4.1 of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal128.prototype.remainder">
    <h1>Decimal128.prototype.remainder ( _x_ )</h1>
    <p>This method computes the remainder upon dividing the current Decimal128 object by another one. The computation proceeds as though infinite precision and unbounded range were available, rounding, if necessary.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Perform ? RequireInternalSlot(_x_, [[Decimal128Data]]).
      1. Let _d1_ be _O_.[[Decimal128Data]].
      1. Let _d2_ be _x_.[[Decimal128Data]].
      1. If _d1_ or _d2_ is *NaN*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
      1. If _d1_ is *+∞*<sub>𝔻</sub> or *-∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
      1. If _d2_ is *-∞*<sub>𝔻</sub> or *-∞*<sub>𝔻</sub>, return Decimal128ValueToObject(_d1_).
      1. If _d2_ is *+0*<sub>𝔻</sub> or *−0*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
      1. If _d1_ is *+0*<sub>𝔻</sub> or *−0*<sub>𝔻</sub>, return Decimal128ValueToObject(_d1_).
      1. Assert: _d2_ ≠ 0.
      1. Let _quotient_ be _d1_ / _d2_.
      1. Let _q_ be truncate(_quotient_).
      1. Let _r_ be _d1_ - (_d2_ × _q_).
      1. If _r_ = 0, and _d1_ < 0, return Decimal128ValueToObject(*−0*<sub>𝔽</sub>).
      1. Otherwise, return Decimal128ValueToObject(_r_).
    </emu-alg>
    <emu-note>
      <p>The remainder operation specified here deviates from the <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref> remainder operation (defined there in Section 5.3.1). We follow the <emu-xref href="#sec-numeric-types-number-remainder">the remainder operation for Number</emu-xref> rather than IEEE 754, which specifies that, for example, the remainder 46 and 10 is -4 rather than 6.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal128.prototype.compare">
    <h1>Decimal128.prototype.compare ( _x_ )</h1>
    <p>This method returns one of the four Number values *-1*<sub>𝔽</sub>, *+0*<sub>𝔽</sub>, *1*<sub>𝔽</sub>, and *NaN*<sub>𝔽</sub>. It compares the mathematical value of the current Decimal128 object with that of another Decimal128 object.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Perform ? RequireInternalSlot(_x_, [[Decimal128Data]]).
      1. Let _d1_ be _O_.[[Decimal128Data]].
      1. Let _d2_ be _x_.[[Decimal128Data]].
      1. If _d1_ is *NaN*<sub>𝔻</sub>, return *NaN*<sub>𝔽</sub>.
      1. If _d2_ is *NaN*<sub>𝔻</sub>, return *NaN*<sub>𝔽</sub>.
      1. If _d1_ is *+∞*<sub>𝔻</sub>, then
        1. If _d2_ is *+∞*<sub>𝔻</sub>, return *+0*<sub>𝔽</sub>.
        1. Return *1*<sub>𝔽</sub>.
      1. If _d1_ is *-∞*<sub>𝔻</sub>, then
        1. If _d2_ is *-∞*<sub>𝔻</sub>, return *+0*<sub>𝔽</sub>.
        1. Return *-1*<sub>𝔽</sub>.
      1. If _d2_ is *+∞*<sub>𝔻</sub>, return *-1*<sub>𝔽</sub>.
      1. If _d2_ is *-∞*<sub>𝔻</sub>, return *1*<sub>𝔽</sub>.
      1. If MV(_d1_) < MV(_d2_), return *-1*<sub>𝔽</sub>.
      1. If MV(_d2_) < MV(_d1_), return *1*<sub>𝔽</sub>.
      1. Otherwise, return *+0*<sub>𝔽</sub>.
    </emu-alg>
    <emu-note>
      <p>This operation combines the <code>compareQuietEqual</code>, <code>compareQuietLess</code> operations in Section 5.6.1 (and explained in Section 5.11) of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal128.prototype.equals">
    <h1>Decimal128.prototype.equals ( _x_ )</h1>
    <p>This method returns either *true*, *false*, or *undefined* according as the current Decimal128 object has the same mathematical value as the given Decimal128 object. The value *undefined* is returned if the current Decimal128 object or the argument is a NaN.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Perform ? RequireInternalSlot(_x_, [[Decimal128Data]]).
      1. Let _d1_ be _O_.[[Decimal128Data]].
      1. Let _d2_ be _x_.[[Decimal128Data]].
      1. If _d1_ is *NaN*<sub>𝔻</sub>, return *undefined*.
      1. If _d2_ is *NaN*<sub>𝔻</sub>, return *undefined*.
      1. If _d1_ is *+∞*<sub>𝔻</sub>, then
        1. If _d2_ is *+∞*<sub>𝔻</sub>, return *true*.
        1. Otherwise, return *false*.
      1. If _d1_ is *-∞*<sub>𝔻</sub>, then
        1. If _d2_ is *-∞*<sub>𝔻</sub>, return *true*.
        1. Otherwise, return *false*.
      1. If _d2_ is *+∞*<sub>𝔻</sub> or *-∞*<sub>𝔻</sub>, return *false*.
      1. If MV(_d1_) = MV(_d2_), return *true*.
      1. Otherwise, return *false*.
    </emu-alg>
    <emu-note>
      <p>This operation corresponds to the <code>compareQuietEqual</code> operation in Section 5.6.1 (and explained in Section 5.11) of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal128.prototype.notequals">
    <h1>Decimal128.prototype.notEquals ( _x_ )</h1>
    <p>This method returns either *true*, *false*, or *undefined* according as the current Decimal128 object has a different mathematical value as the given Decimal128 object. The value *undefined* is returned if the current Decimal128 object or the argument is a NaN.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Perform ? RequireInternalSlot(_x_, [[Decimal128Data]]).
      1. Let _d1_ be _O_.[[Decimal128Data]].
      1. Let _d2_ be _x_.[[Decimal128Data]].
      1. If _d1_ is *NaN*<sub>𝔻</sub>, return *undefined*.
      1. If _d2_ is *NaN*<sub>𝔻</sub>, return *undefined*.
      1. If _d1_ is *+∞*<sub>𝔻</sub>, then
        1. If _d2_ is *+∞*<sub>𝔻</sub>, return *false*.
        1. Otherwise, return *true*.
      1. If _d1_ is *-∞*<sub>𝔻</sub>, then
        1. If _d2_ is *-∞*<sub>𝔻</sub>, return *false*.
        1. Otherwise, return *true*.
      1. If _d2_ is *+∞*<sub>𝔻</sub> or *-∞*<sub>𝔻</sub>, return *true*.
      1. If MV(_d1_) ≠ MV(_d2_), return *true*.
      1. Otherwise, return *false*.
    </emu-alg>
    <emu-note>
      <p>This operation corresponds to the <code>compareQuietNotEqual</code> operation in Section 5.6.1 (and explained in Section 5.11) of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal128.prototype.lessthan">
    <h1>Decimal128.prototype.lessThan ( _x_ )</h1>
    <p>This method returns either *true*, *false* according as the current Decimal128 object has the same mathematical value as the given Decimal128 object. The value *false* is returned if the current Decimal128 object or the argument is a NaN.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Perform ? RequireInternalSlot(_x_, [[Decimal128Data]]).
      1. Let _d1_ be _O_.[[Decimal128Data]].
      1. Let _d2_ be _x_.[[Decimal128Data]].
      1. If _d1_ is *NaN*<sub>𝔻</sub>, return *false*.
      1. If _d2_ is *NaN*<sub>𝔻</sub>, return *false*.
      1. If _d1_ is *+∞*<sub>𝔻</sub>, return *false*.
      1. If _d1_ is *-∞*<sub>𝔻</sub>, then
        1. If _d2_ is *-∞*<sub>𝔻</sub>, return *false*.
        1. Otherwise, return *true*.
      1. If _d2_ is *+∞*<sub>𝔻</sub>, return *true*.
      1. If _d2_ is *-∞*<sub>𝔻</sub>, return *false*.
      1. If MV(_d1_) < MV(_d2_), return *true*.
      1. Otherwise, return *false*.
    </emu-alg>
    <emu-note>
      <p>This operation corresponds to the <code>compareQuietEqual</code> operation in Section 5.6.1 (and explained in Section 5.11) of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal128.prototype.lessthanorequal">
    <h1>Decimal128.prototype.lessThanOrEqual ( _x_ )</h1>
    <p>This method returns either *true*, *false*, or *undefined* according as the current Decimal128 object has the same or smaller mathematical value as the given Decimal128 object. The value *false* is returned if the current Decimal128 object or the argument is a NaN.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Perform ? RequireInternalSlot(_x_, [[Decimal128Data]]).
      1. Let _d1_ be _O_.[[Decimal128Data]].
      1. Let _d2_ be _x_.[[Decimal128Data]].
      1. If _d1_ is *NaN*<sub>𝔻</sub>, return *false*.
      1. If _d2_ is *NaN*<sub>𝔻</sub>, return *false*.
      1. If _d1_ is *+∞*<sub>𝔻</sub>, then
        1. If _d2_ is *+∞*<sub>𝔻</sub>, return *true*.
        1. Otherwise, return *false*.
      1. If _d1_ is *-∞*<sub>𝔻</sub>, return *true*.
      1. If _d2_ is *+∞*<sub>𝔻</sub>, return *true*.
      1. If _d2_ is *-∞*<sub>𝔻</sub>, return *false*.
      1. If MV(_d1_) ≤ MV(_d2_), return *true*.
      1. Otherwise, return *false*.
    </emu-alg>
    <emu-note>
      <p>This operation corresponds to the <code>compareQuietLessEqual</code> operation in Section 5.6.1 (and explained in Section 5.11) of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal128.prototype.greaterthan">
    <h1>Decimal128.prototype.greaterThan ( _x_ )</h1>
    <p>This method returns either *true*, *false* according as the current Decimal128 object has a greater mathematical value as the given Decimal128 object. The value *false* is returned if either the current Decimal128 object or the argument is a NaN.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Perform ? RequireInternalSlot(_x_, [[Decimal128Data]]).
      1. Let _d1_ be _O_.[[Decimal128Data]].
      1. Let _d2_ be _x_.[[Decimal128Data]].
      1. If _d1_ is *NaN*<sub>𝔻</sub>, return *false*.
      1. If _d2_ is *NaN*<sub>𝔻</sub>, return *false*.
      1. If _d1_ is *+∞*<sub>𝔻</sub>, then
        1. If _d2_ is *+∞*<sub>𝔻</sub>, return *false*.
        1. Otherwise, return *true*.
      1. If _d1_ is *-∞*<sub>𝔻</sub>, return *false*.
      1. If _d2_ is *+∞*<sub>𝔻</sub>, return *false*.
      1. If _d2_ is *-∞*<sub>𝔻</sub>, return *true*.
      1. If MV(_d1_) > MV(_d2_), return *true*.
      1. Otherwise, return *false*.
    </emu-alg>
    <emu-note>
      <p>This operation corresponds to the <code>compareQuietGreater</code> operation in Section 5.6.1 (and explained in Section 5.11) of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal128.prototype.greaterthanorequal">
    <h1>Decimal128.prototype.greaterThanOrEqual ( _x_ )</h1>
    <p>This method returns either *true*, *false** according as the current Decimal128 object has a greater or equal mathematical value as the given Decimal128 object. The value *false* is returned if the current Decimal128 object or the argument is a NaN.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Perform ? RequireInternalSlot(_x_, [[Decimal128Data]]).
      1. Let _d1_ be _O_.[[Decimal128Data]].
      1. Let _d2_ be _x_.[[Decimal128Data]].
      1. If _d1_ is *NaN*<sub>𝔻</sub>, return *false*.
      1. If _d2_ is *NaN*<sub>𝔻</sub>, return *false*.
      1. If _d1_ is *+∞*<sub>𝔻</sub>, return *true*.
      1. If _d1_ is *-∞*<sub>𝔻</sub>, return *false*.
      1. If _d2_ is *+∞*<sub>𝔻</sub>, return *false*.
      1. If _d2_ is *-∞*<sub>𝔻</sub>, return *true*.
      1. If MV(_d1_) ≥ MV(_d2_), return *true*.
      1. Otherwise, return *false*.
    </emu-alg>
    <emu-note>
      <p>This operation corresponds to the <code>compareQuietGreaterEqual</code> operation in Section 5.6.1 (and explained in Section 5.11) of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal-method-round">
    <h1>Decimal128.prototype.round ( _numFractionalDigits_ [ , _roundingMode_ ] )</h1>
    <p>This method rounds the current Decimal128 object according to the specified rounding mode, which, if omitted, is <emu-xref href="#dfn-decimal128-default-rounding-mode">the default rounding mode</emu-xref>, with rounding taking place only after _numFractionalDigits_ non-integer digits, which must be a non-negative integer Number.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. If _numFractionalDigits_ is not a Number, throw a *TypeError* exception.
      1. If _numFractionalDigits_ is not an integer, throw a *RangeError* exception.
      1. If _roundingMode_ is neither *undefined* nor a String, throw a *TypeError* exception.
      1. If _roundingMode_ is undefined, set _roundingMode_ to <emu-xref href="#dfn-decimal128-default-rounding-mode">the default rounding mode</emu-xref>.
      1. If _roundingMode_ is not a rounding mode, throw a *RangeError* exception.
      1. Let _d_ be _O_.[[Decimal128Data]].
      1. If _d_ is one of « *NaN*<sub>𝔻</sub>, *+∞*<sub>𝔻</sub>, *-∞*<sub>𝔻</sub> » return Decimal128ValueToObject(_d_).
      1. If _d_ is *+0*<sub>𝔻</sub> or *−0*<sub>𝔻</sub>, return Decimal128ValueToObject(_d_).
      1. Let _sign_ be sign(_d_).
      1. Let _scaledV_ be _d_ × 10<sup>ℝ(_numFractionalDigits_)</sup>.
      1. If _sign_ = -1, then
        1. Set _scaledV_ to −_scaledV_.
        1. If _roundingMode_ is *"floor"*, set _roundingMode_ to *"ceil"*.
        1. Else if _roundingMode_ is *"ceil"*, set _roundingMode_ to *"floor"*.
      1. Let _roundedScaledV_ be ApplyRoundingModeToPositive(_scaledV_, _roundingMode_).
      1. If _sign_ = -1, set _roundedScaledV_ to −_roundedScaledV_.
      1. Let _rescaledRoundedV_ be _roundedScaledV_ × 10<sup>−_numFractionalDigits_</sup>.
      1. Return Decimal128ValueToObject(RoundToDecimal128Domain(_rescaledRoundedV_, _roundingMode_)).
    </emu-alg>
    <emu-note>
      <p>This operation follows the specification of the rounding mode attributes discussed in Section 4.3 of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal-method-scale10">
    <h1>Decimal128.prototype.scale10 ( _n_ )</h1>
    <p>This method multiplies the current Decimal128 object by 10 raised to the given power.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. If _n_ is not a Number, throw a *TypeError* exception.
      1. If _n_ is not one of « *NaN*<sub>𝔽</sub>, *+∞*<sub>𝔽</sub>, *-∞*<sub>𝔽</sub> », then
        1. If ℝ(_n_) is not an integer, throw a *RangeError* exception.
      1. Let _d_ be _O_.[[Decimal128Data]].
      1. If _d_ is *NaN*<sub>𝔻</sub>, *+∞*<sub>𝔻</sub>, or *-∞*<sub>𝔻</sub>, return Decimal128ValueToObject(_d_).
      1. If _d_ is either *+0*<sub>𝔻</sub> nor *−0*<sub>𝔻</sub>, then
        1. If _n_ is *NaN*<sub>𝔽</sub>, return Decimal128ValueToObject(_d_).
        1. If _n_ is *+∞*<sub>𝔽</sub>, return Decimal128ValueToObject(_d_).
        1. If _n_ is *-∞*<sub>𝔽</sub>, return Decimal128ValueToObject(_d_).
        1. Otherwise, return Decimal128ValueToObject(_d_).
      1. If _n_ is *NaN*<sub>𝔽</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
      1. If _n_ is *+∞*<sub>𝔽</sub>, then
        1. If _d_ > 0, return Decimal128ValueToObject(*+∞*<sub>𝔻</sub>).
        1. Otherwise, return Decimal128ValueToObject(*-∞*<sub>𝔻</sub>).
      1. If _n_ is *-∞*<sub>𝔽</sub>, then
        1. If _d_ > 0, return Decimal128ValueToObject(*+0*<sub>𝔻</sub>).
        1. Otherwise, return Decimal128ValueToObject(*−0*<sub>𝔻</sub>).
      1. Let _w_ be v × 10<sup>ℝ(_n_)</sup>.
      1. Return Decimal128ValueToObject(RoundToDecimal128Domain(_w_)).
    </emu-alg>
    <emu-note>
      <p>This operation follows the specification of the <code>scaleB</code> operation discussed in Section 5.3.3 of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal128.prototype.tostring">
    <h1>Decimal128.prototype.toString ( [ _options_ ] )</h1>
    <p>This method generates a String representation of the current Decimal128 object, in decimal format. Its behaviour is similar to that of Number’s <emu-xref href="#sec-number.prototype.tostring">toString</emu-xref> by rendering the decimal in decimal notation, but will use exponential notation if the the magnitude of the number is less than 10<sup>-6</sup> or greater than 10<sup>34</sup>.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. If _options_ is not *undefined*, then
        1. If _options_ is not an Object, throw a *TypeError* exception.
      1. Let _d_ be _O_.[[Decimal128Data]].
      1. If _d_ is *NaN*<sub>𝔻</sub>, return "NaN".
      1. If _d_ is *+∞*<sub>𝔻</sub>, return "Infinity".
      1. If _d_ is *-∞*<sub>𝔻</sub>, return "-Infinity".
      1. If _d_ is *+0*<sub>𝔻</sub>, return *"0"*.
      1. If _d_ is *−0*<sub>𝔻</sub>, return *"-0"*.
      1. If abs(_d_) < 10<sup>-6</sup> or abs(_d_) ≥ 10<sup>34</sup>, return return Decimal128ToExponentialString(_O_).
      1. Otherwise, return Decimal128ToDecimalString(_O_).
    </emu-alg>
    <emu-note>
      <p>This operation follows the specification of the conversion of IEEE 754-2019 Decimal128 values to strings (external character sequences) discussed in Section 5.12 of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal128.prototype.tolocalestring">
    <h1>Decimal128.prototype.toLocaleString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
      <p>An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement this method as specified in the ECMA-402 specification. If an ECMAScript implementation does not include the ECMA-402 API the following specification of this method is used:</p>
      <p>This method produces a String value that represents this Decimal128 object formatted according to the conventions of the host environment’s current locale. This method is implementation-defined, and it is permissible, but not encouraged, for it to return the same thing as <emu-xref href="#sec-decimal128.prototype.tostring">`toString`</emu-xref>.</p>
      <p>The meanings of the optional parameters to this method are defined in the ECMA-402 specification; implementations that do not include ECMA-402 support must not use those parameter positions for anything else.</p>
  </emu-clause>

  <emu-clause id="sec-decimal128.prototype.toexponential">
    <h1>Decimal128.prototype.toExponential ( [ _options_ ] )</h1>
    <p>This method generates a String representation of the current Decimal128 object, in exponential format (e.g., *"123e-4"*).</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. If _options_ is not *undefined*, then
        1. If _options_ is not an Object, throw a *TypeError* exception.
      1. Return Decimal128ToExponentialString(_O_).
    </emu-alg>
    <emu-note>
      <p>This operation follows the specification of the conversion of IEEE 754-2019 Decimal128 values to strings (external character sequences) discussed in Section 5.12 of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal128.prototype.tofixed">
    <h1>Decimal128.prototype.toFixed ( [ _options_ ] )</h1>
    <p>This method generates a String representation of the current Decimal128 object, in decimal format, with a specified number of digits after the decimal point.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Let _numDigits_ be *+0*<sub>𝔽</sub>.
      1. Let _roundingMode_ be *undefined*.
      1. If _options_ is not *undefined*, then
        1. If _options_ is not an Object, throw a *TypeError* exception.
        1. Set _numDigits_ to ? Get(_options_, *"digits"*).
        1. Set _roundingMode_ to ? Get(_options_, *"roundingMode"*).
      1. If _numDigits_ is not a Number, throw a *TypeError* exception.
      1. If _numDigits_ is *NaN*<sub>𝔽</sub>, *+∞*<sub>𝔽</sub>, or *-∞*<sub>𝔽</sub>, throw a *RangeError* exception.
      1. Set _numDigits_ to ℝ(_numDigits_).
      1. If _numDigits_ < 0, throw a *RangeError* exception.
      1. If _numDigits_ is not an integer, throw a *RangeError* exception.
      1. If _roundingMode_ is *undefined*, set _roundingMode_ to *"halfEven"*.
      1. Else if _roundingMode_ is not a String, throw a *TypeError* exception.
      1. Else if _roundingMode_ is not a <emu-xref href="#dfn-decimal128-rounding-mode">Decimal128 rounding mode</emu-xref>, throw a *RangeError* exception.
      1. Let _d_ be _O_.[[Decimal128Data]].
      1. If _d_ is *NaN*<sub>𝔻</sub>, return *"NaN"*.
      1. If _d_ is *+∞*<sub>𝔻</sub>, return *"Infintiy"*.
      1. If _d_ is *-∞*<sub>𝔻</sub>, return *"-Infintiy"*.
      1. If sign(_d_) = 1, let _signPrefix_ be *""*, else let _signPrefix_ be *"-"*.
      1. If _d_ is *+0*<sub>𝔻</sub> or *-0*<sub>𝔻</sub>, then
        1. If _numDigits_ = 0, then
          1. Return the concatenation of _signPrefix_ and *"0"*.
        1. Otherwise:
          1. Let _trailingZeroes_ be *"0"* repeated _numDigits_ times.
          1. Return the concatenation of _signPrefix, *"0"*, *"."*, and _trailingZeroes_.
      1. Set _d_ to abs(_d_).
      1. Let _scaledV_ be _d_ × 10<sup>_numDigits_</sup>.
      1. Let _roundedScaledV_ be ApplyRoundingModeToPositive(_scaledV_, _roundingMode_).
      1. Let _s_ be the unique decimal string representation of _roundedScaledV_ without leading zeroes.
      1. Let _integerDigits_ be _s_.
      1. Let _nonIntegerDigits_ be *""*.
      1. If _s_ contains an occurrence of *"."*, then
        1. Let _i_ be the index of the first occurrence of *"."* in _s_.
        1. Set _integerDigits_ to the substring of _s_ from 0 to _i_.
        1. Set _nonIntegerDigits_ to the substring of _s_ from _i_ + 1.
      1. If _numDigits_ = 0, return _integerDigits_.
      1. Let _numNonIntegerDigits_ be the length of _nonIntegerDigits_.
      1. If the _numNonIntegerDigits_ < _numDigits_, then
        1. Let _additionalZeroes_ be the string *"0"* repeated _numDigits_ - _numNonIntegerDigits_ times.
        1. Set _nonIntegerDigits_ to the concatenation of _nonIntegerDigits_ and _additionalZeroes_.
      1. Else if _numNonIntegerDigits_ > _numDigits_, then
        1. Set _nonIntegerDigits_ to the substring of _nonIntegerDigits_ from 0 to _numDigits_.
      1. Return the concatenation of _signPrefix_, _integerDigits_, *"."*, and _nonIntegerDigits_.
    </emu-alg>
    <emu-note>
      <p>This operation follows the specification of the conversion of IEEE 754-2019 Decimal128 values to strings (external character sequences) discussed in Section 5.12 of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal128.prototype.tojson">
    <h1>Decimal128.prototype.toJSON ( )</h1>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Throw a *TypeError* exception.
    </emu-alg>
    <emu-note>
      <p>The behaviour of this operation aligns with that of the conversion of BigInt values to JSON using <emu-xref href="#sec-json.stringify">`JSON.stringify`</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal128.prototype.toprecision">
    <h1>Decimal128.prototype.toPrecision ( [ _options_ ] )</h1>
    <p>This method generates a String representation of the current Decimal128 object, in decimal format, with a specified number of significant digits. If the _precision_ argument is omitted or is *undefined*, this method is equivalent to <emu-xref href="#sec-decimal128.prototype.tostring">toString</emu-xref>. This method may produce results in exponential notation or decimal notation.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Let _precision_ be 0.
      1. If _options_ is not *undefined*, then
        1. If _options_ is not an Object, throw a *TypeError* exception.
        1. Let _optPrecision_ be ? Get(_options_, *"precision"*).
        1. If _optPrecision_ is neither *undefined* nor a Number, throw a *TypeError* exception.
        1. If _optPrecision_ is *undefined*, return Decimal128ToDecimalString(_O_).
        1. If _precision_ is *NaN*<sub>𝔽</sub>, *+∞*<sub>𝔽</sub> or *+∞*<sub>𝔽</sub>, throw a *RangeError* exception.
        1. Set _precision_ to ℝ(_precision_).
      1. If _precision_ is not an integer, throw a *RangeError* exception.
      1. If _precision_ < 1, throw a *RangeError* exception.
      1. Let _d_ be _O_.[[Decimal128Data]].
      1. If _d_ is *NaN*<sub>𝔻</sub>, return *"NaN"*.
      1. If _d_ is *+∞*<sub>𝔻</sub>, return *"Infinity"*.
      1. If _d_ is *-∞*<sub>𝔻</sub>, return *"-Infinity"*.
      1. If sign(_d_) = 1, let _signPrefix_ be *""*, else let _signPrefix_ be *"-"*.
      1. If _d_ is *+0*<sub>𝔻</sub> or *-0*<sub>𝔻</sub>, then
        1. If _precision_ = 0, then
          1. Return *"0"*.
        1. Otherwise:
          1. Let _extraZeroes_ be the string *"0"* repeated _precision_ times.
          1. Return the string concatenation of *"0"*, *"."*, and _extraZeroes_.
      1. Set _d_ to abs(_d_).
      1. Let _coefficient_ be _d_ × 10<sup>-q</sup>.
      1. Assert: _coefficient_ is an integer.
      1. Let _coefficientStr_ be the unique decimal string representation of _coefficient_ without leading zeroes.
      1. Let _firstDigit_ be the substring of _coefficientStr_ from 0 to 1.
      1. Let _remainingDigits_ be the substring of _coefficientStr_ from 1.
      1. Let _numCoefficientDigits_ be the length of _coefficientStr_.
      1. Let _m_ be the mantissa of _d_.
      1. Let _scaledM_ be _m_ × 10<sup>_numCoefficientDigits_</sup>.
      1. Let _fractionalPart_ be _scaledM_ mod 1.
      1. Let _e_ be the exponent of _d_.
      1. Let _eStr_ be the unique decimal string representation of _e_ without leading zeroes.
      1. If _numCoefficientDigits_ ≤ _numCoefficientDigits_, then
        1. Let _adjustedMantissa_ be _m_ - (_fractionalPart_ × 10<sup>-_numDigits</sup>).
        1. Assert: _adjustedMantissa_ is an integer.
        1. Let _adjustedMantissaStr_ be the unique decimal string representation of _adjustedMantissa_ without leading zeroes and without trailing zeroes.
        1. If _e_ ≥ 0, set _eStr_ to the concation of *"+"* and _eStr_.
        1. Return the concation of _signPrefix_, _adjustedMantissaStr_, *"e"*, and _eStr_.
      1. Otherwise:
        1. Let _extraZeroes_ be the string *"0"* repeated _numCoefficientDigits_ - 1 - _numCoefficientDigits_ times.
        1. Let _s_ be the string concatenation of _firstDigit_, *"."*, _remainingDigits_, _extraZeroes_, *"e"*, and _eStr_.
        1. Return _s_.
    </emu-alg>
    <emu-note>
      <p>This operation follows the specification of the conversion of IEEE 754-2019 Decimal128 values to strings (external character sequences) discussed in Section 5.12 of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal128.prototype.valueof">
    <h1>Decimal128.prototype.valueOf ( _x_ )</h1>
    <p>This method performs the following steps when called:</p>
    <emu-alg>
      1. Throw a *TypeError* exception.
    </emu-alg>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-numbers-and-dates">
  <h1>Numbers and Dates</h1>
  <emu-clause id="sec-number-objects">
    <h1>Number Objects</h1>

    <emu-clause id="sec-number-constructor">
      <h1>The Number Constructor</h1>
      <emu-clause id="sec-number-constructor-number-value">
        <h1>Number ( _value_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If _value_ is present, then
            1. <ins>If _value_ is an object that has an [[Decimal128Data]] internal slot, then</ins>
              1. <ins>Let _d_ be _value_.[[Decimal128Data]].</ins>
              1. <ins>Let _serialized_ be Decimal128ToExponentialString(_d_).</ins>
              1. <ins>Let _n_ be ! ToNumber(_serialized_).</ins>
            1. Else,
              1. Let _prim_ be ? ToNumeric(_value_).
              1. If _prim_ is a BigInt, let _n_ be 𝔽(ℝ(_prim_)).
              1. Otherwise, let _n_ be _prim_.
          1. Else,
            1. Let _n_ be *+0*<sub>𝔽</sub>.
          1. If NewTarget is *undefined*, return _n_.
          1. Let _O_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%Number.prototype%"*, « [[NumberData]] »).
          1. Set _O_.[[NumberData]] to _n_.
          1. Return _O_.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-bigint-objects">
    <h1>BigInt Objects</h1>
    <emu-clause id="sec-bigint-constructor">
      <h1>The BigInt Constructor</h1>
      <emu-clause id="sec-bigint-constructor-number-value">
        <h1>BigInt ( _value_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If NewTarget is not *undefined*, throw a *TypeError* exception.
          1. <ins>If _value_ has a [[Decimal128Data]] internal slot, return ? Decimal128ToBigInt(_value_).</ins>
          1. Let _prim_ be ? ToPrimitive(_value_, ~number~).
          1. If _prim_ is a Number, return ? NumberToBigInt(_prim_).
          1. Otherwise, return ? <emu-meta suppress-effects="user-code">ToBigInt(_prim_)</emu-meta>.
        </emu-alg>

         <emu-clause id="sec-numbertobigint" type="abstract operation">
          <h1>
            <ins>Decimal128ToBigInt (
            _number_: an Object with a [[Decimal128Data]] internal slot,
            ): either a normal completion containing a BigInt or a throw completion</ins>
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Let _d_ be _number_.[[Decimal128Data]].
            1. If _d_ is *NaN*<sub>𝔻</sub>, *+∞*<sub>𝔻</sub> or *-∞*<sub>𝔻</sub>, throw a *RangeError* exception.
            1. If _d_ is *+0*<sub>𝔻</sub> or *−0*<sub>𝔻</sub>, return ℤ(0).
            1. If _d_ is an integer, return ℤ(ℝ(_d_)).
            1. Otherwise, throw a *RangeError* exception.
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-import href="./intl.emu"></emu-import>
