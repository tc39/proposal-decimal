<!DOCTYPE html>
<meta charset="utf-8">
<link rel="stylesheet" href="./spec.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">
<script src="./spec.js"></script>
<pre class="metadata">
title: Decimal
status: proposal
stage: 1
contributors: Jesse Alama, Waldemar Horwat
location: https://github.com/tc39/proposal-decimal/
</pre>

<emu-intro id="sec-decimal-intro-">
  <h1>Introduction</h1>
  <p>This specification consists of two parts:</p>
  <ul>
    <li>The specification of the <a href="https://github.com/tc39/proposal-decimal/" title="Decimal proposal (GitHub)">Decimal proposal</a> and everything related to it, proposed to be added to ECMA-262 in new sections;</li>
    <li>A list of amendments to be made to ECMA-402.</li>
  </ul>
</emu-intro>

<emu-clause id="sec-the-decimal-object">
  <h1>The Decimal128 Object</h1>

  <emu-intro id="sec-decimal-intro">
    <h1>Introduction</h1>
    <p>Decimal128 values, as specified here, are intended to represent base-10 (decimal) numbers as specified in <emu-xref href="#sec-bibliography">IEEE 754 Decimal128</emu-xref>. A Decimal128 value, as specified here, is one of the following four kinds of values:</p>

    <ul>
      <li>*NaN*<sub>𝔻</sub>, represending a decimal not-a-number</li>
      <li>*+∞*<sub>𝔻</sub>, representing positive infinity as a decimal,</li>
      <li>*-∞*<sub>𝔻</sub>, representing negative infinity as a decimal,</li>
      <li>« _v_, _q_ »<sub>𝔻</sub>, where _v_ and _q_ satisfy the following conditions:</li>
      <ul>
        <li>_v_ is either
        <ul>
          <li>*+0*<sub>𝔻</sub>, represending non-negative zero as a decimal value</li>
          <li>*−0*<sub>𝔻</sub>, representing negative zero as a decimal value, or</li>
          <li>a mathematical value</li>
        </ul></li>
        <li>_q_ is an integer satisfying -6176 ≤ _q_ ≤ 6111,</li>
        <li>If _v_ is a mathematical value, then v × 10<sup>−_q_</sup> is an integer _n_ such that 0 < abs(_n_) < 10<sup>34</sup></li>
      </ul>
    </ul>
    <emu-note>
      <p>A Decimal128 value is not an ECMAScript language value.</p>
    </emu-note>
    <p>A Decimal128 value is said to be <dfn id="dfn-decimal128-finite">finite</dfn> if it has the form « _v_, _q_ »<sub>𝔻</sub>. A <dfn id="dfn-decimal128-zero">zero</dfn> Decimal128 value is a finite Decimal128 value of the form « 0<sub>𝔻</sub>, _q_ »<sub>𝔻</sub> or « −0<sub>𝔻</sub>, _q_ »<sub>𝔻</sub>. A finite non-zero Decimal128 value is one of the form « _v_, _q_ »<sub>𝔻</sub> where _v_ is a mathematical value.</p>
    <p>The <dfn id="dfn-decimal128-mathematical-value">mathematical value</dfn> of a finite Decimal128 value _x_ = « _v_, _q_ »<sub>𝔻</sub> is defined as follows:</p>
    <ul>
      <li>If _x_ is zero, the mathematical value of _x_ is 0</li>
      <li>If _x_ is non-zero, the mathematical value of _x_ is v × 10<sup>_q_</sup></li>
    </ul>
    <p>Decimal128 values defined in this section are ECMAScript analogues of <emu-xref href="#sec-bibliography">IEEE 754 Decimal128 values</emu-xref>. The full spectrum of values defined by Decimal128 are available here, though there is only one Decimal128 value, NaN<sub>𝔻</sub>, representing all possible IEEE 754 Decimal128 NaN values.</p>
    <p>A <dfn id="dfn-decimal128-rounding-mode">Decimal128 rounding mode</dfn> is one of the String values *"ceil"*, *"floor"*, *"trunc"*, *"halfExpand"*, and *"halfEven"*. The <dfn id="dfn-decimal128-default-rounding-mode">default rounding mode</dfn> is the String value *"halfEven"*.</p>
    <emu-table id="table-decimal128-rounding-modes">
      <emu-caption>Rounding modes in Decimal128 compared to IEEE 754 rounding modes</emu-caption>
      <table class="real-table">
        <thead>
          <tr>
            <th>Decimal128 rounding mode</th>
            <th>Description</th>
            <th>IEEE 754 rounding mode</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>*"ceil"*</td>
            <td>Toward positive infinity</td>
            <td>*"roundTowardPositive"*</td>
          </tr>
          <tr>
            <td>*"floor"*</td>
            <td>Toward negative infinity</td>
            <td>*"roundTowardNegative"*</td>
          </tr>
          <tr>
            <td>*"trunc"*</td>
            <td>Toward zero</td>
            <td>*"roundTowardZero"*</td>
          </tr>
          <tr>
            <td>*"halfExpand"*</td>
            <td>Ties away from zero</td>
            <td>*"roundTiesToAway"*</td>
          </tr>
          <tr>
            <td>*"halfEven"*</td>
            <td>Ties toward an even rounding increment multiple</td>
            <td>*"roundTiesToEven"*</td>
          </tr>
        </tbody>
      </table>
      <emu-note>The above five rounding modes are defined in IEEE 754. This table is offered for implementors who may need to convert the Decimal128 rounding modes defined here into a library that may use the official IEEE 754 rounding mode names. Additional rounding modes are used elsewhere in this specification, such as in <emu-xref href="#table-intl-rounding-modes">Intl.NumberFormat</emu-xref>.</emu-note>
    </emu-table>
    <p>For every finite Decimal128 value _x_ = « _v_, _q_ »<sub>𝔻</sub>, we define:</p>
    <ul>
      <li><emu-eqn id="eqn-decimal128-cohort" aoid="cohort">cohort</emu-eqn>(_x_) is _v_;</li>
      <li><emu-eqn id="eqn-decimal128-quantum" aoid="quantum">quantum</emu-eqn>(_x_) is _q_.</li>
    </ul>
    <p>For every non-NaN Decimal128 value, we define its sign as follows:</p>
    <ul>
      <li><emu-eqn id="eqn-decimal128-sign-positive-infinity" aoid="sign">sign</emu-eqn>(*∞<sub>𝔻</sub>*) = 1</li>
      <li><emu-eqn id="eqn-decimal128-sign-negative-infinity">sign</emu-eqn>(*-∞*<sub>𝔻</sub>) = -1</li>
      <li><emu-eqn id="eqn-decimal128-sign-positive-zero">sign</emu-eqn>(« *+0*<sub>𝔻</sub>, _q_ ») = 1</li>
      <li><emu-eqn id="eqn-decimal128-sign-negative-zero">sign</emu-eqn>(« *−0*<sub>𝔻</sub>, _q_ ») = -1</li>
      <li><emu-eqn id="eqn-decimal128-sign-finite-non-zero">sign</emu-eqn>(« _v_, _q_ ») = _v_ / abs(_v_)</li>
    </ul>
    <p>For every finite non-zero Decimal128 value « _v_, _q_ »<sub>𝔻</sub> there exists a unique integer _e_ and mathematical value _s_ such that</p>
    <ol>
      <li>_v_ = _s_ × 10<sup>_e_</sup></li>
      <li>1 ≤ abs(_s_) < 10</li>
    </ol>
    <p>We call _e_ the <dfn id="dfn-decimal128-exponent">exponent</dfn> and _s_ the <dfn id="dfn-decimal128-significand">significand</dfn> of « _v_, _q_ »<sub>𝔻</sub>. The exponent and significand are undefined for NaN, non-finite, and zero Decimal128 values.</p>
    <emu-note>
      <p>The significand of a finite non-zero Decimal128 value is a rational number.</p>
    </emu-note>
    <emu-note>
      <p>The exponent _e_ of finite non-zero Decimal128 values is an integer satisfying 6144 ≥ _e_ ≥ -6176.</p>
    </emu-note>
    <p>A finite non-zero Decimal128 value is <dfn id="dfn-decimal128-normalized">normalized</dfn> if its exponent _e_ satisfies 6144 ≥ _e_ ≥ -6143. A finite non-zero Decimal128 value is <dfn id="dfn-decimal128-denormalized-">denormalized</dfn> if its exponent _e_ satisfies -6144 ≥ _e_ ≥ -6176.</p>
    <p>A <dfn id="dfn-decimal-cohort">decimal cohort</dfn> is one of the values *NaN*<sub>𝔻</sub>, *+∞*<sub>𝔻</sub>, *-∞*<sub>𝔻</sub>, *+0*<sub>𝔻</sub>, *−0*<sub>𝔻</sub>, or a mathematical value.</p>
    <p>For a proper discussion of rounding, we need to separate how rounding occurs with normalized compared with denormlized values. For a normalized Decimal128 value we define its <dfn>truncated exponent</dfn> as equal to its exponent. For zero or denormalized Decimal128 values we define the truncated exponent as the constant -6143. Given this, we define the <dfn>scaled significand</dfn> of a finite Decimal128 value as follows:</p>
    <ul>
      <li>The scaled significand of a zero Decimal128 value is 0</li>
      <li>The scaled significand of a non-zero Decimal128 value _x = « _v_, _q_ »<sub>𝔻</sub> is v × 10<sup>33 − _te_</sup>, where _te_ is the truncated exponent of _x_.</li>
    </ul>
    <emu-note>
      <p>The scaled significand of a finite Decimal128 value is always an integer whose absolute value is less than 10<sup>34</sup>.</p>
    </emu-note>
  </emu-intro>
  <emu-clause id="sec-decimal-abstract-ops">
    <h1>Abstract Operations</h1>

    <emu-clause id="sec-decimal128-roundtodecimal128domain" type="abstract operation">
      <h1>RoundToDecimal128Domain(
        _v_: a mathematical value,
        optional _roundingMode_: a Decimal128 rounding mode
      ): *+∞*<sub>𝔻</sub>, *-∞*<sub>𝔻</sub>, *+0*<sub>𝔻</sub>, *−0*<sub>𝔻</sub>, or a mathematical value
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It computes the closest approximation to a given mathematical value, rounded according to the given rounding mode, that is available within the limits of Decimal128.</dd>
      </dl>
      <emu-alg>
        1. If _v_ = 0, return *+0*<sub>𝔻</sub>.
        1. If v < 0, then
          1. Let _reverseRoundingMode_ be _roundingMode_.
          1. If _roundingMode_ is *"floor"*, set _reverseRoundingMode_ to *"ceil"*.
          1. If _roundingMode_ is *"ceil"*, set _reverseRoundingMode_ to *"floor"*.
          1. Let _d_ be RoundToDecimal128Domain(–_v_, _reverseRoundingMode_).
          1. If _d_ is *+∞*<sub>𝔻</sub>, return *–∞*<sub>𝔻</sub>.
          1. If _d_ is *+0*<sub>𝔻</sub>, return *−0*<sub>𝔻</sub>.
          1. Assert: _d_ is a mathematical value.
          1. Return –_d_.
        1. Let _e_ be the unique integer such that 10<sup>_e_</sup> ≤ _v_ < 10<sup>_e_+1</sup>.
        1. Let _te_ be _e_ − 33.
        1. If _te_ < –6176, set _te_ to –6176.
        1. Let _m_ be _v_ × 10<sup>–_te_</sup>.
        1. Let _rounded_ be ApplyRoundingModeToPositive(_m_, _roundingMode_).
        1. If _rounded_ = 10<sup>34</sup>, then
          1. Set _te_ to _te_ + 1.
          1. Set _rounded_ = to 10<sup>33</sup>.
        1. If _te_ > 6111, return *+∞*<sub>𝔻</sub>.
        1. If _rounded_ = 0, return *+0*<sub>𝔻</sub>.
        1. Return _rounded_ × 10<sup>_te_</sup>.
      </emu-alg>

      <emu-clause id="sec-decimal128-applyroundingmodetopositive" type="abstract operation">
        <h1>ApplyRoundingModeToPositive(
          _m_: a positive mathematical value,
          _roundingMode_: a Decimal128 rounding mode
        ): *+∞*<sub>𝔻</sub>, *+0*<sub>𝔻</sub>, or a mathematical value
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It computes the closest approximation to a given mathematical value,which must be positive, rounded according to the given rounding mode, that is available within the limits of Decimal128.</dd>
        </dl>
        <emu-alg>
          1. Let _mLow_ be floor(_m_).
          1. Let _fraction_ be _m_ – _mLow_.
          1. If _fraction_ = 0, return _mLow_.
          1. Let _mHigh_ be _mLow_ + 1.
          1. If _roundingMode_ is *"floor"* or *"trunc"*, return _mLow_.
          1. If _roundingMode_ is *"ceil"*, return _mHigh_.
          1. If _fraction_ < 0.5, return _mLow_.
          1. If _fraction_ > 0.5, return _mHigh_.
          1. If _roundingMode_ is *"halfExpand"*, return _mHigh_.
          1. If _mLow_ is an even integer, return _mLow_.
          1. Return _mHigh_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-decimal128-pickquantum" type="abstract operation">
      <h1>PickQuantum(
        _d_: a decimal cohort,
        _v_: a mathematical value,
        _preferredQuantum_: an integer
      ): a Decimal128 value
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It takes a decimal cohort, a mathematical value, and an integer and produces a Decimal128 value in the cohort of _d_. If _d_ is an exact Decimal128 cohort representation of _v_, PickQuantum picks the quantum as close as possible to _qPreferred_; if _d_ is not an exact Decimal128 cohort representation of _v_, PickQuantum picks the lowest possible quantum.</dd>
      </dl>
      <emu-alg>
        1. If _d_ is one of « *NaN*<sub>𝔻</sub>, *+∞*<sub>𝔻</sub>, *–∞*<sub>𝔻</sub> », return _d_.
        1. Let _inexact_ be *false*.
        1. If _d_ is *+0*<sub>𝔻</sub> or *–0*<sub>𝔻</sub>, then
          1. Let _qMax_ be 6111.
          1. Let _qMin_ be –6176.
          1. If _v_ ≠ 0, set _inexact_ to *true*.
        1. Otherwise:
          1. Let _e_ be the unique integer such that 10<sup>_e_</sup> ≤ abs(v) < 10<sup>_e_ + 1</sup>.
          1. Let _qMin_ be _e_ – 33.
          1. If _qMin_ < –6176, set _qMin_ to –6176.
          1. Let _m_ be _v_ × 10<sup>–_qMin_</sup>.
          1. Assert: _m_ is an integer.
          1. Assert: 0 < abs(_m_) < 1034.
          1. Assert: _qMin_ ≤ 6111.
          1. Let _n_ be the largest integer for which _m_ × 10<sup>–n</sup> is an integer.
          1. Let _qMax_ be _qMin_ + _n_.
          1. If _qMax_ > 6111, set _qMax_ to 6111.
          1. If _v_ ≠ d, set _inexact_ to *true*.
        1. If _inexact_ is *true*, then
          1. Let _q_ be _qMin_.
        1. Otherwise:
          1. Let _q_ be _qPreferred_.
          1. If _q_ < _qMin_, set _q_ to _qMin_.
          1. If _q_ > _qMax_, set _q_ to _qMax_.
        1. Return « _d_, _q_ »<sub>𝔻</sub>.
      </emu-alg>
      <emu-alg>
        1. If _d_ is *NaN*<sub>𝔻</sub>, *+∞*<sub>𝔻</sub>, or *-∞*<sub>𝔻</sub>, return _d_.
        1. Let _actualQuantum_ be _preferredQuantum_.
        1. If _preferredQuantum_ < -6176, set _actualQuantum_ to -6176.
        1. If _preferredQuantum_ > 6111, set _actualQuantum_ to 6111.
        1. Otherwise, return « _d_, _actualQuantum_ »<sub>𝔻</sub>.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-decimal128-roundandpickquantum" type="abstract operation">
      <h1>RoundAndPickQuantum(
        _d_: a mathematical value,
        _preferredQuantum_: an integer,
        optional _roundingMode_: a Decimal128 rounding mode
      ): a Decimal128 value
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It rounds the given mathematical value according to the given rounding mode and picks a suitable quantum for the rounded result.</dd>
      </dl>
      <emu-alg>
        1. Return PickQuantum(RoundToDecimal128Domain(_d_, _roundingMode_), _d_, _preferredQuantum_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-decimal128-abs" type="abstract operation">
      <h1>
        Decimal128Abs (
          _argument_ : a Decimal128 value
        ): a Decimal128 value
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It computes the absolute value of a Decimal128 value</dd>
      </dl>
      <emu-alg>
        1. If _argument_ is *NaN*<sub>𝔻</sub>, return *NaN*<sub>𝔻</sub>.
        1. If _argument_ is *+∞*<sub>𝔻</sub> or *-∞*<sub>𝔻</sub>, return *+∞*<sub>𝔻</sub>.
        1. Let _v_ be cohort(_argument_).
        1. Let _q_ be quantum(_argument_).
        1. If _v_ is *+0*<sub>𝔻</sub> or *−0*<sub>𝔻</sub>, return « *+0*<sub>𝔻</sub>, _q_ »<sub>𝔻</sub>.
        1. Otherwise, return « abs(_v_), _q_ »<sub>𝔻</sub>.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-decimal128-negate" type="abstract operation">
      <h1>
        Decimal128Negate (
          _argument_ : a Decimal128 value
        ): a Decimal128 value
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It computes the negation of a Decimal128 value</dd>
      </dl>
      <emu-alg>
        1. If _argument_ is *NaN*<sub>𝔻</sub>, return *NaN*<sub>𝔻</sub>.
        1. If _argument_ is *+∞*<sub>𝔻</sub>, return *-∞*<sub>𝔻</sub>.
        1. If _argument_ is *-∞*<sub>𝔻</sub>, return *+∞*<sub>𝔻</sub>.
        1. Let _v_ be cohort(_argument_).
        1. Let _q_ be quantum(_argument_).
        1. If _v_ is *+0*<sub>𝔻</sub>, return « *−0*<sub>𝔻</sub>, _q_ »<sub>𝔻</sub>.
        1. If _v_ is *−0*<sub>𝔻</sub>, return « *+0*<sub>𝔻</sub>, _q_ »<sub>𝔻</sub>.
        1. Otherwise, return « −_v_, _q_ »<sub>𝔻</sub>.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-decimal128-decimal128todecimalstring" type="abstract operation">
      <h1>
        Decimal128ToDecimalString (
          _argument_ : a Decimal128 value,
          _preserveTrailingZeroes_ : a Boolean
        ): a String
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It renders _argument_ as a string in decimal notation, regardless of how many decimal digits would be required.</dd>
      </dl>
      <emu-alg>
        1. If _argument_ is *NaN*<sub>𝔻</sub>, return *"NaN"*.
        1. Let _abs_ be Decimal128Abs(_argument_).
        1. Let _renderedAbsoluateValue_ be NonNegativeDecimal128ToDecimalString(_abs_, _preserveTrailingZeroes_).
        1. If sign(_argument_) = -1, return the concatenation of *"-"* and _renderedAbsoluateValue_.
        1. Otherwise, return _renderedAbsoluateValue_.
      </emu-alg>

      <emu-clause id="sec-decimal128-nonnegativedecimal128todecimalstring" type="abstract operation">
        <h1>
          NonNegativeDecimal128ToDecimalString (
            _argument_ : a non-*NaN*<sub>𝔻</sub> Decimal128 value for which sign(_argument) = 1,
            _preserveTrailingZeroes_ : a Boolean
          ): a String
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It renders _argument_ as a string in decimal representation, regardless of how many decimal digits are required. It is assumed that sign(_argument_) = 1.</dd>
        </dl>
        <emu-alg>
          1. If _argument_ is *+∞*<sub>𝔻</sub>, return *"Infinity"*.
          1. Let _v_ be cohort(_argument_).
          1. Let _q_ be quantum(_argument_).
          1. If _v_ is *+0*<sub>𝔻</sub>, then
            1. Let _integerPart_ be *"0"*.
          1. Otherwise:
            1. Let _n_ be the integer for which _v_ × 10<sup>−_q_</sup> = _n_.
            1. Assert: 0 < abs(_n_) < 10<sup>34</sup>.
            1. Let _digits_ be the unique decimal string representation of _n_ without leading zeroes.
            1. If _q_ ≥ 0, then
              1. Let _trailingZeroes_ be the String *"0"* repeated abs(_n_) − _q_ times.
              1. Return the concatenation of _digits_ and _trailingZeroes_.
            1. Let _integerPart_ be the substring of _digits_ from 0 to abs(_n_) − _q_.
          1. If _preserveTrailingZeroes_ is *false* and _v_ is an integer, then
            1. Assert: _integerPart_ is not *""*.
            1. Return _integerPart_.
          1. If _integerPart_ is *""*, set _integerPart_ to *"0"*.
          1. Let _nonIntegerPart_ be the substring of _digits_ from abs(_n_) − _q_ to the length of _digits_.
          1. If _preserveTrailingZeroes_ is *false*, set _nonIntegerPart_ to a copy of _nonIntegerPart_ with trailing *"0"*s removed.
          1. Assert: _nonIntegerPart_ is not *""*.
          1. Return the concatenation of _integerPart_, *"."*, and _nonIntegerPart_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-decimal128toexponentialstring" type="abstract operation">
      <h1>
        Decimal128ToExponentialString (
          _argument_ : a Decimal128 value,
          _preserveTrailingZeroes_ : a Boolean
        ): a String
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It renders _argument_ in exponential notation.</dd>
      </dl>
      <emu-alg>
        1. If _argument_ is *NaN*<sub>𝔻</sub>, return *"NaN"*.
        1. If _argument_ is *+∞*<sub>𝔻</sub>, return *"Infinity"*.
        1. If _argument_ is *-∞*<sub>𝔻</sub>, return *"-Infinity"*.
        1. Let _v_ be cohort(_argument_).
        1. Let _q_ be quantum(_argument_).
        1. If _v_ is *+0*<sub>𝔻</sub>, return *"0"*.
        1. If _v_ is *−0*<sub>𝔻</sub>, return *"-0"*.
        1. Let _coefficientStr_ be the unique decimal string representation of _v_ without leading zeroes.
        1. Let _exponentStr_ be the unique decimal string representation of _q_ without leading zeroes.
        1. Return the concatenation of _coefficientStr_, *"e"*, and _exponentStr_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-decimal128-isintegraldecimal128value" type="abstract operation">
      <h1>
        IsIntegralDecimal128 (
          _argument_: A Decimal128 object
        ): a Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It determines if _argument_ is a finite integral Decimal128 value.</dd>
      </dl>
      <emu-alg>
        1. Let _d_ be _argument_.[[Decimal128Data]].
        1. If _d_ is *NaN*<sub>𝔻</sub>, *+∞*<sub>𝔻</sub> or *-∞*<sub>𝔻</sub>, return *false*.
        1. Let _v_ be cohort(_d_).
        1. If _v_ is *+0*<sub>𝔻</sub> or *−0*<sub>𝔻</sub>, return *true*.
        1. If _v_ is an integer, return *true*.
        1. Otherwise, return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-decimal128-value-to-object" type="abstract operation">
      <h1>
        Decimal128ValueToObject (
          _argument_ : a Decimal128 value
        ): a Decimal128 object
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It converts a Decimal128 value to a Decimal128 object.</dd>
      </dl>
      <emu-alg>
        1. Let _O_ be ! OrdinaryCreateFromConstructor(%Decimal128%, *"%Decimal128.prototype%"*, « [[Decimal128Data]] »).
        1. Set _O_.[[Decimal128Data]] to _argument_.
        1. Return _O_.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-the-decimal-constructor">
    <h1>The Decimal128 Constructor</h1>
    <p>The Decimal128 constructor:</p>
    <ul>
      <li>is <dfn>%Decimal128%</dfn>.</li>
      <li>is the initial value of the the *"Decimal128"* property of the global object.</li>
      <li>creates and initializes a new Decimal128 object when called as a constructor</li>
      <li>may be used as the value of an *extends* clause of a class definition. Subclass constructors that intend to inherit the specified Decimal128 behaviour must include a *super* call to the Decimal128 constructor to create and initialize the subclass instance with a [[Decimal128Data]] internal slot.</li>
    </ul>
    <emu-clause id="sec-the-decimal128-constructor-value">
      <h1>Decimal128 ( _x_ )</h1>
      <emu-alg>
        1. If NewTarget is *undefined*, throw a *TypeError* exception.
        1. Let _toParse_ be *undefined*.
        1. If _x_ is a BigInt, set _toParse_ to BigInt::toString(_x_, 10).
        1. Otherwise, if _x_ is a Number, set _toParse_ to ! Call(%Number.prototype.toExponential%, _x_, « »).
        1. Otherwise, if _x_ is a String, set _toParse_ to _x_.
        1. If _toParse_ is not a String, throw a *TypeError* exception.
        1. Let _O_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%Decimal128.prototype%"*, « [[Decimal128Data]] »).
        1. If _toParse_ is *"NaN"*, then
          1. Set _O_.[[Decimal128Data]] to *NaN*<sub>𝔻</sub>.
        1. Else,
          1. Let _parseResult_ be ParseText(_toParse_, |StrDecimalLiteral|).
          1. If _parseResult_ is a List of errors, throw a *SyntaxError* exception.
          1. Let _decimalValue_ be ? StringDecimalValue of _parseResult_.
          1. Set _O_.[[Decimal128Data]] to _decimalValue_.
        1. Return _O_.
      </emu-alg>
      <emu-note>
        <p>Given a Number argument, the constructor converts it to a String using the <emu-xref href="#sec-number.prototype.tostring">toString</emu-xref> method (with no arguments). In some cases, this may not be desited. In some use cases, given a Number, one may wish to call the Decimal128 constructor not with the number but rather with, for instance, the result of calling <emu-xref href="#sec-number.prototype.tofixed">toFixed</emu-xref> or <emu-xref href="#sec-number.prototype.toprecision">toPrecision</emu-xref> on the Number, thereby ensuring a certain level of precision that may get lost when using Number’s toString.</p>
      </emu-note>
      <emu-clause id="sec-runtime-semantics-stringdecimalvalue" type="sdo">
        <h1>Runtime Semantics: StringDecimalValue ( ): either a normal completion containing a Decimal128 value or a throw completion</h1>
        <dl class="header">
        </dl>
        <emu-grammar>StrDecimalLiteral ::: `-` StrUnsignedDecimalLiteral</emu-grammar>
        <emu-alg>
          1. Let _a_ be ? StringDecimalValue of |StrUnsignedDecimalLiteral|.
          1. If _a_ is *+∞*<sub>𝔻</sub>, return *-∞*<sub>𝔻</sub>.
          1. Assert: _a_ is finite.
          1. Let _v_ be cohort(_a_).
          1. Let _q_ be quantum(_a_).
          1. If _v_ is *+0*<sub>𝔻</sub>, return « *−0*<sub>𝔻</sub>, _q_ »<sub>𝔻</sub>.
          1. Return « −_v_, _q_ »<sub>𝔻</sub>.
        </emu-alg>
        <emu-grammar>StrUnsignedDecimalLiteral ::: `Infinity`</emu-grammar>
        <emu-alg>
          1. Return *+∞*<sub>𝔻</sub>.
        </emu-alg>
        <emu-grammar>StrUnsignedDecimalLiteral ::: DecimalDigits `.` DecimalDigits? ExponentPart?</emu-grammar>
        <emu-alg>
          1. Let _a_ be MV of the first |DecimalDigits|.
          1. If the second |DecimalDigits| is present, then
            1. Let _b_ be MV of the second |DecimalDigits|.
            1. Let _n_ be the number of code points in the second |DecimalDigits|.
          1. Else,
            1. Let _b_ be 0.
            1. Let _n_ be 0.
          1. If |ExponentPart| is present, let _e_ be MV of |ExponentPart|. Otherwise, let _e_ be 0.
          1. Return RoundAndPickQuantum((_a_ + (_b_ × 10<sup>−_n_</sup>)) × 10<sup>_e_</sup>, _e_ − _n_).
        </emu-alg>
        <emu-grammar>StrUnsignedDecimalLiteral ::: `.` DecimalDigits ExponentPart?</emu-grammar>
        <emu-alg>
          1. Let _b_ be MV of |DecimalDigits|.
          1. If |ExponentPart| is present, let _e_ be MV of |ExponentPart|. Otherwise, let _e_ be 0.
          1. Let _n_ be the number of code points in |DecimalDigits|.
          1. Let _newValue_ be _b_ × 10<sup>_e_ − _n_</sup>.
          1. Return RoundAndPickQuantum(_newValue_, _e_ − _n_).
        </emu-alg>
        <emu-grammar>StrUnsignedDecimalLiteral ::: DecimalDigits ExponentPart?</emu-grammar>
        <emu-alg>
          1. Let _a_ be MV of |DecimalDigits|.
          1. If |ExponentPart| is present, let _e_ be MV of |ExponentPart|. Otherwise, let _e_ be 0.
          1. Return RoundAndPickQuantum(_a_ × 10<sup>_e_</sup>, _e_).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-decimal-prototype-properties">
  <h1>Properties of the Decimal128 Prototype</h1>

  <emu-clause id="sec-decimal128.prototype.isnan">
    <h1>Decimal128.prototype.isNaN ( )</h1>
    <p>This method returns a Boolean value indicating whether a Decimal128 object represents *NaN*<sub>𝔻</sub>.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Let _d_ be _O_.[[Decimal128Data]].
      1. If _d_ is *NaN*<sub>𝔻</sub>, return *true*.
      1. Otherwise, return *false*.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-decimal128.prototype.isfinite">
    <h1>Decimal128.prototype.isFinite ( )</h1>
    <p>This method returns a Boolean value indicating whether a Decimal128 object represents *+∞*<sub>𝔻</sub> or *-∞*<sub>𝔻</sub>.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Let _d_ be _O_.[[Decimal128Data]].
      1. If _d_ is *NaN*<sub>𝔻</sub>, *+∞*<sub>𝔻</sub> or *-∞*<sub>𝔻</sub>, return *false*.
      1. Otherwise, return *true*.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-decimal128.prototype.exponent">
    <h1>Decimal128.prototype.exponent ( )</h1>
    <p>This method returns a Number value represents the <emu-xref href="#dfn-decimal128-exponent">exponent</emu-xref>, which is the integer _n_ for which the current Decimal128 object, _x_ = « _v_, _q_ »<sub>𝔻</sub>, there exists a mathematical value _s_ such that _v_ = _s_ × 10<sup>_e_</sup> and 1 ≤ abs(_s_) < 10. This method requires that the Decimal128 value held by the current Decimal128 object is finite and non-zero.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Let _d_ be _O_.[[Decimal128Data]].
      1. If _d_ is *NaN*<sub>𝔻</sub>, return *NaN*<sub>𝔽</sub>.
      1. If _d_ is *+∞*<sub>𝔻</sub> or *-∞*<sub>𝔻</sub>, return *+∞*<sub>𝔽</sub>.
      1. Let _v_ be cohort(_d_).
      1. If _v_ is *+0*<sub>𝔻</sub> or *−0*<sub>𝔻</sub>, return *-∞*<sub>𝔽</sub>.
      1. Let _e_ be the unique integer for which there exists a mathematical value _s_ such that _v_ = _s_ × 10<sup>_e_</sup> and 1 ≤ abs(_s_) < 10.
      1. Return 𝔽(_e_).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-decimal128.prototype.mantissa">
    <h1>Decimal128.prototype.mantissa ( )</h1>
    <p>This method returns a Decimal128 value representing the <emu-xref href="#dfn-decimal128-significand">significand</emu-xref> of the current Decimal128 object, which is the mathematical value _n_ for which the current Decimal128 object, _x_ = « _v_, _q_ »<sub>𝔻</sub>, there exists an integer _e_ such such that _v_ = _s_ × 10<sup>_e_</sup> and 1 ≤ abs(_s_) < 10. This method requires that the Decimal128 value held by the curernt Decimal128 object is finite and non-zero.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Let _d_ be _O_.[[Decimal128Data]].
      1. If _d_ is *NaN*<sub>𝔻</sub>, return *NaN*<sub>𝔽</sub>.
      1. If _d_ is *+∞*<sub>𝔻</sub> or *-∞*<sub>𝔻</sub>, return *+∞*<sub>𝔽</sub>.
      1. Let _v_ be cohort(_d_).
      1. If _v_ is *+0*<sub>𝔻</sub> or *−0*<sub>𝔻</sub>, return *-∞*<sub>𝔽</sub>.
      1. Let _s_ be the unique mathematical value such that _v_ = _s_ × 10<sup>_e_</sup> and 1 ≤ abs(_s_) < 10.
      1. Return Decimal128ValueToObject(« _s_, −_e_ »<sub>𝔻</sub>).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-decimal128.prototype.precision">
    <h1>Decimal128.prototype.precision</h1>
    <p>This method returns a Number value representing the quantum of the underlying Decimal128 value.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Let _d_ be _O_.[[Decimal128Data]].
      1. If _d_ is *NaN*<sub>𝔻</sub>, return *NaN*<sub>𝔽</sub>.
      1. If _d_ is *+∞*<sub>𝔻</sub> or *-∞*<sub>𝔻</sub>, return *+∞*<sub>𝔽</sub>.
      1. Let _q_ be quantum(_d_).
      1. Return 𝔽(_q_).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-decimal128.prototype.abs">
    <h1>Decimal128.prototype.abs ( )</h1>
    <p>This method computes the absolute value of a Decimal128 object.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Let _d_ be _O_.[[Decimal128Data]].
      1. Return Decimal128ValueToObject(Decimal128Abs(_d_)).
    </emu-alg>
    <emu-note>
      <p>This operation follows the specification in Section 5.5.1 of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal128.prototype.negate">
    <h1>Decimal128.prototype.negate ( )</h1>
    <p>This method inverts the sign of a Decimal128 object.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Let _d_ be _O_.[[Decimal128Data]].
      1. Return Decimal128ValueToObject(Decimal128Negate(_d_)).
    </emu-alg>
    <emu-note>
      <p>This operation follows the specification in Section 5.5.1 of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal128.prototype.add">
    <h1>Decimal128.prototype.add ( _x_ )</h1>
    <p>This method computes the addition of a Decimal128 object with another one. The computation proceeds as though infinite precision and unbounded range were available, rounding, if necessary.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Perform ? RequireInternalSlot(_x_, [[Decimal128Data]]).
      1. Let _d1_ be _O_.[[Decimal128Data]].
      1. Let _d2_ be _x_.[[Decimal128Data]].
      1. If _d1_ or _d2_ is *NaN*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
      1. If _d1_ is *+∞*<sub>𝔻</sub> or _d2_ is *+∞*<sub>𝔻</sub>, then
        1. If _d1_ is *-∞*<sub>𝔻</sub> or _d2_ is *-∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
        1. Return Decimal128ValueToObject(*+∞*<sub>𝔻</sub>).
      1. If _d1_ is *-∞*<sub>𝔻</sub> or _d2_ is *-∞*<sub>𝔻</sub>, then
        1. Assert: _d1_ is not *+∞*<sub>𝔻</sub> and _d2_ is not *+∞*<sub>𝔻</sub>.
        1. Return Decimal128ValueToObject(*-∞*<sub>𝔻</sub>).
      1. Let _v1_ be cohort(_d1_).
      1. Let _v2_ be cohort(_d2_).
      1. Let _q1_ be quantum(_d1_).
      1. Let _q2_ be quantum(_d2_).
      1. Let _newQ_ be min(_q1_, _q2_).
      1. If _v1_ is *−0*<sub>𝔻</sub>, return Decimal128ValueToObject(PickQuantum(_v2_, _v2_, _newQ_))..
      1. If _v2_ is *−0*<sub>𝔻</sub>, return Decimal128ValueToObject(PickQuantum(_v1_, _v1_, _newQ_)).
      1. If _v1_ is *+0*<sub>𝔻</sub>, set _v1_ to 0.
      1. If _v2_ is *+0*<sub>𝔻</sub>, set _v2_ to 0.
      1. Let _sum_ be _v1_ + _v2_.
      1. If _sum_ = 0, return Decimal128ValueToObject(PickQuantum(*+0*<sub>𝔻</sub>, 0, _newQ_)).
      1. Return Decimal128ValueToObject(RoundAndPickQuantum(_sum_, _newQ_)).
    </emu-alg>
    <emu-note>
      <p>This operation follows the specification in Section 5.4.1 of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal128.prototype.subtract">
    <h1>Decimal128.prototype.subtract ( _x_ )</h1>
    <p>This method computes subtracts the given Decimal128 object from the current one. The computation proceeds as though infinite precision and unbounded range were available, rounding, if necessary.</p>
    <p>It performs the following steps when called:</p>
      <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Perform ? RequireInternalSlot(_x_, [[Decimal128Data]]).
      1. Let _d1_ be _O_.[[Decimal128Data]].
      1. Let _d2_ be _x_.[[Decimal128Data]].
      1. If _d1_ or _d2_ is *NaN*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
      1. If _d1_ is *+∞*<sub>𝔻</sub> or *-∞*<sub>𝔻</sub>, then
        1. If _d2_ is _d1_, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
        1. Return Decimal128ValueToObject(_d1_).
      1. If _d2_ is *+∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*-∞*<sub>𝔻</sub>).
      1. If _d2_ is *-∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*+∞*<sub>𝔻</sub>).
      1. Let _v1_ be cohort(_d1_).
      1. Let _v2_ be cohort(_d2_).
      1. Let _q1_ be quantum(_d1_).
      1. Let _q2_ be quantum(_d2_).
      1. Let _newQ_ be min(_q1_, _q2_).
      1. If _v1_ is *−0*<sub>𝔻</sub> and _v2_ is *+0*<sub>𝔻</sub>, return Decimal128ValueToObject(PickQuantum(*−0*<sub>𝔻</sub>, 0, _newQ_)).
      1. If _v1_ is *+0*<sub>𝔻</sub> or *−0*<sub>𝔻</sub>, set _v1_ to 0.
      1. If _v2_ is *+0*<sub>𝔻</sub> or *−0*<sub>𝔻</sub>, set _v2_ to 0.
      1. Let _difference_ be _v1_ − _v2_.
      1. Return Decimal128ValueToObject(RoundAndPickQuantum(_difference_, _newQ_)).
    </emu-alg>
    <emu-note>
      <p>This operation follows the specification in Section 5.4.1 of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal128.prototype.multiply">
    <h1>Decimal128.prototype.multiply ( _x_ )</h1>
    <p>This method computes multiplies the current Decimal128 object by another one. The computation proceeds as though infinite precision and unbounded range were available, rounding, if necessary.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Perform ? RequireInternalSlot(_x_, [[Decimal128Data]]).
      1. Let _d1_ be _O_.[[Decimal128Data]].
      1. Let _d2_ be _x_.[[Decimal128Data]].
      1. If _d1_ or _d2_ is *NaN*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
      1. If _d1_ or _d2_ is *+∞*<sub>𝔻</sub>, then
        1. If _d1_ or _d2_ is a zero Decimal128 value, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
        1. If sign(_d1_) = -1 or sign(_d2_) = -1, return Decimal128ValueToObject(*-∞*<sub>𝔻</sub>).
        1. Return Decimal128ValueToObject(*+∞*<sub>𝔻</sub>).
      1. If _d1_ or _d2_ is *-∞*<sub>𝔻</sub>, then
        1. If _d1_ or _d2_ is a zero Decimal128 value, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
        1. If sign(_d1_) = -1 and sign(_d2_) = -1, return Decimal128ValueToObject(*+∞*<sub>𝔻</sub>).
        1. Return Decimal128ValueToObject(*-∞*<sub>𝔻</sub>).
      1. Let _v1_ be cohort(_d1_).
      1. Let _v2_ be cohort(_d1_).
      1. Let _q1_ be quantum(_d1_).
      1. Let _q2_ be quantum(_d2_).
      1. Let _newQ_ be _q1_ + _q2_.
      1. If _v1_ or _v2_ is *+0*<sub>𝔻</sub>, then
        1. If sign(_d1_) = -1 or sign(_d2_) = -1, return Decimal128ValueToObject(PickQuantum(*−0*<sub>𝔻</sub>, 0, _newQ_)).
        1. Return Decimal128ValueToObject(PickQuantum(*+0*<sub>𝔻</sub>, 0, _newQ_)).
      1. If _v1_ or _v2_ is *−0*<sub>𝔻</sub>, then
        1. If sign(_d1_) = -1 and sign(_d2_) = -1, return Decimal128ValueToObject(PickQuantum(*+0*<sub>𝔻</sub>, 0, _newQ_)).
        1. Return Decimal128ValueToObject(PickQuantum(*−0*<sub>𝔻</sub>, 0, _newQ_)).
      1. Let _product_ be _v1_ × _v2_.
      1. Assert: _product_ ≠ 0.
      1. Return Decimal128ValueToObject(RoundAndPickQuantum(_product_, _newQ_)).
    </emu-alg>
    <emu-note>
      <p>This operation follows the specification in Section 5.4.1 of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal128.prototype.divide">
    <h1>Decimal128.prototype.divide ( _x_ )</h1>
    <p>This method computes divides the current Decimal128 object by another one. The computation proceeds as though infinite precision and unbounded range were available, rounding, if necessary.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Perform ? RequireInternalSlot(_x_, [[Decimal128Data]]).
      1. Let _d1_ be _O_.[[Decimal128Data]].
      1. Let _d2_ be _x_.[[Decimal128Data]].
      1. If _d1_ or _d2_ is *NaN*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
      1. If _d1_ is *+∞*<sub>𝔻</sub>, then
        1. If _d2_ is *+∞*<sub>𝔻</sub> or *-∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
        1. If sign(_d2_) = -1, return Decimal128ValueToObject(*-∞*<sub>𝔻</sub>).
        1. Otherwise, return Decimal128ValueToObject(*+∞*<sub>𝔻</sub>).
      1. If _d1_ is *-∞*<sub>𝔻</sub>, then
        1. If _d2_ is *+∞*<sub>𝔻</sub> or *-∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
        1. If sign(_d2_) = -1, return Decimal128ValueToObject(*+∞*<sub>𝔻</sub>).
        1. Otherwise, return Decimal128ValueToObject(*-∞*<sub>𝔻</sub>).
      1. If _d2_ is *+∞*<sub>𝔻</sub>, then
        1. If sign(_d1_) = -1, return *−0*<sub>𝔻</sub>.
        1. Otherwise, return *+0*<sub>𝔻</sub>.
      1. If _d2_ is *-∞*<sub>𝔻</sub>, then
        1. If sign(_d1_) = -1, return *+0*<sub>𝔻</sub>.
        1. Otherwise, return *−0*<sub>𝔻</sub>.
      1. Let _v1_ be cohort(_d1_).
      1. Let _v2_ be cohort(_d2_).
      1. Let _q1_ be quantum(_d1_).
      1. Let _q2_ be quantum(_d2_).
      1. Let _newQ_ be _q2_ − _q1_.
      1. If _q2_ is *+0*<sub>𝔻</sub> or *−0*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
      1. If _v1_ is *+0*<sub>𝔻</sub>, then
        1. If _v2_ < 0, return Decimal128ValueToObject(PickQuantum(*−0*<sub>𝔻</sub>, 0, _newQ_)).
        1. Otherwise, return Decimal128ValueToObject(PickQuantum(*+0*<sub>𝔻</sub>, 0, _newQ_)).
      1. If _v1_ is *−0*<sub>𝔻</sub>, then
        1. If _v2_ < 0, return Decimal128ValueToObject(PickQuantum(*+0*<sub>𝔻</sub>, 0, _newQ_)).
        1. Otherwise, return Decimal128ValueToObject(PickQuantum(*−0*<sub>𝔻</sub>, 0, _newQ_)).
      1. Let _quotient_ be _v1_ / _v2_.
      1. Return Decimal128ValueToObject(RoundAndPickQuantum(_quotient_, _newQ_)).
    </emu-alg>
    <emu-note>
      <p>This operation follows the specification in Section 5.4.1 of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal128.prototype.remainder">
    <h1>Decimal128.prototype.remainder ( _x_ )</h1>
    <p>This method computes the remainder upon dividing the current Decimal128 object by another one. The computation proceeds as though infinite precision and unbounded range were available, rounding, if necessary.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Perform ? RequireInternalSlot(_x_, [[Decimal128Data]]).
      1. Let _d1_ be _O_.[[Decimal128Data]].
      1. Let _d2_ be _x_.[[Decimal128Data]].
      1. If _d1_ or _d2_ is *NaN*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
      1. If _d1_ is *+∞*<sub>𝔻</sub> or *-∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
      1. If _d1_ is *-∞*<sub>𝔻</sub> or *-∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
      1. Let _v1_ be cohort(_d1_).
      1. Let _v2_ be cohort(_d2_).
      1. Let _q1_ be quantum(_d1_).
      1. Let _q2_ be quantum(_d2_).
      1. Let _newQ_ be min(_q1_, _q2_).
      1. If _v2_ is *+0*<sub>𝔻</sub> or *−0*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
      1. If _v1_ is *+0*<sub>𝔻</sub>, return Decimal128ValueToObject(PickQuantum(*+0*<sub>𝔻</sub>, 0, _newQ_)).
      1. If _v1_ is *−0*<sub>𝔻</sub>, return Decimal128ValueToObject(PickQuantum(*−0*<sub>𝔻</sub>, 0, _newQ_)).
      1. Let _remainder_ be _v1_ % _v2_.
      1. If _remainder_ = 0, then
        1. If _v1_ < 0, return Decimal128ValueToObject(PickQuantum(*−0*<sub>𝔽</sub>, 0, _newQ_)).
        1. Otherwise, return Decimal128ValueToObject(PickQuantum(*+0*<sub>𝔽</sub>, 0, _newQ_)).
      1. Return Decimal128ValueToObject(PickQuantum(_remainder_, _remainder_, _newQ_)).
    </emu-alg>
    <emu-note>
      <p>The remainder operation specified here deviates from the <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref> remainder operation (defined there in Section 5.3.1). We follow the <emu-xref href="#sec-numeric-types-number-remainder">the remainder operation for Number</emu-xref> rather than IEEE 754, which specifies that, for example, the remainder 46 and 10 is -4 rather than 6.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal128.prototype.compare">
    <h1>Decimal128.prototype.compare ( _x_ )</h1>
    <p>This method returns one of the four Number values *-1*<sub>𝔽</sub>, *+0*<sub>𝔽</sub>, *1*<sub>𝔽</sub>, and *NaN*<sub>𝔽</sub>. It compares the mathematical value of the current Decimal128 object with that of another Decimal128 object.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Perform ? RequireInternalSlot(_x_, [[Decimal128Data]]).
      1. Let _d1_ be _O_.[[Decimal128Data]].
      1. Let _d2_ be _x_.[[Decimal128Data]].
      1. If _d1_ is *NaN*<sub>𝔻</sub>, return *NaN*<sub>𝔽</sub>.
      1. If _d2_ is *NaN*<sub>𝔻</sub>, return *NaN*<sub>𝔽</sub>.
      1. If _d1_ is *+∞*<sub>𝔻</sub>, then
        1. If _d2_ is *+∞*<sub>𝔻</sub>, return *+0*<sub>𝔽</sub>.
        1. Return *1*<sub>𝔽</sub>.
      1. If _d1_ is *-∞*<sub>𝔻</sub>, then
        1. If _d2_ is *-∞*<sub>𝔻</sub>, return *+0*<sub>𝔽</sub>.
        1. Return *-1*<sub>𝔽</sub>.
      1. If _d2_ is *+∞*<sub>𝔻</sub>, return *-1*<sub>𝔽</sub>.
      1. If _d2_ is *-∞*<sub>𝔻</sub>, return *1*<sub>𝔽</sub>.
      1. If <emu-xref href="#dfn-decimal128-mathematical-value">the mathematical value of</emu-xref> of _d1_ is less than <emu-xref href="#dfn-decimal128-mathematical-value">the mathematical value of</emu-xref> _d2_, return *-1*<sub>𝔽</sub>.
      1. If <emu-xref href="#dfn-decimal128-mathematical-value">the mathematical value of of</emu-xref> _d2_ is less than <emu-xref href="#dfn-decimal128-mathematical-value">the mathematical value of</emu-xref> _d1_, return *1*<sub>𝔽</sub>.
      1. Otherwise, return *+0*<sub>𝔽</sub>.
    </emu-alg>
    <emu-note>
      <p>This operation combines the <code>compareQuietEqual</code>, <code>compareQuietLess</code> operations in Section 5.6.1 (and explained in Section 5.11) of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal128.prototype.equals">
    <h1>Decimal128.prototype.equals ( _x_ )</h1>
    <p>This method returns either *true*, *false*, or *undefined* according as the current Decimal128 object has the same mathematical value as the given Decimal128 object. The value *undefined* is returned if the current Decimal128 object or the argument is a NaN.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Perform ? RequireInternalSlot(_x_, [[Decimal128Data]]).
      1. Let _d1_ be _O_.[[Decimal128Data]].
      1. Let _d2_ be _x_.[[Decimal128Data]].
      1. If _d1_ is *NaN*<sub>𝔻</sub>, return *undefined*.
      1. If _d2_ is *NaN*<sub>𝔻</sub>, return *undefined*.
      1. If _d1_ is *+∞*<sub>𝔻</sub>, then
        1. If _d2_ is *+∞*<sub>𝔻</sub>, return *true*.
        1. Otherwise, return *false*.
      1. If _d1_ is *-∞*<sub>𝔻</sub>, then
        1. If _d2_ is *-∞*<sub>𝔻</sub>, return *true*.
        1. Otherwise, return *false*.
      1. If _d2_ is *+∞*<sub>𝔻</sub> or *-∞*<sub>𝔻</sub>, return *false*.
      1. Let _v1_ be cohort(_d1_).
      1. Let _v2_ be cohort(_d2_).
      1. If _v1_ is *+0*<sub>𝔻</sub> or *+0*<sub>𝔻</sub>, then
        1. If _v2_ is either *+0*<sub>𝔻</sub> or *−0*<sub>𝔻</sub>, return *true*.
        1. Otherwise, return *false*.
      1. If _v2_ is *+0*<sub>𝔻</sub> or *+0*<sub>𝔻</sub>, return *false*.
      1. If _v1_ = _v2_, return *true*.
      1. Otherwise, return *false*.
    </emu-alg>
    <emu-note>
      <p>This operation corresponds to the <code>compareQuietEqual</code> operation in Section 5.6.1 (and explained in Section 5.11) of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal128.prototype.notequals">
    <h1>Decimal128.prototype.notEquals ( _x_ )</h1>
    <p>This method returns either *true*, *false*, or *undefined* according as the current Decimal128 object has a different mathematical value as the given Decimal128 object. The value *undefined* is returned if the current Decimal128 object or the argument is a NaN.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Perform ? RequireInternalSlot(_x_, [[Decimal128Data]]).
      1. Let _d1_ be _O_.[[Decimal128Data]].
      1. Let _d2_ be _x_.[[Decimal128Data]].
      1. If _d1_ is *NaN*<sub>𝔻</sub>, return *undefined*.
      1. If _d2_ is *NaN*<sub>𝔻</sub>, return *undefined*.
      1. If _d1_ is *+∞*<sub>𝔻</sub>, then
        1. If _d2_ is *+∞*<sub>𝔻</sub>, return *false*.
        1. Otherwise, return *true*.
      1. If _d1_ is *-∞*<sub>𝔻</sub>, then
        1. If _d2_ is *-∞*<sub>𝔻</sub>, return *false*.
        1. Otherwise, return *true*.
      1. If _d2_ is *+∞*<sub>𝔻</sub> or *-∞*<sub>𝔻</sub>, return *true*.
      1. Let _v1_ be cohort(_d1_).
      1. Let _v2_ be cohort(_d2_).
      1. If _v1_ is *+0*<sub>𝔻</sub> or *+0*<sub>𝔻</sub>, then
        1. If _v2_ is either *+0*<sub>𝔻</sub> or *−0*<sub>𝔻</sub>, return *false*.
        1. Otherwise, return *true*.
      1. If _v2_ is *+0*<sub>𝔻</sub> or *+0*<sub>𝔻</sub>, return *true*.
      1. If _v1_ = _v2_, return *false*.
      1. Otherwise, return *true*.
    </emu-alg>
    <emu-note>
      <p>This operation corresponds to the <code>compareQuietNotEqual</code> operation in Section 5.6.1 (and explained in Section 5.11) of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal128.prototype.lessthan">
    <h1>Decimal128.prototype.lessThan ( _x_ )</h1>
    <p>This method returns either *true*, *false*, or *undefined* according as the current Decimal128 object has the same mathematical value as the given Decimal128 object. The value *undefined* is returned if the current Decimal128 object or the argument is a NaN.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Perform ? RequireInternalSlot(_x_, [[Decimal128Data]]).
      1. Let _d1_ be _O_.[[Decimal128Data]].
      1. Let _d2_ be _x_.[[Decimal128Data]].
      1. If _d1_ is *NaN*<sub>𝔻</sub>, return *undefined*.
      1. If _d2_ is *NaN*<sub>𝔻</sub>, return *undefined*.
      1. If _d1_ is *+∞*<sub>𝔻</sub>, return *false*.
      1. If _d1_ is *-∞*<sub>𝔻</sub>, then
        1. If _d2_ is *-∞*<sub>𝔻</sub>, return *false*.
        1. Otherwise, return *true*.
      1. If _d2_ is *+∞*<sub>𝔻</sub>, return *true*.
      1. If _d2_ is *-∞*<sub>𝔻</sub>, return *false*.
      1. Let _v1_ be cohort(_d1_).
      1. Let _v2_ be cohort(_d2_).
      1. If _v1_ is *+0*<sub>𝔻</sub> or *+0*<sub>𝔻</sub>, then
        1. If _v2_ is either *+0*<sub>𝔻</sub> or *−0*<sub>𝔻</sub>, return *false*.
        1. If _v2_ > 0, return *true*.
        1. Otherwise, return *false*.
      1. If _v2_ is *+0*<sub>𝔻</sub> or *+0*<sub>𝔻</sub>, then
        1. If _v1_ < 0, return *true*.
        1. Otherwise, return *false*.
      1. If _v1_ < _v2_, return *true*.
      1. Otherwise, return *false*.
    </emu-alg>
    <emu-note>
      <p>This operation corresponds to the <code>compareQuietEqual</code> operation in Section 5.6.1 (and explained in Section 5.11) of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal128.prototype.lessthanorequal">
    <h1>Decimal128.prototype.lessThanOrEqual ( _x_ )</h1>
    <p>This method returns either *true*, *false*, or *undefined* according as the current Decimal128 object has the same or smaller mathematical value as the given Decimal128 object. The value *undefined* is returned if the current Decimal128 object or the argument is a NaN.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Perform ? RequireInternalSlot(_x_, [[Decimal128Data]]).
      1. Let _d1_ be _O_.[[Decimal128Data]].
      1. Let _d2_ be _x_.[[Decimal128Data]].
      1. If _d1_ is *NaN*<sub>𝔻</sub>, return *undefined*.
      1. If _d2_ is *NaN*<sub>𝔻</sub>, return *undefined*.
      1. If _d1_ is *+∞*<sub>𝔻</sub>, then
        1. If _d2_ is *+∞*<sub>𝔻</sub>, return *true*.
        1. Otherwise, return *false*.
      1. If _d1_ is *-∞*<sub>𝔻</sub>, return *true*.
      1. If _d2_ is *+∞*<sub>𝔻</sub>, return *true*.
      1. If _d2_ is *-∞*<sub>𝔻</sub>, return *false*.
      1. Let _v1_ be cohort(_d1_).
      1. Let _v2_ be cohort(_d2_).
      1. If _v1_ is *+0*<sub>𝔻</sub> or *+0*<sub>𝔻</sub>, then
        1. If _v2_ is either *+0*<sub>𝔻</sub> or *−0*<sub>𝔻</sub>, return *true*.
        1. If _v2_ < 0, return *true*.
        1. Otherwise, return *false*.
      1. If _v2_ is *+0*<sub>𝔻</sub> or *+0*<sub>𝔻</sub>, then
        1. If _v1_ < 0, return *true*.
        1. Otherwise, return *false*.
      1. If _v1_ < _v2_, return *true*.
      1. Otherwise, return *false*.
    </emu-alg>
    <emu-note>
      <p>This operation corresponds to the <code>compareQuietLessEqual</code> operation in Section 5.6.1 (and explained in Section 5.11) of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal128.prototype.greaterthan">
    <h1>Decimal128.prototype.greaterThan ( _x_ )</h1>
    <p>This method returns either *true*, *false*, or *undefined* according as the current Decimal128 object has a greater mathematical value as the given Decimal128 object. The value *undefined* is returned if the current Decimal128 object or the argument is a NaN.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Perform ? RequireInternalSlot(_x_, [[Decimal128Data]]).
      1. Let _d1_ be _O_.[[Decimal128Data]].
      1. Let _d2_ be _x_.[[Decimal128Data]].
      1. If _d1_ is *NaN*<sub>𝔻</sub>, return *undefined*.
      1. If _d2_ is *NaN*<sub>𝔻</sub>, return *undefined*.
      1. If _d1_ is *+∞*<sub>𝔻</sub>, then
        1. If _d2_ is *+∞*<sub>𝔻</sub>, return *false*.
        1. Otherwise, return *true*.
      1. If _d1_ is *-∞*<sub>𝔻</sub>, return *false*.
      1. If _d2_ is *+∞*<sub>𝔻</sub>, return *false*.
      1. If _d2_ is *-∞*<sub>𝔻</sub>, return *true*.
      1. Let _v1_ be cohort(_d1_).
      1. Let _v2_ be cohort(_d2_).
      1. If _v1_ is *+0*<sub>𝔻</sub> or *+0*<sub>𝔻</sub>, then
        1. If _v2_ is either *+0*<sub>𝔻</sub> or *−0*<sub>𝔻</sub>, return *false*.
        1. If _v2_ < 0, return *true*.
        1. Otherwise, return *false*.
      1. If _v2_ is *+0*<sub>𝔻</sub> or *+0*<sub>𝔻</sub>, then
        1. If _v1_ > 0, return *true*.
        1. Otherwise, return *false*.
      1. If _v1_ > _v2_, return *true*.
      1. Otherwise, return *false*.
    </emu-alg>
    <emu-note>
      <p>This operation corresponds to the <code>compareQuietGreater</code> operation in Section 5.6.1 (and explained in Section 5.11) of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal128.prototype.greaterthanorequal">
    <h1>Decimal128.prototype.greaterThanOrEqual ( _x_ )</h1>
    <p>This method returns either *true*, *false*, or *undefined* according as the current Decimal128 object has a greater or equal mathematical value as the given Decimal128 object. The value *undefined* is returned if the current Decimal128 object or the argument is a NaN.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Perform ? RequireInternalSlot(_x_, [[Decimal128Data]]).
      1. Let _d1_ be _O_.[[Decimal128Data]].
      1. Let _d2_ be _x_.[[Decimal128Data]].
      1. If _d1_ is *NaN*<sub>𝔻</sub>, return *undefined*.
      1. If _d2_ is *NaN*<sub>𝔻</sub>, return *undefined*.
      1. If _d1_ is *+∞*<sub>𝔻</sub>, return *true*.
      1. If _d1_ is *-∞*<sub>𝔻</sub>, return *false*.
      1. If _d2_ is *+∞*<sub>𝔻</sub>, return *false*.
      1. If _d2_ is *-∞*<sub>𝔻</sub>, return *true*.
      1. Let _v1_ be cohort(_d1_).
      1. Let _v2_ be cohort(_d2_).
      1. If _v1_ is *+0*<sub>𝔻</sub> or *+0*<sub>𝔻</sub>, then
        1. If _v2_ is either *+0*<sub>𝔻</sub> or *−0*<sub>𝔻</sub>, return *true*.
        1. If _v2_ < 0, return *true*.
        1. Otherwise, return *false*.
      1. If _v2_ is *+0*<sub>𝔻</sub> or *+0*<sub>𝔻</sub>, then
        1. If _v1_ > 0, return *true*.
        1. Otherwise, return *false*.
      1. If _v1_ ≥ _v2_, return *true*.
      1. Otherwise, return *false*.
    </emu-alg>
    <emu-note>
      <p>This operation corresponds to the <code>compareQuietGreaterEqual</code> operation in Section 5.6.1 (and explained in Section 5.11) of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal-method-round">
    <h1>Decimal128.prototype.round ( _numFractionalDigits_ [ , _roundingMode_ ] )</h1>
    <p>This method rounds the current Decimal128 object according to the specified rounding mode, which, if omitted, is <emu-xref href="#dfn-decimal128-default-rounding-mode">the default rounding mode</emu-xref>, with rounding taking place only after _numFractionalDigits_ non-integer digits, which must be a non-negative integer Number.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. If _numFractionalDigits_ is not a Number, throw a *TypeError* exception.
      1. If _numFractionalDigits_ is not an integer, throw a *RangeError* exception.
      1. If _roundingMode_ is neither *undefined* nor a String, throw a *TypeError* exception.
      1. If _roundingMode_ is undefined, set _roundingMode_ to <emu-xref href="#dfn-decimal128-default-rounding-mode">the default rounding mode</emu-xref>.
      1. If _roundingMode_ is not a rounding mode, throw a *RangeError* exception.
      1. Let _d_ be _O_.[[Decimal128Data]].
      1. If _d_ is one of « *NaN*<sub>𝔻</sub>, *+∞*<sub>𝔻</sub>, *-∞*<sub>𝔻</sub> », return Decimal128ValueToObject(_d_).
      1. Let _v_ be cohort(_d_).
      1. If _v_ is *+0*<sub>𝔻</sub> or *−0*<sub>𝔻</sub>, return Decimal128ValueToObject(« _v_, −_numFractionalDigits_ »<sub>𝔻</sub>).
      1. Let _sign_ be sign(_d_).
      1. Let _scaledV_ be _v_ × 10<sup>ℝ(_numFractionalDigits_)</sup>.
      1. If _sign_ = -1, set _scaledV_ to −_scaledV_.
      1. Let _roundedScaledV_ be ApplyRoundingModeToPositive(_scaledV_, _roundingMode_).
      1. If _sign_ = -1, set _roundedScaledV_ to −_roundedScaledV_.
      1. Let _rescaledRoundedV_ be _roundedScaledV_ × 10<sup>−_numFractionalDigits_</sup>.
      1. Return Decimal128ValueToObject(RoundAndPickQuantum(_rescaledRoundedV_, −_numFractionalDigits_, _roundingMode_)).
    </emu-alg>
    <emu-note>
      <p>This operation follows the specification of the rounding mode attributes discussed in Section 4.3 of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal-method-scale10">
    <h1>Decimal128.prototype.scale10 ( _n_ )</h1>
    <p>This method multiplies the current Decimal128 object by 10 raised to the given power.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. If _n_ is not a Number, throw a *TypeError* exception.
      1. If _n_ is not one of « *NaN*<sub>𝔽</sub>, *+∞*<sub>𝔽</sub>, *-∞*<sub>𝔽</sub> », then
        1. If ℝ(_n_) is not an integer, throw a *RangeError* exception.
      1. Let _d_ be _O_.[[Decimal128Data]].
      1. If _d_ is *NaN*<sub>𝔻</sub>, *+∞*<sub>𝔻</sub>, or *-∞*<sub>𝔻</sub>, return Decimal128ValueToObject(_d_).
      1. Let _v_ be cohort(_d_).
      1. Let _q_ be quantum(_d_).
      1. Let _newQuantum_ be _q_ + ℝ(_n_).
      1. If _v_ is either *+0*<sub>𝔻</sub> nor *−0*<sub>𝔻</sub>, then
        1. If _n_ is *NaN*<sub>𝔽</sub>, return Decimal128ValueToObject(_d_).
        1. If _n_ is *+∞*<sub>𝔽</sub>, return Decimal128ValueToObject(« _v_, 6111 »<sub>𝔻</sub>).
        1. If _n_ is *-∞*<sub>𝔽</sub>, return Decimal128ValueToObject(« _v_, -6176 »<sub>𝔻</sub>).
        1. Otherwise, return Decimal128ValueToObject(PickQuantum(_v_, _v_, _newQuantum_)).
      1. If _n_ is *NaN*<sub>𝔽</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
      1. If _n_ is *+∞*<sub>𝔽</sub>, then
        1. If _v_ > 0, return Decimal128ValueToObject(*+∞*<sub>𝔻</sub>).
        1. Otherwise, return Decimal128ValueToObject(*-∞*<sub>𝔻</sub>).
      1. If _n_ is *-∞*<sub>𝔽</sub>, then
        1. If _v_ > 0, return Decimal128ValueToObject(« *+0*<sub>𝔻</sub>, -6176 »<sub>𝔻</sub>).
        1. Otherwise, return Decimal128ValueToObject(« *−0*<sub>𝔻</sub>, -6176 »<sub>𝔻</sub>).
      1. Let _w_ be v × 10<sup>ℝ(_n_)</sup>.
      1. Return Decimal128ValueToObject(RoundAndPickQuantum(_w_, _newQuantum_)).
    </emu-alg>
    <emu-note>
      <p>This operation follows the specification of the <code>scaleB</code> operation discussed in Section 5.3.3 of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal128.prototype.tostring">
    <h1>Decimal128.prototype.toString ( [ _options_ ] )</h1>
    <p>This method generates a String representation of the current Decimal128 object, in decimal format. Its behaviour is similar to that of Number’s <emu-xref href="#sec-number.prototype.tostring">toString</emu-xref> by rendering the decimal in decimal notation, but will use exponential notation if the the magnitude of the number is less than 10<sup>-6</sup> or greater than 10<sup>34</sup>.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Let _preserveTrailingZeroes_ be *false*.
      1. If _options_ is not *undefined*, then
        1. If _options_ is not an Object, throw a *TypeError* exception.
        1. Set _preserveTrailingZeroes_ to ? Get(_options_, *"preserveTrailingZeroes"*).
        1. If _preserveTrailingZeroes_ is not a Boolean value, throw a *TypeError* exception.
      1. Let _d_ be _O_.[[Decimal128Data]].
      1. If _d_ is *NaN*<sub>𝔻</sub>, return "NaN".
      1. If _d_ is *+∞*<sub>𝔻</sub>, return "Infinity".
      1. If _d_ is *-∞*<sub>𝔻</sub>, return "-Infinity".
      1. Let _v_ be cohort(_d_).
      1. Let _q_ be quantum(_d_).
      1. If _v_ is *+0*<sub>𝔻</sub> or *−0*<sub>𝔻</sub>, then
        1. Let _signPrefix_ be *""*.
        1. If _v_ is *−0*<sub>𝔻</sub>, set _signPrefix_ to *"-"*.
        1. If _q_ ≥ 0, return *"0"*.
        1. If _q_ > -6, return the concatenation of _signPrefix_, *"0"*, *"."*, and the string *"0"* repeated _q_ times.
        1. Otherwise, return the concatenation of _signPrefix_, *"0"*, *"e"*, and the string representation of _q_ in decimal notation.
      1. If abs(_v_) < 10<sup>-6</sup> or abs(_v_) ≥ 10<sup>34</sup>, return return Decimal128ToExponentialString(_O_, _preserveTrailingZeroes_).
      1. Otherwise, return Decimal128ToDecimalString(_O_, _preserveTrailingZeroes_).
    </emu-alg>
    <emu-note>
      <p>This operation follows the specification of the conversion of IEEE 754 Decimal128 values to strings (external character sequences) discussed in Section 5.12 of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal128.prototype.toexponential">
    <h1>Decimal128.prototype.toExponential ( [ _options_ ] )</h1>
    <p>This method generates a String representation of the current Decimal128 object, in exponential format (e.g., *"123e-4"*).</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Let _shouldCanonicalize_ be *true*.
      1. If _options_ is not *undefined*, then
        1. If _options_ is not an Object, throw a *TypeError* exception.
        1. Set _shouldCanonicalize_ to ? Get(_options_, *"canonicalize"*).
        1. If _shouldCanonicalize_ is not a Boolean value, throw a *TypeError* exception.
      1. Return Decimal128ToExponentialString(_O_, _shouldCanonicalize_).
    </emu-alg>
    <emu-note>
      <p>This operation follows the specification of the conversion of IEEE 754 Decimal128 values to strings (external character sequences) discussed in Section 5.12 of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal128.prototype.tofixed">
    <h1>Decimal128.prototype.toFixed ( [ _options_ ] )</h1>
    <p>This method generates a String representation of the current Decimal128 object, in decimal format, with a specified number of digits after the decimal point.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Let _numDigits_ be *+0*<sub>𝔽</sub>.
      1. If _options_ is not *undefined*, then
        1. If _options_ is not an Object, throw a *TypeError* exception.
        1. Set _numDigits_ to ? Get(_options_, *"digits"*).
        1. If _numDigits_ is not a Number, throw a *TypeError* exception.
      1. If _numDigits_ < 0, throw a *RangeError* exception.
      1. If _numDigits_ is not an integer, throw a *RangeError* exception.
      1. Let _s_ be Decimal128ToDecimalString(_O_, *false*).
      1. If _s_ is *"NaN"*, *"Infinity"*, or *"-Infinity"*, return _s_.
      1. Let _integerDigits_ be *""*.
      1. Let _nonIntegerDigits_ be *""*.
      1. If _s_ contains a *"."*, then
        1. Set _integerDigits_ to the substring of _s_ up to the first occurrence of *"."* in _s_.
        1. Set _nonIntegerDigits_ to the substring of _s_ after the first occurrence of *"."* in _s_.
        1. If _numDigits_ > 0, set _nonIntegerDigits_ to the substring of _nonIntegerDigits_ from 0 to _numDigits_.
      1. Else,
        1. Set _integerDigits_ to _s_.
      1. If _numDigits_ is 0, return _integerDigits_.
      1. Return the concatenation of _integerDigits_, *"."*, and _nonIntegerDigits_.
    </emu-alg>
    <emu-note>
      <p>This operation follows the specification of the conversion of IEEE 754 Decimal128 values to strings (external character sequences) discussed in Section 5.12 of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal128.prototype.toprecision">
    <h1>Decimal128.prototype.toPrecision ( [ _options_ ] )</h1>
    <p>This method generates a String representation of the current Decimal128 object, in decimal format, with a specified number of significant digits. If the _precision_ argument is omitted or is *undefined*, this method is equivalent to <emu-xref href="#sec-decimal128.prototype.tostring">toString</emu-xref>. This method may produce results in exponential notation or decimal notation.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Let _shouldCanonicalize_ be *true*.
      1. If _shouldCanonicalize_ is neither *undefined* nor a Boolean value, throw a *TypeError* exception.
      1. If _precision_ is neither *undefined* nor a Number, throw a *TypeError* exception.
      1. If _precision_ is *undefined*, return Decimal128ToDecimalString(_O_, _shouldCanonicalize_).
      1. If _precision_ is not an integer, throw a *RangeError* exception.
      1. If _precision_ < 1, throw a *RangeError* exception.
      1. Let _d_ be _O_.[[Decimal128Data]].
      1. If _d_ is *NaN*<sub>𝔻</sub>, return *"NaN"*.
      1. If _d_ is *+∞*<sub>𝔻</sub>, return *"Infinity"*.
      1. If _d_ is *-∞*<sub>𝔻</sub>, return *"-Infinity"*.
      1. Let _v_ be cohort(_d_).
      1. Let _q_ be quantum(_d_).
      1. If _v_ is *+0*<sub>𝔻</sub>, return *"0"*.
      1. If _v_ is *−0*<sub>𝔻</sub>, return *"-0"*.
      1. If −_q_ < _precision_, then
        1. Let _s_ be Decimal128ToDecimalString(_O_, _shouldCanonicalize_).
        1. Let _integerDigits_ be the substring of _s_ up to the first occurrence of *"."* in _s_.
        1. Let _nonIntegerDigits_ be the substring of _s_ after the first occurrence of *"."* in _s_.
        1. Let _numTrailingZeroesToAdd_ be _precision_ minus the length of _nonIntegerDigits_.
        1. Let _trailingZeroes_ be the string *"0"* repeated _numTrailingZeroesToAdd_ times.
        1. Return the concatenation of _integerDigits_, *"."*, _nonIntegerDigits_, and _trailingZeroes_.
      1. Let _n_ be the integer such that v × 10<sup>−_q_</sup> = _n_ and 0 < abs(_n_) < 10<sup>34</sup>.
      1. Let _n1_ be the largest multiple of 10 such that _n_ − _n1_ < 10<sup>_precision_</sup>.
      1. Let _v1_ be _v_ − (_n1_ / 10<sup>_precision_</sup>).
      1. Assert: _v1_ ≠ 0.
      1. Let _N_ be RoundAndPickQuantum(_v1_, −_precision_).<sub>𝔻</sub>.
      1. Return Decimal128ToDecimalString(_N_, _shouldCanonicalize_).
    </emu-alg>
    <emu-note>
      <p>This operation follows the specification of the conversion of IEEE 754 Decimal128 values to strings (external character sequences) discussed in Section 5.12 of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal128.prototype.valueof">
    <h1>Decimal128.prototype.valueOf ( _x_ )</h1>
    <p>This method performs the following steps when called:</p>
    <emu-alg>
      1. Throw a *TypeError* exception.
    </emu-alg>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-numbers-and-dates">
  <h1>Numbers and Dates</h1>
  <emu-clause id="sec-number-objects">
    <h1>Number Objects</h1>

    <emu-clause id="sec-number-constructor">
      <h1>The Number Constructor</h1>
      <emu-clause id="sec-number-constructor-number-value">
        <h1>Number ( _value_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If _value_ is present, then
            1. <ins>If _value_ is an object that has an [[Decimal128Data]] internal slot, then</ins>
              1. <ins>Let _d_ be _value_.[[Decimal128Data]].</ins>
              1. <ins>Let _serialized_ be Decimal128ToExponentialString(_d_, *false*).</ins>
              1. <ins>Let _n_ be ! ToNumber(_serialized_).</ins>
            1. Else,
              1. Let _prim_ be ? ToNumeric(_value_).
              1. If _prim_ is a BigInt, let _n_ be 𝔽(ℝ(_prim_)).
              1. Otherwise, let _n_ be _prim_.
          1. Else,
            1. Let _n_ be *+0*<sub>𝔽</sub>.
          1. If NewTarget is *undefined*, return _n_.
          1. Let _O_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%Number.prototype%"*, « [[NumberData]] »).
          1. Set _O_.[[NumberData]] to _n_.
          1. Return _O_.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-bigint-objects">
    <h1>BigInt Objects</h1>
    <emu-clause id="sec-bigint-constructor">
      <h1>The BigInt Constructor</h1>
      <emu-clause id="sec-bigint-constructor-number-value">
        <h1>BigInt ( _value_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If NewTarget is not *undefined*, throw a *TypeError* exception.
          1. <ins>If _value_ has a [[Decimal128Data]] internal slot, return ? Decimal128ToBigInt(_value_).</ins>
          1. Let _prim_ be ? ToPrimitive(_value_, ~number~).
          1. If _prim_ is a Number, return ? NumberToBigInt(_prim_).
          1. Otherwise, return ? <emu-meta suppress-effects="user-code">ToBigInt(_prim_)</emu-meta>.
        </emu-alg>

         <emu-clause id="sec-numbertobigint" type="abstract operation">
          <h1>
            <ins>Decimal128ToBigInt (
            _number_: a Decimal128 object,
            ): either a normal completion containing a BigInt or a throw completion</ins>
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. If IsIntegralDecimal128(_number_) is *false*, throw a *RangeError* exception.
            1. Return ℤ(ℝ(_number_)).
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-import href="./intl.emu"></emu-import>
