<!DOCTYPE html>
<meta charset="utf-8">
<link rel="stylesheet" href="./spec.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">
<script src="./spec.js"></script>
<pre class="metadata">
title: Decimal
status: proposal
stage: 1
contributors: Jesse Alama
location: https://github.com/tc39/proposal-decimal/
</pre>

<emu-intro id="sec-decimal-intro-">
  <h1>Introduction</h1>
  <p>This specification consists of two parts:</p>
  <ul>
    <li>The specification of the <a href="https://github.com/tc39/proposal-decimal/" title="Decimal proposal (GitHub)">Decimal proposal</a> and everything related to it, proposed to be added to ECMA-262 in new sections;</li>
    <li>A list of amendments to be made to ECMA-402.</li>
  </ul>
</emu-intro>

<emu-clause id="sec-the-decimal-object">
  <h1>The Decimal128 Object</h1>

  <emu-intro id="sec-decimal-intro">
    <h1>Introduction</h1>
    <p>Decimal128 values, as specified here, are intended to represent base-10 (decimal) numbers as specified in <emu-xref href="#sec-bibliography">IEEE 754> Decimal128</emu-xref>. A Decimal128 value, as specified here, is one of the following four kinds of values:</p>

    <ul>
      <li>*NaN*<sub>𝔻</sub>, represending a decimal not-a-number</li>
      <li>*+∞*<sub>𝔻</sub>, representing positive infinity as a decimal,</li>
      <li>*-∞*<sub>𝔻</sub>, representing negative infinity as a decimal,</li>
      <li>« _v_, _q_ », where _v_ and _q_ satisfy the following conditions:</li>
      <ul>
        <li>_v_ is either
        <ul>
          <li>*+0*<sub>𝔻</sub>, represending non-negative zero as a decimal value</li>
          <li>*-0*<sub>𝔻</sub>, representing negative zero as a decimal value, or</li>
          <li>a mathematical value</li>
        </ul></li>
        <li>_q_ is an integer satisfying -6176 ≤ _q_ ≤ 6111,</li>
        <li>If _v_ is a mathematical value, then v × 10<sup>-_q_</sup> is an integer _n_ such that 0 < abs(_n_) < 10<sup>34</sup></li>
      </ul>
    </ul>
    <emu-note>
      <p>A Decimal128 value is not an ECMAScript language value.</p>
    </emu-note>
    <p>The <dfn id="dfn-decimal128-mathematical-value">mathematical value</dfn> of a finite Decimal128 value _x_ = « _v_, _q_ »<sub>𝔻</sub> is defined as follows:</p>
    <ul>
      <li>If _x_ is zero, the mathematical value of _x_ is 0</li>
      <li>If _x_ is non-zero, the mathematical value of _x_ is v × 10<sup>_q_</sup></li>
    </ul>
    <p>A Decimal128 value is said to be <dfn id="dfn-decimal128-finite">finite</dfn> if it has the form « _v_, _q_ ». A <dfn id="dfn-decimal128-zero">zero</dfn> Decimal128 value is a finite Decimal128 value of the form « 0<sub>𝔻</sub>, _q_ »<sub>𝔻</sub> or « -0<sub>𝔻</sub>, _q_ »<sub>𝔻</sub>. A finite non-zero Decimal128 value is one of the form « _v_, _q_ »<sub>𝔻</sub> where _v_ is a mathematical value. A finite Decimal128 value « _v_, _q_ » is said to be <dfn>negative</dfn> if either _v_ is -0<sub>D</sub> or _v_ is a real number such that _v_ < 0.</p>
    <emu-note>
      <p>The _v_ component of a finite non-zero Decimal128 value « _v_, _q_ »<sub>𝔻</sub> is a rational number.</p>
    </emu-note>
    <p>Decimal128 values defined in this section are ECMAScript analogues of <emu-xref href="#sec-bibliography">IEEE 754 Decimal128 values</emu-xref>. The full spectrum of values defined by Decimal128 are available here, though there is only one Decimal128 value, NaN<sub>𝔻</sub>, representing all possible IEEE 754 Decimal128 NaN values.</p>
    <p>A <dfn id="dfn-decimal128-rounding-mode">rounding mode</dfn> is one of the String values *"ceil"*, *"floor"*, *"trunc"*, *"halfExpand"*, and *"halfEven"*. The <dfn id="dfn-decimal128-default-rounding-mode">default rounding mode</dfn> is the String value *"halfEven"*.</p>
    <emu-table id="table-decimal128-rounding-modes">
      <emu-caption>Rounding modes in Decimal128 compared to IEEE 754 rounding modes</emu-caption>
      <table class="real-table">
        <thead>
          <tr>
            <th>Decimal128 rounding mode</th>
            <th>Description</th>
            <th>IEEE 754 rounding mode</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>*"ceil"*</td>
            <td>Toward positive infinity</td>
            <td>*"roundTowardPositive"*</td>
          </tr>
          <tr>
            <td>*"floor"*</td>
            <td>Toward negative infinity</td>
            <td>*"roundTowardNegative"*</td>
          </tr>
          <tr>
            <td>*"trunc"*</td>
            <td>Toward zero</td>
            <td>*"roundTowardZero"*</td>
          </tr>
          <tr>
            <td>*"halfExpand"*</td>
            <td>Ties away from zero</td>
            <td>*"roundTiesToAway"*</td>
          </tr>
          <tr>
            <td>*"halfEven"*</td>
            <td>Ties toward an even rounding increment multiple</td>
            <td>*"roundTiesToEven"*</td>
          </tr>
        </tbody>
      </table>
      <emu-note>The above five rounding modes are defined in IEEE 754. This table is offered for implementors who may need to convert the Decimal128 rounding modes defined here into a library that may use the official IEEE 754 rounding mode names. Additional rounding modes are used elsewhere in this specification, such as in <emu-xref href="#table-intl-rounding-modes">Intl.NumberFormat</emu-xref>.</emu-note>
    </emu-table>
    <p>The <dfn id="dfn-decimal128-cohort">cohort</dfn> of a Decimal128 value is defined as follows:</p>
    <ul>
      <li>cohort(*NaN*<sub>𝔻</sub>) = *NaN*<sub>𝔻</sub></li>
      <li>cohort(*+∞*<sub>𝔻</sub>) = *+∞*<sub>𝔻</sub></li>
      <li>cohort(*-∞*<sub>𝔻</sub>) = *-∞*<sub>𝔻</sub></li>
      <li>cohort(« _v_, _q_ »<sub>𝔻</sub>) = _v_</li>
    </ul>
    <p>For every finite non-zero Decimal128 value « _v_, _q_ »<sub>𝔻</sub> there exists a unique integer _e_ and mathematical value _s_ such that</p>
    <ol>
      <li>_v_ = _s_ × 10<sup>_e_</sup></li>
      <li>1 ≤ abs(_s_) < 10</li>
    </ol>
    <p>We call _e_ the <dfn>exponent</dfn> and _s_ the <dfn>significand</dfn> of « _v_, _q_ »<sub>𝔻</sub>. The exponent and significand are undefined for NaN, non-finite, and zero Decimal128 values.</p>
    <emu-note>
      <p>The significand of a finite non-zero Decimal128 value is a rational number.</p>
    </emu-note>
    <emu-note>
      <p>The exponent _e_ of finite non-zero Decimal128 values is an integer satisfying 6144 ≥ _e_ ≥ -6176.</p>
    </emu-note>
    <p>A finite non-zero Decimal128 value is <dfn>normalized</dfn> if its exponent _e_ satisfies 6144 ≥ _e_ ≥ -6143. A finite non-zero Decimal128 value is <dfn>denormalized</dfn> if its exponent _e_ satisfies -6144 ≥ _e_ ≥ -6176.</p>
    <p>For a proper discussion of rounding, we need to separate how rounding occurs with normalized compared with denormlized values. For a normalized Decimal128 value we define its <dfn>truncated exponent</dfn> as equal to its exponent. For zero or denormalized Decimal128 values we define the truncated exponent as the constant -6143. Given this, we define the <dfn>scaled significand</dfn> of a finite Decimal128 value as follows:</p>
    <ul>
      <li>The scaled significand of a zero Decimal128 value is 0</li>
      <li>The scaled significand of a non-zero Decimal128 value _x = « _v_, _q_ »<sub>𝔻</sub> is v × 10<sup>33 - _te_</sup>, where _t_ is the truncated exponent of _x_.</li>
    </ul>
    <emu-note>
      <p>The scaled significand of a finite Decimal128 value is always an integer whose absolute value is less than 10<sup>34</sup>.</p>
    </emu-note>
  </emu-intro>
  <emu-clause id="sec-decimal-abstract-ops">
    <h1>Abstract Operations</h1>

    <emu-clause id="sec-decimal128-decimal128todecimalstring" type="abstract operation">
      <h1>
        Decimal128ToDecimalString (
          _argument_ : a Decimal128 value
        ): a String
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It renders _argument_ as a decimal (non-exponential) string.</dd>
      </dl>
      <emu-alg>
        1. If _argument_ is *NaN*<sub>𝔻</sub>, return *"NaN"*.
        1. If _argument_ is *+∞*<sub>𝔻</sub>, return *"Infinity"*.
        1. If _argument_ is *-∞*<sub>𝔻</sub>, return *"-Infinity"*.
        1. Let _v_ be _argument_[0].
        1. Let _q_ be _argument_[1].
        1. If _v_ is *+0*<sub>𝔻</sub>, return *"0"*.
        1. If _v_ is *-0*<sub>𝔻</sub>, return *"-0"*.
        1. Let _n_ be the integer for which _v_ × 10<sup>-_q_</sup> = _n_ and 0 < abs(_n_) < 10<sup>34</sup>.
        1. Assert: _n_ is not 0.
        1. Let _digits_ be the unique decimal string representation of _n_ without leading zeroes.
        1. If _q_ < 0, then
          1. Let _trailingZeroes_ be the String *"0"* repeated abs(_n_) - _q_ times.
          1. Return the concatenation of _digits_ and _trailingZeroes_.
        1. Let _integerPart_ be the substring of _digits_ from 0 to abs(n) - _q_.
        1. Let _nonIntegerPart_ be the substring of _digits_ from abs(n) - _q_ to the length of _digits_.
        1. Return the concatenation of _integerPart_, *"."*, and _nonIntegerPart_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-decimal128toexponentialstring" type="abstract operation">
      <h1>
        Decimal128ToExponentialString (
          _argument_ : a Decimal128 value
        ): a String
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It renders _argument_ in exponential notation.</dd>
      </dl>
      <emu-alg>
        1. If _argument_ is *NaN*<sub>𝔻</sub>, return *"NaN"*.
        1. If _argument_ is *+∞*<sub>𝔻</sub>, return *"Infinity"*.
        1. If _argument_ is *-∞*<sub>𝔻</sub>, return *"-Infinity"*.
        1. Let _v_ be _argument_[0].
        1. Let _q_ be _argument_[1].
        1. If _v_ is *+0*<sub>𝔻</sub>, return *"0"*.
        1. If _v_ is *-0*<sub>𝔻</sub>, return *"-0"*.
        1. Let _coefficientStr_ be the unique decimal string representation of _v_ without leading zeroes.
        1. Let _exponentStr_ be the unique decimal string representation of _q_ without leading zeroes.
        1. Return the concatenation of _coefficientStr_, *"e"*, and _exponentStr_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-decimal128-isintegraldecimal128value" type="abstract operation">
      <h1>
        IsIntegralDecimal128 (
          _argument_: A Decimal128 object
        ): a Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It determines if _argument_ is a finite integral Decimal128 value.</dd>
      </dl>
      <emu-alg>
        1. Let _d_ be _argument_.[[Decimal128Data]].
        1. If _d_ is *NaN*<sub>𝔻</sub>, return *false*.
        1. If _d_ is *+∞*<sub>𝔻</sub> or *-∞*<sub>𝔻</sub>, return *false*.
        1. Let _v_ be _d_[0].
        1. Let _q_ be _d_[1].
        1. If _v_ is an integer and 0 ≤ _q_, return *true*.
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-decimal128-value-to-object" type="abstract operation">
      <h1>
        Decimal128ValueToObject (
          _argument_ : a Decimal128 value
        ): a Decimal128 object
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It converts a Decimal128 value to a Decimal128 object.</dd>
      </dl>
      <emu-alg>
        1. Let _O_ be ! OrdinaryCreateFromConstructor(%Decimal128%, *"%Decimal128.prototype%"*, « [[Decimal128Data]] »).
        1. Set _O_.[[Decimal128Data]] to _argument_.
        1. Return _O_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-decimal128-d" type="abstract operation">
      <h1>
        EnsureDecimal128Value (
          _coefficient_ : a mathematical value,
          _intendedExponent_ : a mathematical value,
          _roundingMode_: a Decimal128 rounding mode
        ): either a normal completion containing a Decimal128 value or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It attempts to convert the pair of arguments, which might be out of range when considered as a Decimal128 value, into a Decimal128 value, throwing an exception if the conversion cannot be done.</dd>
      </dl>
      <emu-alg>
        1. If -6111 ≤ _intendedExponent_ ≤ 6176, then
          1. If _coefficient_ × 10<sup>_intendedExponent_</sup> is an integer _n_ such that 0 < abs(_n_) < 10<sup>34</sup>, return « _coefficient, _intendedExponent_ ».
          1. Throw a *RangeError* exception.
        1. If _intendedExponent_ < 0, return ? EnsureDecimal128Value(_coefficient_ / 10, _intendedExponent_ + 1, _roundingMode_).
        1. Otherwise, return ? EnsureDecimal128Value(_coefficient_ × 10, _intendedExponent_ + 1, _roundingMode_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-the-decimal-constructor">
    <h1>The Decimal128 Constructor</h1>
    <p>The Decimal128 constructor:</p>
    <ul>
      <li>is <dfn>%Decimal128%</dfn>.</li>
      <li>is the initial value of the the *"Decimal128"* property of the global object.</li>
      <li>creates and initializes a new Decimal128 object when called as a constructor</li>
      <li>may be used as the value of an *extends* clause of a class definition. Subclass constructors that intend to inherit the specified Decimal128 behaviour must include a *super* call to the Decimal128 constructor to create and initialize the subclass instance with a [[Decimal128Data]] internal slot.</li>
    </ul>
    <emu-clause id="sec-the-decimal128-constructor-value">
      <h1>Decimal128 ( _x_ )</h1>
      <emu-alg>
        1. If NewTarget is *undefined*, throw a *TypeError* exception.
        1. Let _toParse_ be *undefined*.
        1. If _x_ is a BigInt, set _toParse_ to BigInt::toString(_x_, 10).
        1. Otherwise, if _x_ is a Number, set _toParse_ to Number::toString(_x_, 10).
        1. Otherwise, if _x_ is a String, set _toParse_ to _x_.
        1. If _toParse_ is not a String, throw a *TypeError* exception.
        1. Let _O_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%Decimal128.prototype%"*, « [[Decimal128Data]] »).
        1. If _toParse_ is *"NaN"*, regardless of case, set _O_.[[Decimal128Data]] to *NaN*<sub>𝔻</sub>.
        1. If _toParse_ is *"-Infinity"*, regardless of case, set _O_.[[Decimal128Data]] to *-∞*<sub>𝔻</sub>.
        1. If _toParse_ is *"Infinity"*, regardless of case, set _O_.[[Decimal128Data]] to *+∞*<sub>𝔻</sub>.
        1. Let _parseResult_ be ParseText(_toParse_, |DecimalLiteral|).
        1. If _parseResult_ is a List of errors, throw a *SyntaxError* exception.
        1. If _parseResult_ contains a |DecimalIntegerLiteral|, then
          1. Let _integerPart_ be the source text contained within the |DecimalIntegerLiteral| Parse Node.
        1. Else,
          1. Let _integerPart_ be *"0"*.
        1. Let _nonIntegerDigits_ be the source text contained within the |DecimalLiteral| Parse Node.
        1. If _parseResult_ contains a |ExponentPart| Parse Node whose source text is not *""*, then
          1. Let _exponentPart_ be the source text contained within the |ExponentPart| Parse Node.
          1. Let _s_ be the concatenation of _integerPart_ and _nonIntegerDigits_.
          1. Let _m_ be the mathematical value whose decimal representation is _s_.
          1. Let _e_ be the mathematical value whose decimal representatin is _exponentPart_.
          1. Set _O_.[[Decimal128Data]] to ? EnsureDecimal128Value(_m_, _e_, *"halfEven"*).
        1. Else,
          1. Let _s_ be the concatenation of _integerPart_ and _nonIntegerDigits_.
          1. Let _q_ be the length of _nonIntegerDigits_.
          1. Let _m_ be the mathematical value whose decimal representation is _s_.
          1. Set _O_.[[Decimal128Data]] to ? EnsureDecimal128Value(_m_, -_q_, *"halfEven"*).
        1. Return _O_.
      </emu-alg>
      <emu-note>
        <p>Given a Number argument, the constructor converts it to a String using the <emu-xref href="#sec-number.prototype.tostring">toString</emu-xref> method (with no arguments). In some cases, this may not be desited. In some use cases, given a Number, one may wish to call the Decimal128 constructor not with the number but rather with, for instance, the result of calling <emu-xref href="#sec-number.prototype.tofixed">toFixed</emu-xref> or <emu-xref href="#sec-number.prototype.toprecision">toPrecision</emu-xref> on the Number, thereby ensuring a certain level of precision that may get lost when using Number’s toString.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-decimal-prototype-properties">
  <h1>Properties of the Decimal128 Prototype</h1>

  <emu-clause id="sec-decimal.prototype.isnan">
    <h1>Decimal128.prototype.isNaN ( )</h1>
    <p>This method performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Let _d_ be _O_.[[Decimal128Data]].
      1. If _d_ is *NaN*<sub>𝔻</sub>, return *true*.
      1. Otherwise, return *false*.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-decimal.prototype.isfinite">
    <h1>Decimal128.prototype.isFinite ( )</h1>
    <p>This method performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Let _d_ be _O_.[[Decimal128Data]].
      1. If _d_ is *+∞*<sub>𝔻</sub> or *-∞*<sub>𝔻</sub>, return *true*.
      1. Otherwise, return *false*.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-decimal.prototype.abs">
    <h1>Decimal128.prototype.abs ( )</h1>
    <p>This method performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Let _d_ be _O_.[[Decimal128Data]].
      1. If _d_ is *NaN*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
      1. If _d_ is *+∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*+∞*<sub>𝔻</sub>).
      1. If _d_ is *-∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*+∞*<sub>𝔻</sub>).
      1. Let _v_ be _d_[0].
      1. Let _q_ be _d_[1].
      1. Let _n_ be « abs(_v_), _q_ ».
      1. Let _N_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%Decimal128.prototype%"*, « [[Decimal128Data]] »).
      1. Set _N_.[[Decimal128Data]] to _n_.
      1. Return _N_.
    </emu-alg>
    <emu-note>
      <p>This operation follows the specification in Section 5.5.1 of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal.prototype.negate">
    <h1>Decimal128.prototype.negate ( )</h1>
    <p>This method performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Let _d_ be _O_.[[Decimal128Data]].
      1. If _d_ is *NaN*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
      1. If _d_ is *+∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*-∞*<sub>𝔻</sub>).
      1. If _d_ is *-∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*+∞*<sub>𝔻</sub>).
      1. Let _v_ be _d_[0].
      1. Let _q_ be _d_[1].
      1. Let _n_ be « -1 × _v_, _q_ ».
      1. Let _N_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%Decimal128.prototype%"*, « [[Decimal128Data]] »).
      1. Set _N_.[[Decimal128Data]] to _n_.
      1. Return _N_.
    </emu-alg>
    <emu-note>
      <p>This operation follows the specification in Section 5.5.1 of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal.prototype.add">
    <h1>Decimal128.prototype.add ( _x_ )</h1>
    <p>This method performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Perform ? RequireInternalSlot(_x_, [[Decimal128Data]]).
      1. Let _d1_ be _O_.[[Decimal128Data]].
      1. Let _d2_ be _x_.[[Decimal128Data]].
      1. If _d1_ or _d2_ is *NaN*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
      1. If _d1_ is *+∞*<sub>𝔻</sub>, then
        1. If _d2_ is *+∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*+∞*<sub>𝔻</sub>).
        1. If _d2_ is *-∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
        1. Return Decimal128ValueToObject(*+∞*<sub>𝔻</sub>).
      1. If _d1_ is *-∞*<sub>𝔻</sub>, then
        1. If _d2_ is *+∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
        1. If _d2_ is *-∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*-∞*<sub>𝔻</sub>).
        1. Return Decimal128ValueToObject(*-∞*<sub>𝔻</sub>).
      1. Return Decimal128ValueToObject(? EnsureDecimal128Value(_d1_[0] + _d2_[0], min(_d1_[1], _d2_[1]), *"halfEven"*)).
    </emu-alg>
    <emu-note>
      <p>This operation follows the specification in Section 5.4.1 of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal.prototype.subtract">
    <h1>Decimal128.prototype.subtract ( _x_ )</h1>
    <p>This method performs the following steps when called:</p>
      <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Perform ? RequireInternalSlot(_x_, [[Decimal128Data]]).
      1. Let _d1_ be _O_.[[Decimal128Data]].
      1. Let _d2_ be _x_.[[Decimal128Data]].
      1. If _d1_ or _d2_ is *NaN*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
      1. If _d1_ is *+∞*<sub>𝔻</sub>, then
        1. If _d2_ is *+∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*+∞*<sub>𝔻</sub>).
        1. If _d2_ is *-∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
        1. Return Decimal128ValueToObject(*+∞*<sub>𝔻</sub>).
      1. If _d1_ is *-∞*<sub>𝔻</sub>, then
        1. If _d2_ is *+∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*-∞*<sub>𝔻</sub>).
        1. If _d2_ is *-∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
        1. Return Decimal128ValueToObject(*-∞*<sub>𝔻</sub>).
      1. Return Decimal128ValueToObject(? EnsureDecimal128Value(d1[0] - d2[0], min(d1[1], d2[1]), *"halfEven"*)).
    </emu-alg>
    <emu-note>
      <p>This operation follows the specification in Section 5.4.1 of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal.prototype.multiply">
    <h1>Decimal128.prototype.multiply ( _x_ )</h1>
    <p>This method performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Perform ? RequireInternalSlot(_x_, [[Decimal128Data]]).
      1. Let _d1_ be _O_.[[Decimal128Data]].
      1. Let _d2_ be _x_.[[Decimal128Data]].
      1. If _d1_ or _d2_ is *NaN*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
      1. If _d1_ is *+∞*<sub>𝔻</sub>, then
        1. If _d2_ is *+∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*+∞*<sub>𝔻</sub>).
        1. If _d2_ is *-∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
        1. If _d2_ is a zero Decimal128 value, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
        1. Return Decimal128ValueToObject(*+∞*<sub>𝔻</sub>).
      1. If _d1_ is *-∞*<sub>𝔻</sub>, then
        1. If _d2_ is *+∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*-∞*<sub>𝔻</sub>).
        1. If _d2_ is *-∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*+∞*<sub>𝔻</sub>).
        1. If _d2_ is a zero Decimal128 value, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
        1. If _d2_[0] < 0, return Decimal128ValueToObject(*+∞*<sub>𝔻</sub>).
        1. Return Decimal128ValueToObject(*-∞*<sub>𝔻</sub>).
      1. Return Decimal128ValueToObject(? EnsureDecimal128Value (_d1_[0] × _d2_[0], _d1_[1] + _d2_[1], *"halfEven"*)).
    </emu-alg>
    <emu-note>
      <p>This operation follows the specification in Section 5.4.1 of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal.prototype.divide">
    <h1>Decimal128.prototype.divide ( _x_ )</h1>
    <p>This method performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Perform ? RequireInternalSlot(_x_, [[Decimal128Data]]).
      1. Let _d1_ be _O_.[[Decimal128Data]].
      1. Let _d2_ be _x_.[[Decimal128Data]].
      1. If _d1_ or _d2_ is *NaN*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
      1. If _d1_ is *+∞*<sub>𝔻</sub> or *-∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
      1. If _d2_ is *-∞*<sub>𝔻</sub> or *-∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
      1. Return Decimal128ValueToObject(? EnsureDecimal128Value(_d1_[0] / _d2_[0], _d1_[1] + _d2_[1], *"halfEven"*)).
    </emu-alg>
    <emu-note>
      <p>This operation follows the specification in Section 5.4.1 of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal.prototype.remainder">
    <h1>Decimal128.prototype.remainder ( _x_ )</h1>
    <p>This method performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Perform ? RequireInternalSlot(_x_, [[Decimal128Data]]).
      1. Let _d1_ be _O_.[[Decimal128Data]].
      1. Let _d2_ be _x_.[[Decimal128Data]].
      1. If _d1_ or _d2_ is *NaN*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
      1. If _d1_ is *+∞*<sub>𝔻</sub> or *-∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
      1. If _d1_ is *-∞*<sub>𝔻</sub> or *-∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
      1. Return Decimal128ValueToObject(? EnsureDecimal128Value(_d1_[0] % _d2_[0], _d1_[1] + _d2_[1], *"halfEven"*)).
    </emu-alg>
    <emu-note>
      <p>The remainder operation specified here deviates from the <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref> remainder operation (defined there in Section 5.3.1). We follow the <emu-xref href="#sec-numeric-types-number-remainder">the remainder operation for Number</emu-xref> rather than IEEE 754, which specifies that, for example, the remainder 46 and 10 is -4 rather than 6.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal.prototype.equals">
    <h1>Decimal128.prototype.equals ( _x_ )</h1>
    <p>This method performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Perform ? RequireInternalSlot(_x_, [[Decimal128Data]]).
      1. Let _d1_ be _O_.[[Decimal128Data]].
      1. Let _d2_ be _x_.[[Decimal128Data]].
      1. If _d1_ or _d2_ is *NaN*<sub>𝔻</sub>, throw a *RangeError* exception.
      1. If _d1_ is *+∞*<sub>𝔻</sub>, then
        1. If _d2_ is *+∞*<sub>𝔻</sub>, return *true*.
        1. Return *false*.
      1. If _d1_ is *-∞*<sub>𝔻</sub>, then
        1. If _d2_ is *-∞*<sub>𝔻</sub>, return *true*.
        1. Return *false*.
      I. If _d2_ is *+∞*<sub>𝔻</sub> or *+∞*<sub>𝔻</sub>, return *false*.
      1. If the mathematical value of _d1_ is equal to the mathematical value of _d2_, return *true*.
      1. Return *false*.
    </emu-alg>
    <emu-note>
      <p>This operation follows the specification of the <code>compareSignalingEqual</code> operation in Section 5.6.1 (and explained in Section 5.11) of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal.prototype.lessthan">
    <h1>Decimal128.prototype.lessThan ( _x_ )</h1>
    <p>This method performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Perform ? RequireInternalSlot(_x_, [[Decimal128Data]]).
      1. Let _d1_ be _O_.[[Decimal128Data]].
      1. Let _d2_ be _x_.[[Decimal128Data]].
      1. If _d1_ or _d2_ is *NaN*<sub>𝔻</sub>, throw a *RangeError* exception.
      1. If _d1_ is *+∞*<sub>𝔻</sub>, then
        1. If _d2_ is *+∞*<sub>𝔻</sub> or *-∞*<sub>𝔻</sub>, return *false*.
        1. Return *true*.
      1. If _d1_ is *+∞*<sub>𝔻</sub>, then
        1. If _d2_ is *-∞*<sub>𝔻</sub>, return *false*.
        1. If _d2_ is *+∞*<sub>𝔻</sub>, return *true*.
        1. Return *true*.
      1. If the mathematical value of of _d1_ is less than the mathematical value of _d2_, return *true*.
      1. Return *false*.
    </emu-alg>
    <emu-note>
      <p>This operation follows the specification of the <code>compareSignalingLess</code> operation in Section 5.6.1 (and explained in Section 5.11) of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal.prototype.compare">
    <h1>Decimal128.prototype.compare ( _x_ )</h1>
    <p>This method performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Perform ? RequireInternalSlot(_x_, [[Decimal128Data]]).
      1. Let _d1_ be _O_.[[Decimal128Data]].
      1. Let _d2_ be _x_.[[Decimal128Data]].
      1. If _d1_ is *NaN*<sub>𝔻</sub>, then
        1. If _d2_ is *NaN*<sub>𝔻</sub>, return *true*.
        1. Return *false*.
      1. If _d2_ is *NaN*<sub>𝔻</sub>, return *false*.
      1. If _d1_ is *+∞*<sub>𝔻</sub>, then
        1. If _d2_ is *+∞*<sub>𝔻</sub>, return *+0*<sub>𝔽</sub>.
        1. Return *1*<sub>𝔽</sub>.
      1. If _d1_ is *-∞*<sub>𝔻</sub>, then
        1. If _d2_ is *-∞*<sub>𝔻</sub>, return *+0*<sub>𝔽</sub>.
        1. Return *-1*<sub>𝔽</sub>.
      1. If _d2_ is *+∞*<sub>𝔻</sub>, return *-1*<sub>𝔽</sub>.
      1. If _d2_ is *-∞*<sub>𝔻</sub>, return *1*<sub>𝔽</sub>.
      1. If the mathematical value of of _d1_ is less than the mathematical value of _d2_, return *-1*<sub>𝔽</sub>.
      1. If the mathematical value of of _d2_ is less than the mathematical value of _d1_, return *1*<sub>𝔽</sub>.
      1. Let _v1_ be _d1_[1].
      1. Let _v2_ be _d2_[1].
      1. If the mathematical value of _v1_ is less than the mathematical value of _v2_, return *-1*<sub>𝔽</sub>.
      1. If the mathematical value of _v2_ is less than the mathematical value of _v1_, return *1*<sub>𝔽</sub>.
      1. Return *+0*<sub>𝔽</sub>.
    </emu-alg>
    <emu-note>
      <p>This operation follows the specification of the <code>compareQuietOrdered</code> operation in Section 5.6.1 (and explained in Section 5.11) of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
    <emu-note>
      <p>This operation compares Decimal128 values, intuitively understood as digit strings. Thus, for example, 1.2 and 1.20 are considered distinct values for this operation. To compare by mathematical value, see <emu-xref href="#sec-decimal.prototype.lessthan">lessThan</emu-xref> or <emu-xref href="#sec-decimal.prototype.equals">equals</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal-method-round">
    <h1>Decimal128.prototype.round ( _numFractionalDigits_ [ , _roundingMode_ ] )</h1>
    <p>This method performs the following steps when called:</p>
    <emu-alg>
      1. If _numFractionalDigits_ is not a Number, throw a *TypeError* exception.
      1. If _numFractionalDigits_ < 0, throw a *RangeError* exception.
      1. If _numFractionalDigits_ is not an integer, throw a *RangeError* exception.
      1. If _roundingMode_ is neither *undefined* nor a String, throw a *TypeError* exception.
      1. If _roundingMode_ is undefined, set _roundingMode_ to <emu-xref href="#dfn-decimal128-default-rounding-mode">the default rounding mode</emu-xref>.
      1. If _roundingMode_ is not a rounding mode, throw a *RangeError* exception.
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Let _d_ be _O_.[[Decimal128Data]].
      1. If _d_ is *NaN*<sub>𝔻</sub>, return _O_.
      1. If _d_ is *+∞*<sub>𝔻</sub>, return _O_.
      1. If _d_ is *-∞*<sub>𝔻</sub>, return _O_.
      1. Let _v_ be _d_[0].
      1. Let _q_ be _d_[1].
      1. If _v_ is *+0*<sub>𝔻</sub>, return _O_.
      1. If _v_ is *-0*<sub>𝔻</sub>, return _O_.
      1. Let _n_ be the integer such that v × 10<sup>-_q_</sup> = _n_ and 0 < abs(_n_) < 10<sup>34</sup>.
      1. Return Decimal128ValueToObject(? EnsureDecimal128Value(v × 10<sup>-_numFractionalDigits_</sup>, _q_ + _numFractionalDigits_, _roundingMode_)).
    </emu-alg>
    <emu-note>
      <p>This operation follows the specification of the rounding mode attributes discussed in Section 4.3 of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal.prototype.tostring">
    <h1>Decimal128.prototype.toString ( )</h1>
    <p>This method performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Return Decimal128ToDecimalString(_O_).
    </emu-alg>
    <emu-note>
      <p>This operation follows the specification of the conversion of IEEE 754 Decimal128 values to strings (external character sequences) discussed in Section 5.12 of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal.prototype.toexponential">
    <h1>Decimal128.prototype.toExponential ( )</h1>
    <p>This method performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Return Decimal128ToExponentialString(_O_).
    </emu-alg>
    <emu-note>
      <p>This operation follows the specification of the conversion of IEEE 754 Decimal128 values to strings (external character sequences) discussed in Section 5.12 of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal.prototype.tofixed">
    <h1>Decimal128.prototype.toFixed ( [ _numDigits_ ] )</h1>
    <p>This method performs the following steps when called:</p>
    <emu-alg>
      1. If _numDigits_ is neither *undefined* nor a Number, throw a *TypeError* exception.
      1. If _numDigits_ is *undefined_, let _numDigits_ be *+0*<sub>𝔽</sub>.
      1. If _numDigits_ < 0, throw a *RangeError* exception.
      1. If _numDigits_ is not an integer, throw a *RangeError* exception.
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Let _s_ be Decimal128ToDecimalString(_O_).
      1. If _s_ is *"NaN"*, *"Infinity"*, or *"-Infinity"*, return _s_.
      1. Let _integerDigits_ be *""*.
      1. Let _nonIntegerDigits_ be *""*.
      1. If _s_ contains a *"."*, then
        1. Set _integerDigits_ to the substring of _s_ up to the first occurrence of *"."* in _s_.
        1. Set _nonIntegerDigits_ to the substring of _s_ after the first occurrence of *"."* in _s_.
        1. If _numDigits_ > 0, set _nonIntegerDigits_ to the substring of _nonIntegerDigits_ from 0 to _numDigits_.
      1. Else,
        1. Set _integerDigits_ to _s_.
      1. If _numDigits_ is 0, return _integerDigits_.
      1. Return the concatenation of _integerDigits_, *"."*, and _nonIntegerDigits_.
    </emu-alg>
    <emu-note>
      <p>This operation follows the specification of the conversion of IEEE 754 Decimal128 values to strings (external character sequences) discussed in Section 5.12 of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal.prototype.toprecision">
    <h1>Decimal128.prototype.toPrecision ( [ _precision_ ] )</h1>
    <p>This method performs the following steps when called:</p>
    <emu-alg>
      1. If _precision_ is neither *undefined* nor a Number, throw a *TypeError* exception.
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. If _precision_ is *undefined_, return Decimal128ToDecimalString(_O_).
      1. If _precision_ is not an integer, throw a *RangeError* exception.
      1. If _precision_ < 1, throw a *RangeError* exception.
      1. Let _d_ be _O_.[[Decimal128Data]].
      1. If _d_ is *NaN*<sub>𝔻</sub>, return *"NaN"*.
      1. If _d_ is *+∞*<sub>𝔻</sub>, return *"Infinity"*.
      1. If _d_ is *-∞*<sub>𝔻</sub>, return *"-Infinity"*.
      1. Let _v_ be _d_[0].
      1. Let _q_ be _d_[1].
      1. If _v_ is *+0*<sub>𝔻</sub>, return *"0"*.
      1. If _v_ is *-0*<sub>𝔻</sub>, return *"-0"*.
      1. If -_q_ < _precision_, then
        1. Let _s_ be Decimal128ToDecimalString(_O_).
        1. Let _integerDigits_ be the substring of _s_ up to the first occurrence of *"."* in _s_.
        1. Let _nonIntegerDigits_ be the substring of _s_ after the first occurrence of *"."* in _s_.
        1. Let _numTrailingZeroesToAdd_ be _precision_ minus the length of _nonIntegerDigits_.
        1. Let _trailingZeroes_ be the string *"0"* repeated _numTrailingZeroesToAdd_ times.
        1. Return the concatenation of _integerDigits_, *"."*, _nonIntegerDigits_, and _trailingZeroes_.
      1. Let _n_ be the integer such that v × 10<sup>-_q_</sup> = _n_ and 0 < abs(_n_) < 10<sup>34</sup>.
      1. Let _n1_ be the largest multiple of 10 such that _n_ - _n1_ is less than 10<sup>_precision_</sup>.
      1. Let _v1_ be _v_ - (_n1_ / 10<sup>_precision_</sup>).
      1. Let _N_ be ? EnsureDecimal128Value(_v1_, _precision_, *"halfEven"*).
      1. Return Decimal128ToDecimalString(_N_).
    </emu-alg>
    <emu-note>
      <p>This operation follows the specification of the conversion of IEEE 754 Decimal128 values to strings (external character sequences) discussed in Section 5.12 of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal.prototype.valueof">
    <h1>Decimal128.prototype.valueOf ( _x_ )</h1>
    <p>This method performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Throw a *TypeError* exception.
    </emu-alg>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-numbers-and-dates">
  <h1>Numbers and Dates</h1>
  <emu-clause id="sec-number-objects">
    <h1>Number Objects</h1>
    <emu-clause id="sec-number-constructor">
      <h1>The Number Constructor</h1>
      <emu-clause id="sec-number-constructor-number-value">
        <h1>Number ( _value_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If _value_ is present, then
            1. Let _serialized_ be the result of ! Call([_value_].[[toString]], _value_).
            1. If _value_ is a Decimal128 object, return ! ToNumber(_serialized_).
            1. Let _prim_ be ? ToNumeric(_value_).
            1. If _prim_ is a BigInt, let _n_ be 𝔽(ℝ(_prim_)).
            1. Otherwise, let _n_ be _prim_.
          1. Else,
            1. Let _n_ be *+0*<sub>𝔽</sub>.
          1. If NewTarget is *undefined*, return _n_.
          1. Let _O_ be ? OrdinaryCreateFromConstructor(%Decimal128%, *"%Number.prototype%"*, « [[NumberData]] »).
          1. Set _O_.[[NumberData]] to _n_.
          1. Return _O_.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
  <emu-clause id="sec-bigint-objects">
    <h1>BigInt Objects</h1>
    <emu-clause id="sec-bigint-constructor">
      <h1>The BigInt Constructor</h1>
      <emu-clause id="sec-bigint-constructor-number-value">
        <h1>BigInt ( _value_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If NewTarget is not *undefined*, throw a *TypeError* exception.
          1. <ins>If _value_ is a Decimal128 object, return ? Decimal128ToBigInt(_value_).</ins>
          1. Let _prim_ be ? ToPrimitive(_value_, ~number~).
          1. If _prim_ is a Number, return ? NumberToBigInt(_prim_).
          1. Otherwise, return ? <emu-meta suppress-effects="user-code">ToBigInt(_prim_)</emu-meta>.
        </emu-alg>

         <emu-clause id="sec-numbertobigint" type="abstract operation">
          <h1>
            <ins>Decimal128ToBigInt (
            _number_: a Decimal128 object,
            ): either a normal completion containing a BigInt or a throw completion</ins>
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. If IsIntegralDecimal128(_number_) is *false*, throw a *RangeError* exception.
            1. Return ℤ(ℝ(_number_)).
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-import href="./intl.emu"></emu-import>
