<!DOCTYPE html>
<meta charset="utf-8">
<link rel="stylesheet" href="./spec.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">
<script src="./spec.js"></script>
<pre class="metadata">
title: Decimal
status: proposal
stage: 1
contributors: Jesse Alama
location: https://github.com/tc39/proposal-decimal/
</pre>

<emu-intro id="sec-decimal-intro-">
  <h1>Introduction</h1>
  <p>This specification consists of two parts:</p>
  <ul>
    <li>The specification of the <a href="https://github.com/tc39/proposal-decimal/" title="Decimal proposal (GitHub)">Decimal proposal</a> and everything related to it, proposed to be added to ECMA-262 in new sections;</li>
    <li>A list of amendments to be made to ECMA-402.</li>
  </ul>
</emu-intro>

<emu-clause id="sec-the-decimal-object">
  <h1>The Decimal128 Object</h1>

  <emu-intro id="sec-decimal-intro">
    <h1>Introduction</h1>
    <p>Decimal128 values, as specified here, are intended to represent base-10 (decimal) numbers as specified in <emu-xref href="#sec-bibliography">IEEE 754> Decimal128</emu-xref>. A Decimal128 value, as specified here, is one of the following four kinds of values:</p>

    <ul>
      <li>*NaN*<sub>𝔻</sub>, represending a decimal not-a-number</li>
      <li>*+∞*<sub>𝔻</sub>, representing positive infinity as a decimal,</li>
      <li>*-∞*<sub>𝔻</sub>, representing negative infinity as a decimal,</li>
      <li>« _v_, _q_ »<sub>𝔻</sub>, where _v_ and _q_ satisfy the following conditions:</li>
      <ul>
        <li>_v_ is either
        <ul>
          <li>*+0*<sub>𝔻</sub>, represending non-negative zero as a decimal value</li>
          <li>*-0*<sub>𝔻</sub>, representing negative zero as a decimal value, or</li>
          <li>a mathematical value</li>
        </ul></li>
        <li>_q_ is an integer satisfying -6176 ≤ _q_ ≤ 6111,</li>
        <li>If _v_ is a mathematical value, then v × 10<sup>-_q_</sup> is an integer _n_ such that 0 < abs(_n_) < 10<sup>34</sup></li>
      </ul>
    </ul>
    <emu-note>
      <p>A Decimal128 value is not an ECMAScript language value.</p>
    </emu-note>
    <p>A Decimal128 value is said to be <dfn id="dfn-decimal128-finite">finite</dfn> if it has the form « _v_, _q_ »<sub>𝔻</sub>. A <dfn id="dfn-decimal128-zero">zero</dfn> Decimal128 value is a finite Decimal128 value of the form « 0<sub>𝔻</sub>, _q_ »<sub>𝔻</sub> or « -0<sub>𝔻</sub>, _q_ »<sub>𝔻</sub>. A finite non-zero Decimal128 value is one of the form « _v_, _q_ »<sub>𝔻</sub> where _v_ is a mathematical value. A finite Decimal128 value « _v_, _q_ »<sub>𝔻</sub> is said to be <dfn>negative</dfn> if either _v_ is -0<sub>D</sub> or _v_ is a real number such that _v_ < 0.</p>
    <p>The <dfn id="dfn-decimal128-mathematical-value">mathematical value</dfn> of a finite Decimal128 value _x_ = « _v_, _q_ »<sub>𝔻</sub> is defined as follows:</p>
    <ul>
      <li>If _x_ is zero, the mathematical value of _x_ is 0</li>
      <li>If _x_ is non-zero, the mathematical value of _x_ is v × 10<sup>_q_</sup></li>
    </ul>
    <emu-note>
      <p>The _v_ component of a finite non-zero Decimal128 value « _v_, _q_ »<sub>𝔻</sub> is a rational number.</p>
    </emu-note>
    <p>Decimal128 values defined in this section are ECMAScript analogues of <emu-xref href="#sec-bibliography">IEEE 754 Decimal128 values</emu-xref>. The full spectrum of values defined by Decimal128 are available here, though there is only one Decimal128 value, NaN<sub>𝔻</sub>, representing all possible IEEE 754 Decimal128 NaN values.</p>
    <p>A <dfn id="dfn-decimal128-rounding-mode">rounding mode</dfn> is one of the String values *"ceil"*, *"floor"*, *"trunc"*, *"halfExpand"*, and *"halfEven"*. The <dfn id="dfn-decimal128-default-rounding-mode">default rounding mode</dfn> is the String value *"halfEven"*.</p>
    <emu-table id="table-decimal128-rounding-modes">
      <emu-caption>Rounding modes in Decimal128 compared to IEEE 754 rounding modes</emu-caption>
      <table class="real-table">
        <thead>
          <tr>
            <th>Decimal128 rounding mode</th>
            <th>Description</th>
            <th>IEEE 754 rounding mode</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>*"ceil"*</td>
            <td>Toward positive infinity</td>
            <td>*"roundTowardPositive"*</td>
          </tr>
          <tr>
            <td>*"floor"*</td>
            <td>Toward negative infinity</td>
            <td>*"roundTowardNegative"*</td>
          </tr>
          <tr>
            <td>*"trunc"*</td>
            <td>Toward zero</td>
            <td>*"roundTowardZero"*</td>
          </tr>
          <tr>
            <td>*"halfExpand"*</td>
            <td>Ties away from zero</td>
            <td>*"roundTiesToAway"*</td>
          </tr>
          <tr>
            <td>*"halfEven"*</td>
            <td>Ties toward an even rounding increment multiple</td>
            <td>*"roundTiesToEven"*</td>
          </tr>
        </tbody>
      </table>
      <emu-note>The above five rounding modes are defined in IEEE 754. This table is offered for implementors who may need to convert the Decimal128 rounding modes defined here into a library that may use the official IEEE 754 rounding mode names. Additional rounding modes are used elsewhere in this specification, such as in <emu-xref href="#table-intl-rounding-modes">Intl.NumberFormat</emu-xref>.</emu-note>
    </emu-table>
    <p>The <emu-eqn id="eqn-decimal128-cohort" aoid="cohort">cohort(_x_)</emu-eqn> of a Decimal128 value _x_ is defined as follows:</p>
    <ul>
      <li>cohort(*NaN*<sub>𝔻</sub>) = *NaN*<sub>𝔻</sub></li>
      <li>cohort(*+∞*<sub>𝔻</sub>) = *+∞*<sub>𝔻</sub></li>
      <li>cohort(*-∞*<sub>𝔻</sub>) = *-∞*<sub>𝔻</sub></li>
      <li>cohort(« _v_, _q_ »<sub>𝔻</sub>) = _v_</li>
    </ul>
    <p>For every finite Decimal128 value _x_ = « _v_, _q_ », the <emu-eqn id="eqn-decimal128-quantum" aoid="quantum">quantum(_x_) = _q_</emu-eqn>.</p>
    <p>For every finite non-zero Decimal128 value « _v_, _q_ »<sub>𝔻</sub> there exists a unique integer _e_ and mathematical value _s_ such that</p>
    <ol>
      <li>_v_ = _s_ × 10<sup>_e_</sup></li>
      <li>1 ≤ abs(_s_) < 10</li>
    </ol>
    <p>We call _e_ the <dfn id="dfn-decimal128-exponent">exponent</dfn> and _s_ the <dfn id="dfn-decimal128-significand">significand</dfn> of « _v_, _q_ »<sub>𝔻</sub>. The exponent and significand are undefined for NaN, non-finite, and zero Decimal128 values.</p>
    <emu-note>
      <p>The significand of a finite non-zero Decimal128 value is a rational number.</p>
    </emu-note>
    <emu-note>
      <p>The exponent _e_ of finite non-zero Decimal128 values is an integer satisfying 6144 ≥ _e_ ≥ -6176.</p>
    </emu-note>
    <p>A finite non-zero Decimal128 value is <dfn>normalized</dfn> if its exponent _e_ satisfies 6144 ≥ _e_ ≥ -6143. A finite non-zero Decimal128 value is <dfn>denormalized</dfn> if its exponent _e_ satisfies -6144 ≥ _e_ ≥ -6176.</p>
    <p>For a proper discussion of rounding, we need to separate how rounding occurs with normalized compared with denormlized values. For a normalized Decimal128 value we define its <dfn>truncated exponent</dfn> as equal to its exponent. For zero or denormalized Decimal128 values we define the truncated exponent as the constant -6143. Given this, we define the <dfn>scaled significand</dfn> of a finite Decimal128 value as follows:</p>
    <ul>
      <li>The scaled significand of a zero Decimal128 value is 0</li>
      <li>The scaled significand of a non-zero Decimal128 value _x = « _v_, _q_ »<sub>𝔻</sub> is v × 10<sup>33 - _te_</sup>, where _te_ is the truncated exponent of _x_.</li>
    </ul>
    <emu-note>
      <p>The scaled significand of a finite Decimal128 value is always an integer whose absolute value is less than 10<sup>34</sup>.</p>
    </emu-note>
  </emu-intro>
  <emu-clause id="sec-decimal-abstract-ops">
    <h1>Abstract Operations</h1>

    <emu-clause id="sec-decimal128-abs" type="abstract operation">
      <h1>
        Decimal128Abs (
          _argument_ : a Decimal128 value
        ): either *NaN*<sub>𝔻</sub> or a non-negative Decimal128 value
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It computes the absolute value of a Decimal128 value</dd>
      </dl>
      <emu-alg>
        1. If _argument_ is *NaN*<sub>𝔻</sub>, return *NaN*<sub>𝔻</sub>.
        1. If _argument_ is *+∞*<sub>𝔻</sub>, return *+∞*<sub>𝔻</sub>.
        1. If _argument_ is *-∞*<sub>𝔻</sub>, return *-∞*<sub>𝔻</sub>.
        1. Let _v_ be cohort(_argument_).
        1. Let _q_ be quantum(_argument_).
        1. If _v_ is *+0*<sub>𝔻</sub>, return « *+0*<sub>𝔻</sub>, _q_ »<sub>𝔻</sub>.
        1. If _v_ is *-0*<sub>𝔻</sub>, return « *+0*<sub>𝔻</sub>, _q_ »<sub>𝔻</sub>.
        1. Otherwise, return « abs(_v_), _q_ »<sub>𝔻</sub>.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-decimal128-negate" type="abstract operation">
      <h1>
        Decimal128Negate (
          _argument_ : a Decimal128 value
        ): a Decimal128 value
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It computes the negation of a Decimal128 value</dd>
      </dl>
      <emu-alg>
        1. If _argument_ is *NaN*<sub>𝔻</sub>, return *NaN*<sub>𝔻</sub>.
        1. If _argument_ is *+∞*<sub>𝔻</sub>, return *-∞*<sub>𝔻</sub>.
        1. If _argument_ is *-∞*<sub>𝔻</sub>, return *+∞*<sub>𝔻</sub>.
        1. Let _v_ be cohort(_argument_).
        1. Let _q_ be quantum(_argument_).
        1. If _v_ is *+0*<sub>𝔻</sub>, return « *-0*<sub>𝔻</sub>, _q_ »<sub>𝔻</sub>.
        1. If _v_ is *-0*<sub>𝔻</sub>, return « *+0*<sub>𝔻</sub>, _q_ »<sub>𝔻</sub>.
        1. Otherwise, return « -_v_, _q_ »<sub>𝔻</sub>.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-decimal128-nonnegativedecimal128todecimalstring" type="abstract operation">
      <h1>
        NonNegativeDecimal128ToDecimalString (
          _argument_ : a non-negative Decimal128 value,
          _shouldCanonicalize_ : a Boolean
        ): a String
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It renders _argument_ as a string, possibly in exponential notation if the decimal representation of the number would require too many digits.</dd>
      </dl>
      <emu-alg>
        1. If _argument_ is *+∞*<sub>𝔻</sub>, return *"Infinity"*.
        1. Let _v_ be cohort(_argument_).
        1. Let _q_ be quantum(_argument_).
        1. If _v_ is *+0*<sub>𝔻</sub>, let _integerPart_ be *"0"*.
        1. Otherwise, if _v_ is *-0*<sub>𝔻</sub>, let _integerPart_ be *"-0"*.
        1. Let _n_ be the integer for which _v_ × 10<sup>-_q_</sup> = _n_.
        1. Assert: 0 < abs(_n_) < 10<sup>34</sup>.
        1. Let _digits_ be the unique decimal string representation of _n_ without leading zeroes.
        1. If _q_ ≥ 0, then
          1. Let _trailingZeroes_ be the String *"0"* repeated abs(_n_) - _q_ times.
          1. Return the concatenation of _digits_ and _trailingZeroes_.
        1. Let _integerPart_ be the substring of _digits_ from 0 to abs(_n_) - _q_.
        1. If _shouldCanonicalize_ is *true* and _v_ is an integer, then
          1. Assert: _integerPart_ is not *""*.
          1. Return _integerPart_.
        1. If _integerPart_ is *""*, set _integerPart_ to *"0"*.
        1. Let _nonIntegerPart_ be the substring of _digits_ from abs(_n_) - _q_ to the length of _digits_.
        1. If _shouldCanonicalize_ is *true*, set _nonIntegerPart_ to a copy of _nonIntegerPart_ with trailing *"0"*s removed.
        1. Assert: _nonIntegerPart_ is not *""*.
        1. Return the concatenation of _integerPart_, *"."*, and _nonIntegerPart_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-decimal128-decimal128todecimalstring" type="abstract operation">
      <h1>
        Decimal128ToDecimalString (
          _argument_ : a Decimal128 value,
          _shouldCanonicalize_ : a Boolean
        ): a String
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It renders _argument_ as a string, possibly in exponential notation if the decimal representation of the number would require too many digits.</dd>
      </dl>
      <emu-alg>
        1. If _argument_ is *NaN*<sub>𝔻</sub>, return *"NaN"*.
        1. Let _abs_ be Decimal128Abs(_argument_).
        1. Let _renderedAbsoluateValue_ be NonNegativeDecimal128ToDecimalString(_abs_, _shouldCanonicalize_).
        1. If _argument_ is negative, return the concatenation of *"-"* and _renderedAbsoluateValue_.
        1. Otherwise, return _renderedAbsoluateValue_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-decimal128toexponentialstring" type="abstract operation">
      <h1>
        Decimal128ToExponentialString (
          _argument_ : a Decimal128 value,
          _shouldCanonicalize_ : a Boolean
        ): a String
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It renders _argument_ in exponential notation.</dd>
      </dl>
      <emu-alg>
        1. If _argument_ is *NaN*<sub>𝔻</sub>, return *"NaN"*.
        1. If _argument_ is *+∞*<sub>𝔻</sub>, return *"Infinity"*.
        1. If _argument_ is *-∞*<sub>𝔻</sub>, return *"-Infinity"*.
        1. Let _v_ be cohort(_argument_).
        1. Let _q_ be quantum(_argument_).
        1. If _v_ is *+0*<sub>𝔻</sub>, return *"0"*.
        1. If _v_ is *-0*<sub>𝔻</sub>, return *"-0"*.
        1. Let _coefficientStr_ be the unique decimal string representation of _v_ without leading zeroes.
        1. Let _exponentStr_ be the unique decimal string representation of _q_ without leading zeroes.
        1. Return the concatenation of _coefficientStr_, *"e"*, and _exponentStr_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-decimal128-isintegraldecimal128value" type="abstract operation">
      <h1>
        IsIntegralDecimal128 (
          _argument_: A Decimal128 object
        ): a Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It determines if _argument_ is a finite integral Decimal128 value.</dd>
      </dl>
      <emu-alg>
        1. Let _d_ be _argument_.[[Decimal128Data]].
        1. If _d_ is *NaN*<sub>𝔻</sub>, return *false*.
        1. If _d_ is *+∞*<sub>𝔻</sub> or *-∞*<sub>𝔻</sub>, return *false*.
        1. Let _v_ be cohort(_d_).
        1. If _v_ is *+0*<sub>𝔻</sub>, return *true*.
        1. If _v_ is *-0*<sub>𝔻</sub>, return *true*.
        1. If _v_ is an integer, return *true*.
        1. Otherwise, return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-decimal128-value-to-object" type="abstract operation">
      <h1>
        Decimal128ValueToObject (
          _argument_ : a Decimal128 value
        ): a Decimal128 object
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It converts a Decimal128 value to a Decimal128 object.</dd>
      </dl>
      <emu-alg>
        1. Let _O_ be ! OrdinaryCreateFromConstructor(%Decimal128%, *"%Decimal128.prototype%"*, « [[Decimal128Data]] »).
        1. Set _O_.[[Decimal128Data]] to _argument_.
        1. Return _O_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-decimal128-d" type="abstract operation">
      <h1>
        EnsureDecimal128Value (
          _coefficient_ : a mathematical value,
          _intendedExponent_ : a mathematical value,
          _roundingMode_: a Decimal128 rounding mode
        ): either a normal completion containing a Decimal128 value or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It attempts to convert the pair of arguments, which might be out of range when considered as a Decimal128 value, into a Decimal128 value, throwing an exception if the conversion cannot be done.</dd>
      </dl>
      <emu-alg>
        1. If -6111 ≤ _intendedExponent_ ≤ 6176, then
          1. If _coefficient_ is 0, return « *+0*<sub>𝔻</sub>, _intendedExponent_ »<sub>𝔻</sub>.
          1. If _coefficient_ × 10<sup>_intendedExponent_</sup> is an integer _n_ such that 0 < abs(_n_) < 10<sup>34</sup>, return « _coefficient_, _intendedExponent_ »<sub>𝔻</sub>.
          1. Throw a *RangeError* exception.
        1. If _intendedExponent_ < 0, return ? EnsureDecimal128Value(_coefficient_ / 10, _intendedExponent_ + 1, _roundingMode_).
        1. Otherwise, return ? EnsureDecimal128Value(_coefficient_ × 10, _intendedExponent_ + 1, _roundingMode_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-the-decimal-constructor">
    <h1>The Decimal128 Constructor</h1>
    <p>The Decimal128 constructor:</p>
    <ul>
      <li>is <dfn>%Decimal128%</dfn>.</li>
      <li>is the initial value of the the *"Decimal128"* property of the global object.</li>
      <li>creates and initializes a new Decimal128 object when called as a constructor</li>
      <li>may be used as the value of an *extends* clause of a class definition. Subclass constructors that intend to inherit the specified Decimal128 behaviour must include a *super* call to the Decimal128 constructor to create and initialize the subclass instance with a [[Decimal128Data]] internal slot.</li>
    </ul>
    <emu-clause id="sec-the-decimal128-constructor-value">
      <h1>Decimal128 ( _x_ )</h1>
      <emu-alg>
        1. If NewTarget is *undefined*, throw a *TypeError* exception.
        1. Let _toParse_ be *undefined*.
        1. If _x_ is a BigInt, set _toParse_ to BigInt::toString(_x_, 10).
        1. Otherwise, if _x_ is a Number, set _toParse_ to ! Call(%Number.prototype.toExponential%, _x_, « »).
        1. Otherwise, if _x_ is a String, set _toParse_ to _x_.
        1. If _toParse_ is not a String, throw a *TypeError* exception.
        1. Let _O_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%Decimal128.prototype%"*, « [[Decimal128Data]] »).
        1. If _toParse_ is *"NaN"*, then
          1. Set _O_.[[Decimal128Data]] to *NaN*<sub>𝔻</sub>.
        1. Else,
          1. Let _parseResult_ be ParseText(_toParse_, |StrDecimalLiteral|).
          1. If _parseResult_ is a List of errors, throw a *SyntaxError* exception.
          1. Let _decimalValue_ be ? StringDecimalValue of _parseResult_.
          1. Set _O_.[[Decimal128Data]] to _decimalValue_.
        1. Return _O_.
      </emu-alg>
      <emu-note>
        <p>Given a Number argument, the constructor converts it to a String using the <emu-xref href="#sec-number.prototype.tostring">toString</emu-xref> method (with no arguments). In some cases, this may not be desited. In some use cases, given a Number, one may wish to call the Decimal128 constructor not with the number but rather with, for instance, the result of calling <emu-xref href="#sec-number.prototype.tofixed">toFixed</emu-xref> or <emu-xref href="#sec-number.prototype.toprecision">toPrecision</emu-xref> on the Number, thereby ensuring a certain level of precision that may get lost when using Number’s toString.</p>
      </emu-note>
      <emu-clause id="sec-runtime-semantics-stringdecimalvalue" type="sdo">
        <h1>Runtime Semantics: StringDecimalValue ( ): either a normal completion containing a Decimal128 value or a throw completion</h1>
        <dl class="header">
        </dl>
        <emu-grammar>StrDecimalLiteral ::: `-` StrUnsignedDecimalLiteral</emu-grammar>
        <emu-alg>
          1. Let _a_ be ? StringDecimalValue of |StrUnsignedDecimalLiteral|.
          1. If _a_ is *+∞*<sub>𝔻</sub>, return *-∞*<sub>𝔻</sub>.
          1. Let _v_ be cohort(_a_).
          1. Let _q_ be quantum(_a_).
          1. If _v_ is *+0*<sub>𝔻</sub>, return « *-0*<sub>𝔻</sub>, _q_ ».
          1. Return « -_v_, _q_ ».
        </emu-alg>
        <emu-grammar>StrUnsignedDecimalLiteral ::: `Infinity`</emu-grammar>
        <emu-alg>
          1. Return *+∞*<sub>𝔻</sub>.
        </emu-alg>
        <emu-grammar>StrUnsignedDecimalLiteral ::: DecimalDigits `.` DecimalDigits? ExponentPart?</emu-grammar>
        <emu-alg>
          1. Let _a_ be MV of the first |DecimalDigits|.
          1. If the second |DecimalDigits| is present, then
            1. Let _b_ be MV of the second |DecimalDigits|.
            1. Let _n_ be the number of code points in the second |DecimalDigits|.
          1. Else,
            1. Let _b_ be 0.
            1. Let _n_ be 0.
          1. If |ExponentPart| is present, let _e_ be MV of |ExponentPart|. Otherwise, let _e_ be 0.
          1. Return ? EnsureDecimal128Value((_a_ + (_b_ × 10<sup>-_n_</sup>)) × 10<sup>_e_</sup>, _e_ - _n_, *"halfEven"*).
        </emu-alg>
        <emu-grammar>StrUnsignedDecimalLiteral ::: `.` DecimalDigits ExponentPart?</emu-grammar>
        <emu-alg>
          1. Let _b_ be MV of |DecimalDigits|.
          1. If |ExponentPart| is present, let _e_ be MV of |ExponentPart|. Otherwise, let _e_ be 0.
          1. Let _n_ be the number of code points in |DecimalDigits|.
          1. Return ? EnsureDecimal128Value(_b_ × 10<sup>_e_ - _n_</sup>, _e_ - _n_, *"halfEven"*).
        </emu-alg>
        <emu-grammar>StrUnsignedDecimalLiteral ::: DecimalDigits ExponentPart?</emu-grammar>
        <emu-alg>
          1. Let _a_ be MV of |DecimalDigits|.
          1. If |ExponentPart| is present, let _e_ be MV of |ExponentPart|. Otherwise, let _e_ be 0.
          1. Return ? EnsureDecimal128Value(_a_ × 10<sup>_e_</sup>, _e_, *"halfEven"*).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-decimal-prototype-properties">
  <h1>Properties of the Decimal128 Prototype</h1>

  <emu-clause id="sec-decimal.prototype.isnan">
    <h1>Decimal128.prototype.isNaN ( )</h1>
    <p>This method returns a Boolean value indicating whether a Decimal128 object represents *NaN*<sub>𝔻</sub>.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Let _d_ be _O_.[[Decimal128Data]].
      1. If _d_ is *NaN*<sub>𝔻</sub>, return *true*.
      1. Otherwise, return *false*.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-decimal.prototype.isfinite">
    <h1>Decimal128.prototype.isFinite ( )</h1>
    <p>This method returns a Boolean value indicating whether a Decimal128 object represents *+∞*<sub>𝔻</sub> or *-∞*<sub>𝔻</sub>.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Let _d_ be _O_.[[Decimal128Data]].
      1. If _d_ is *+∞*<sub>𝔻</sub> or *-∞*<sub>𝔻</sub>, return *true*.
      1. Otherwise, return *false*.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-decimal.prototype.exponent">
    <h1>Decimal128.prototype.exponent ( )</h1>
    <p>This method returns a Number value represents the <emu-xref href="#dfn-decimal128-exponent">exponent</emu-xref>, which is the integer _n_ for which the current Decimal128 object, _x_ = « _v_, _q_ »<sub>𝔻</sub>, there exists a mathematical value _s_ such that _v_ = _s_ × 10<sup>_e_</sup> and 1 ≤ abs(_s_) < 10. This method requires that the Decimal128 value held by the curernt Decimal128 object is finite and non-zero.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Let _d_ be _O_.[[Decimal128Data]].
      1. If _d_ is *NaN*<sub>𝔻</sub>, throw a *RangeError* exception.
      1. If _d_ is *+∞*<sub>𝔻</sub>, throw a *RangeError* exception.
      1. If _d_ is *-∞*<sub>𝔻</sub>, throw a *RangeError* exception.
      1. Let _v_ be cohort(_d_).
      1. If _v_ is *+0*<sub>𝔻</sub>, throw a *RangeError* exception.
      1. If _v_ is *-0*<sub>𝔻</sub>, throw a *RangeError* exception.
      1. Let _e_ be the unique integer for which there exists a mathematical value _s_ such that _v_ = _s_ × 10<sup>_e_</sup> and 1 ≤ abs(_s_) < 10.
      1. Return 𝔽(_e_).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-decimal.prototype.mantissa">
    <h1>Decimal128.prototype.mantissa ( )</h1>
    <p>This method returns a Decimal128 value representing the <emu-xref href="#dfn-decimal128-significand">significand</emu-xref> of the current Decimal128 object, which is the mathematical value _n_ for which the current Decimal128 object, _x_ = « _v_, _q_ »<sub>𝔻</sub>, there exists an integer _e_ such such that _v_ = _s_ × 10<sup>_e_</sup> and 1 ≤ abs(_s_) < 10. This method requires that the Decimal128 value held by the curernt Decimal128 object is finite and non-zero.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Let _d_ be _O_.[[Decimal128Data]].
      1. If _d_ is *NaN*<sub>𝔻</sub>, throw a *RangeError* exception.
      1. If _d_ is *+∞*<sub>𝔻</sub>, throw a *RangeError* exception.
      1. If _d_ is *-∞*<sub>𝔻</sub>, throw a *RangeError* exception.
      1. Let _v_ be cohort(_d_).
      1. If _v_ is *+0*<sub>𝔻</sub>, throw a *RangeError* exception.
      1. If _v_ is *-0*<sub>𝔻</sub>, throw a *RangeError* exception.
      1. Let _s_ be the unique rational number for which there exists an integer _n_ such that _v_ = _s_ × 10<sup>_e_</sup> and 1 ≤ abs(_s_) < 10.
      1. Return Decimal128ValueToObject(! EnsureDecimal128Value(_s_, -_e_, *"halfEven"*)).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-decimal.prototype.abs">
    <h1>Decimal128.prototype.abs ( )</h1>
    <p>This method computes the absolute value of a Decimal128 object.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Let _d_ be _O_.[[Decimal128Data]].
      1. Return Decimal128ValueToObject(Decimal128Abs(_d_)).
    </emu-alg>
    <emu-note>
      <p>This operation follows the specification in Section 5.5.1 of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal.prototype.negate">
    <h1>Decimal128.prototype.negate ( )</h1>
    <p>This method inverts the sign of a Decimal128 object.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Let _d_ be _O_.[[Decimal128Data]].
      1. Return Decimal128ValueToObject(Decimal128Negate(_d_)).
    </emu-alg>
    <emu-note>
      <p>This operation follows the specification in Section 5.5.1 of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal.prototype.add">
    <h1>Decimal128.prototype.add ( _x_ )</h1>
    <p>This method computes the addition of a Decimal128 object with another one. The computation proceeds as though infinite precision and unbounded range were available, rounding, if necessary, according to the *"halfEven"* rounding mode.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Perform ? RequireInternalSlot(_x_, [[Decimal128Data]]).
      1. Let _d1_ be _O_.[[Decimal128Data]].
      1. Let _d2_ be _x_.[[Decimal128Data]].
      1. If _d1_ or _d2_ is *NaN*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
      1. If _d1_ is *+∞*<sub>𝔻</sub>, then
        1. If _d2_ is *+∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*+∞*<sub>𝔻</sub>).
        1. If _d2_ is *-∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
        1. Return Decimal128ValueToObject(*+∞*<sub>𝔻</sub>).
      1. If _d1_ is *-∞*<sub>𝔻</sub>, then
        1. If _d2_ is *+∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
        1. If _d2_ is *-∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*-∞*<sub>𝔻</sub>).
        1. Return Decimal128ValueToObject(*-∞*<sub>𝔻</sub>).
      1. Let _v1_ be cohort(_d1_).
      1. Let _v2_ be cohort(_d2_).
      1. Let _q1_ be quantum(_d1_).
      1. Let _q2_ be quantum(_d2_).
      1. Let _newQ_ be min(_q1_, _q2_).
      1. If _v1_ is *+0*<sub>𝔻</sub>, then
        1. If _v2_ *+0*<sub>𝔻</sub>, return Decimal128ValueToObject(« *+0*<sub>𝔻</sub>, _newQ_ »).
        1. If _v2_ *-0*<sub>𝔻</sub>, return Decimal128ValueToObject(« *+0*<sub>𝔻</sub>, _newQ_ »).
        1. Otherwise, return Decimal128ValueToObject(« _v2_, _newQ_ »).
      1. If _v1_ is *-0*<sub>𝔻</sub>, then
        1. If _v2_ *+0*<sub>𝔻</sub>, return Decimal128ValueToObject(« *+0*<sub>𝔻</sub>, _newQ_ »).
        1. If _v2_ *-0*<sub>𝔻</sub>, return Decimal128ValueToObject(« *-0*<sub>𝔻</sub>, _newQ_ »).
        1. Otherwise, return Decimal128ValueToObject(« _v2_, _newQ_ »).
      1. If _v2_ is *+0*<sub>𝔻</sub>, then
        1. If _v1_ *+0*<sub>𝔻</sub>, return Decimal128ValueToObject(« *+0*<sub>𝔻</sub>, _newQ_ »).
        1. If _v1_ *-0*<sub>𝔻</sub>, return Decimal128ValueToObject(« *+0*<sub>𝔻</sub>, _newQ_ »).
        1. Otherwise, return Decimal128ValueToObject(« _v1_, _newQ_ »).
      1. If _v2_ is *-0*<sub>𝔻</sub>, then
        1. If _v1_ *+0*<sub>𝔻</sub>, return Decimal128ValueToObject(« *+0*<sub>𝔻</sub>, _newQ_ »).
        1. If _v1_ *-0*<sub>𝔻</sub>, return Decimal128ValueToObject(« *-0*<sub>𝔻</sub>, _newQ_ »).
        1. Otherwise, return Decimal128ValueToObject(« _v1_, _newQ_ »).
      1. If _v1_ + _v2_ = 0, return Decimal128ValueToObject(« *+0*<sub>𝔻</sub>, _newQ_ »).
      1. Otherwise, return Decimal128ValueToObject(? EnsureDecimal128Value(_v1_ + _v2_, _newQ_, *"halfEven"*)).
    </emu-alg>
    <emu-note>
      <p>This operation follows the specification in Section 5.4.1 of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal.prototype.subtract">
    <h1>Decimal128.prototype.subtract ( _x_ )</h1>
    <p>This method computes subtracts the given Decimal128 object from the current one. The computation proceeds as though infinite precision and unbounded range were available, rounding, if necessary, according to the *"halfEven"* rounding mode.</p>
    <p>It performs the following steps when called:</p>
      <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Perform ? RequireInternalSlot(_x_, [[Decimal128Data]]).
      1. Let _d1_ be _O_.[[Decimal128Data]].
      1. Let _d2_ be _x_.[[Decimal128Data]].
      1. If _d1_ or _d2_ is *NaN*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
      1. If _d1_ is *+∞*<sub>𝔻</sub>, then
        1. If _d2_ is *+∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*+∞*<sub>𝔻</sub>).
        1. If _d2_ is *-∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
        1. Return Decimal128ValueToObject(*+∞*<sub>𝔻</sub>).
      1. If _d1_ is *-∞*<sub>𝔻</sub>, then
        1. If _d2_ is *+∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*-∞*<sub>𝔻</sub>).
        1. If _d2_ is *-∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
        1. Return Decimal128ValueToObject(*-∞*<sub>𝔻</sub>).
      1. Let _v1_ be cohort(_d1_).
      1. Let _v2_ be cohort(_d2_).
      1. Let _q1_ be quantum(_d1_).
      1. Let _q2_ be quantum(_d2_).
      1. Let _newQ_ be min(_q1_, _q2_).
      1. If _v1_ is *+0*<sub>𝔻</sub>, then
        1. If _v2_ *+0*<sub>𝔻</sub>, return Decimal128ValueToObject(« *+0*<sub>𝔻</sub>, _newQ_ »).
        1. If _v2_ *-0*<sub>𝔻</sub>, return Decimal128ValueToObject(« *+0*<sub>𝔻</sub>, _newQ_ »).
        1. Otherwise, return Decimal128ValueToObject(« _v2_, _newQ_ »).
      1. If _v1_ is *-0*<sub>𝔻</sub>, then
        1. If _v2_ *+0*<sub>𝔻</sub>, return Decimal128ValueToObject(« *-0*<sub>𝔻</sub>, _newQ_ »).
        1. If _v2_ *-0*<sub>𝔻</sub>, return Decimal128ValueToObject(« *+0*<sub>𝔻</sub>, _newQ_ »).
        1. Otherwise, return Decimal128ValueToObject(« _v2_, _newQ_ »).
      1. If _v2_ is *+0*<sub>𝔻</sub>, return Decimal128ValueToObject(« _v1_, _newQ_ »).
      1. If _v2_ is *-0*<sub>𝔻</sub>, return Decimal128ValueToObject(« _v1_, _newQ_ »).
      1. If _v1_ + _v2_ = 0, return Decimal128ValueToObject(« *+0*<sub>𝔻</sub>, _newQ_ »).
      1. Otherwise, return Decimal128ValueToObject(? EnsureDecimal128Value(_v1_ - _v2_, _newQ_, *"halfEven"*)).
    </emu-alg>
    <emu-note>
      <p>This operation follows the specification in Section 5.4.1 of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal.prototype.multiply">
    <h1>Decimal128.prototype.multiply ( _x_ )</h1>
    <p>This method computes multiplies the current Decimal128 object by another one. The computation proceeds as though infinite precision and unbounded range were available, rounding, if necessary, according to the *"halfEven"* rounding mode.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Perform ? RequireInternalSlot(_x_, [[Decimal128Data]]).
      1. Let _d1_ be _O_.[[Decimal128Data]].
      1. Let _d2_ be _x_.[[Decimal128Data]].
      1. If _d1_ or _d2_ is *NaN*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
      1. If _d1_ is *+∞*<sub>𝔻</sub>, then
        1. If _d2_ is *+∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*+∞*<sub>𝔻</sub>).
        1. If _d2_ is *-∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
        1. If _d2_ is a zero Decimal128 value, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
        1. Return Decimal128ValueToObject(*+∞*<sub>𝔻</sub>).
      1. If _d1_ is *-∞*<sub>𝔻</sub>, then
        1. If _d2_ is *+∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*-∞*<sub>𝔻</sub>).
        1. If _d2_ is *-∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*+∞*<sub>𝔻</sub>).
        1. If _d2_ is a zero Decimal128 value, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
        1. Let _v2_ be cohort(_d2_).
        1. If _v2_ < 0, return Decimal128ValueToObject(*+∞*<sub>𝔻</sub>).
        1. Return Decimal128ValueToObject(*-∞*<sub>𝔻</sub>).
      1. Let _v1_ be cohort(_d1_).
      1. Let _q1_ be quantum(_d1_).
      1. Let _q2_ be quantum(_d2_).
      1. Let _newQ_ be _q1_ + _q2_.
      1. If _v1_ is *+0*<sub>𝔻</sub>, then
        1. If the mathematical value of _d2_ is negative, return Decimal128ValueToObject(« *-0*<sub>𝔻</sub>, _newQ_ »).
        1. Otherwise, return Decimal128ValueToObject(« *+0*<sub>𝔻</sub>, _newQ_ »).
      1. If _v1_ is *-0*<sub>𝔻</sub>, then
        1. If the mathematical value of _d2_ is negative, return Decimal128ValueToObject(« *+0*<sub>𝔻</sub>, _newQ_ »).
        1. Otherwise, return Decimal128ValueToObject(« *-0*<sub>𝔻</sub>, _newQ_ »).
      1. If _v2_ is *+0*<sub>𝔻</sub>, then
        1. If the mathematical value of _d1_ is negative, return Decimal128ValueToObject(« *-0*<sub>𝔻</sub>, _newQ_ »).
        1. Otherwise, return Decimal128ValueToObject(« *+0*<sub>𝔻</sub>, _newQ_ »).
      1. If _v2_ is *-0*<sub>𝔻</sub>, then
        1. If the mathematical value of _d1_ is negative, return Decimal128ValueToObject(« *+0*<sub>𝔻</sub>, _newQ_ »).
        1. Otherwise, return Decimal128ValueToObject(« *-0*<sub>𝔻</sub>, _newQ_ »).
      1. Assert: _v1_ × _v2 ≠ 0.
      1. Return Decimal128ValueToObject(? EnsureDecimal128Value (_v1_ × _v2, _newQ_, *"halfEven"*)).
    </emu-alg>
    <emu-note>
      <p>This operation follows the specification in Section 5.4.1 of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal.prototype.divide">
    <h1>Decimal128.prototype.divide ( _x_ )</h1>
    <p>This method computes divides the current Decimal128 object by another one. The computation proceeds as though infinite precision and unbounded range were available, rounding, if necessary, according to the *"halfEven"* rounding mode.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Perform ? RequireInternalSlot(_x_, [[Decimal128Data]]).
      1. Let _d1_ be _O_.[[Decimal128Data]].
      1. Let _d2_ be _x_.[[Decimal128Data]].
      1. If _d1_ or _d2_ is *NaN*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
      1. If _d1_ is *+∞*<sub>𝔻</sub> or *-∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
      1. If _d2_ is *-∞*<sub>𝔻</sub> or *-∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
      1. Let _v1_ be cohort(_d1_).
      1. Let _v2_ be cohort(_d2_).
      1. Let _q1_ be quantum(_d1_).
      1. Let _q2_ be quantum(_d2_).
      1. Let _newQ_ be _q1_ + _q2_.
      1. If _v1_ is *+0*<sub>𝔻</sub>, then
        1. If the mathematical value of _d2_ is negative, return Decimal128ValueToObject(« *-0*<sub>𝔻</sub>, _newQ_ »).
        1. Otherwise, return Decimal128ValueToObject(« *+0*<sub>𝔻</sub>, _newQ_ »).
      1. If _v1_ is *-0*<sub>𝔻</sub>, then
        1. If the mathematical value of _d2_ is negative, return Decimal128ValueToObject(« *+0*<sub>𝔻</sub>, _newQ_ »).
        1. Otherwise, return Decimal128ValueToObject(« *-0*<sub>𝔻</sub>, _newQ_ »).
      1. If _v2_ is *+0*<sub>𝔻</sub>, throw a *RangeError* exception.
      1. If _v2_ is *-0*<sub>𝔻</sub>, throw a *RangeError* exception.
      1. Return Decimal128ValueToObject(? EnsureDecimal128Value(_v1_ / _v2_, _newQ_, *"halfEven"*)).
    </emu-alg>
    <emu-note>
      <p>This operation follows the specification in Section 5.4.1 of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal.prototype.remainder">
    <h1>Decimal128.prototype.remainder ( _x_ )</h1>
    <p>This method computes the remainder upon dividing the current Decimal128 object by another one. The computation proceeds as though infinite precision and unbounded range were available, rounding, if necessary, according to the *"halfEven"* rounding mode.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Perform ? RequireInternalSlot(_x_, [[Decimal128Data]]).
      1. Let _d1_ be _O_.[[Decimal128Data]].
      1. Let _d2_ be _x_.[[Decimal128Data]].
      1. If _d1_ or _d2_ is *NaN*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
      1. If _d1_ is *+∞*<sub>𝔻</sub> or *-∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
      1. If _d1_ is *-∞*<sub>𝔻</sub> or *-∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
      1. Let _v1_ be cohort(_d1_).
      1. Let _v2_ be cohort(_d2_).
      1. Let _q1_ be quantum(_d1_).
      1. Let _q2_ be quantum(_d2_).
      1. Let _newQ_ be _q1_ + _q2_.
      1. If _v2_ is *+0*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
      1. If _v2_ is *-0*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
      1. If _v1_ is *+0*<sub>𝔻</sub>, return Decimal128ValueToObject(« *+0*<sub>𝔻</sub>, _newQ_ »).
      1. If _v1_ is *-0*<sub>𝔻</sub>, return Decimal128ValueToObject(« *-0*<sub>𝔻</sub>, _newQ_ »).
      1. Return Decimal128ValueToObject(? EnsureDecimal128Value(_v1_ % _v2_, _newQ_, *"halfEven"*)).
    </emu-alg>
    <emu-note>
      <p>The remainder operation specified here deviates from the <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref> remainder operation (defined there in Section 5.3.1). We follow the <emu-xref href="#sec-numeric-types-number-remainder">the remainder operation for Number</emu-xref> rather than IEEE 754, which specifies that, for example, the remainder 46 and 10 is -4 rather than 6.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal.prototype.compare">
    <h1>Decimal128.prototype.compare ( _x_ )</h1>
    <p>This method returns one of the four Number values *-1*<sub>𝔽</sub>, *+0*<sub>𝔽</sub>, *1*<sub>𝔽</sub>, and *NaN*<sub>𝔽</sub>. It compares the mathematical value of the current Decimal128 object with that of another Decimal128 object.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Perform ? RequireInternalSlot(_x_, [[Decimal128Data]]).
      1. Let _d1_ be _O_.[[Decimal128Data]].
      1. Let _d2_ be _x_.[[Decimal128Data]].
      1. If _d1_ is *NaN*<sub>𝔻</sub>, return *NaN*<sub>𝔽</sub>.
      1. If _d1_ is *+∞*<sub>𝔻</sub>, then
        1. If _d2_ is *+∞*<sub>𝔻</sub>, return *+0*<sub>𝔽</sub>.
        1. Return *1*<sub>𝔽</sub>.
      1. If _d1_ is *-∞*<sub>𝔻</sub>, then
        1. If _d2_ is *-∞*<sub>𝔻</sub>, return *+0*<sub>𝔽</sub>.
        1. Return *-1*<sub>𝔽</sub>.
      1. If _d2_ is *+∞*<sub>𝔻</sub>, return *-1*<sub>𝔽</sub>.
      1. If _d2_ is *-∞*<sub>𝔻</sub>, return *1*<sub>𝔽</sub>.
      1. If <emu-xref href="#dfn-decimal128-mathematical-value">the mathematical value of</emu-xref> of _d1_ is less than <emu-xref href="#dfn-decimal128-mathematical-value">the mathematical value of</emu-xref> _d2_, return *-1*<sub>𝔽</sub>.
      1. If <emu-xref href="#dfn-decimal128-mathematical-value">the mathematical value of of</emu-xref> _d2_ is less than <emu-xref href="#dfn-decimal128-mathematical-value">the mathematical value of</emu-xref> _d1_, return *1*<sub>𝔽</sub>.
      1. Otherwise, return *+0*<sub>𝔻</sub>.
    </emu-alg>
    <emu-note>
      <p>This operation combines the <code>compareQuietEqual</code>, <code>compareQuietLess</code> operations in Section 5.6.1 (and explained in Section 5.11) of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal-method-round">
    <h1>Decimal128.prototype.round ( _numFractionalDigits_ [ , _roundingMode_ ] )</h1>
    <p>This method rounds the current Decimal128 object according to the specified rounding mode, which, if omitted, is <emu-xref href="#dfn-decimal128-default-rounding-mode">the default rounding mode</emu-xref>, with rounding taking place only after _numFractionalDigits_ non-integer digits, which must be a non-negative integer Number.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. If _numFractionalDigits_ is not a Number, throw a *TypeError* exception.
      1. If _numFractionalDigits_ < 0, throw a *RangeError* exception.
      1. If _numFractionalDigits_ is not an integer, throw a *RangeError* exception.
      1. If _roundingMode_ is neither *undefined* nor a String, throw a *TypeError* exception.
      1. If _roundingMode_ is undefined, set _roundingMode_ to <emu-xref href="#dfn-decimal128-default-rounding-mode">the default rounding mode</emu-xref>.
      1. If _roundingMode_ is not a rounding mode, throw a *RangeError* exception.
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Let _d_ be _O_.[[Decimal128Data]].
      1. If _d_ is *NaN*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
      1. If _d_ is *+∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*+∞*<sub>𝔻</sub>).
      1. If _d_ is *-∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*+∞*<sub>𝔻</sub>).
      1. Let _v_ be cohort(_d_).
      1. Let _q_ be quantum(_d_).
      1. If _v_ is *+0*<sub>𝔻</sub>, return Decimal128ValueToObject(« *+0*<sub>𝔻</sub>, _numFractionalDigits_ »).
      1. If _v_ is *-0*<sub>𝔻</sub>, return Decimal128ValueToObject(« *-0*<sub>𝔻</sub>, _numFractionalDigits_ »).
      1. Let _n_ be the integer such that v × 10<sup>-_q_</sup> = _n_ and 0 < abs(_n_) < 10<sup>34</sup>.
      1. Let _newD_ be ? EnsureDecimal128Value(v × 10<sup>_numFractionalDigits_</sup>, _q_ + _numFractionalDigits_, _roundingMode_).
      1. Return Decimal128ValueToObject(_newD_).
    </emu-alg>
    <emu-note>
      <p>This operation follows the specification of the rounding mode attributes discussed in Section 4.3 of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal-method-scale10">
    <h1>Decimal128.prototype.scale10 ( _n_ )</h1>
    <p>This method multiplies the current Decimal128 object by 10 raised to the given power.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. If _n_ is not a Number, throw a *TypeError* exception.
      1. If _n_ is *NaN*<sub>𝔽</sub>, throw a *RangeError* exception.
      1. If _n_ is *+∞*<sub>𝔽</sub>, throw a *RangeError* exception.
      1. If _n_ is *-∞*<sub>𝔽</sub>, throw a *RangeError* exception.
      1. Let _d_ be _O_.[[Decimal128Data]].
      1. If _d_ is *NaN*<sub>𝔻</sub>, return Decimal128ValueToObject(*NaN*<sub>𝔻</sub>).
      1. If _d_ is *+∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*+∞*<sub>𝔻</sub>).
      1. If _d_ is *-∞*<sub>𝔻</sub>, return Decimal128ValueToObject(*+∞*<sub>𝔻</sub>).
      1. Let _v_ be cohort(_d_).
      1. Let _q_ be quantum(_d_).
      1. If _v_ is neither *+0*<sub>𝔻</sub> nor *-0*<sub>𝔻</sub>, set _v_ to _v_ × 10<sup>ℝ(_n_)</sup>.
      1. Return Decimal128ValueToObject(? EnsureDecimal128Value(_v_, _q_ + ℝ(_n_), *"halfEven"*)).
    </emu-alg>
    <emu-note>
      <p>This operation follows the specification of the rounding mode attributes discussed in Section 4.3 of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal.prototype.tostring">
    <h1>Decimal128.prototype.toString ( [ _options_ ] )</h1>
    <p>This method generates a String representation of the current Decimal128 object, in decimal format. Its behaviour is similar to that of Number’s <emu-xref href="#sec-number.prototype.tostring">toString</emu-xref> by rendering the decimal in decimal notation, provided the length of that string is less than 20. Otherwise, the decimal will be rendered in exponential notation.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Let _shouldCanonicalize_ be *true*.
      1. If _options_ is not *undefined*, then
        1. If _options_ is not an Object, throw a *TypeError* exception.
        1. Set _shouldCanonicalize_ to ? Get(_options_, *"canonicalize"*).
        1. If _shouldCanonicalize_ is not a Boolean value, throw a *TypeError* exception.
      1. Let _inDecimalNotation_ be Decimal128ToDecimalString(_O_, _shouldCanonicalize_).
      1. If the length of _inDecimalNotation_ is less than 22, return _inDecimalNotation_.
      1. Otherwise, return Decimal128ToExponentialString(_O_, _shouldCanonicalize_).
    </emu-alg>
    <emu-note>
      <p>This operation follows the specification of the conversion of IEEE 754 Decimal128 values to strings (external character sequences) discussed in Section 5.12 of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal.prototype.toexponential">
    <h1>Decimal128.prototype.toExponential ( [ _options_ ] )</h1>
    <p>This method generates a String representation of the current Decimal128 object, in exponential format (e.g., *"123e-4"*).</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Let _shouldCanonicalize_ be *true*.
      1. If _options_ is not *undefined*, then
        1. If _options_ is not an Object, throw a *TypeError* exception.
        1. Set _shouldCanonicalize_ to ? Get(_options_, *"canonicalize"*).
        1. If _shouldCanonicalize_ is not a Boolean value, throw a *TypeError* exception.
      1. Return Decimal128ToExponentialString(_O_, _shouldCanonicalize_).
    </emu-alg>
    <emu-note>
      <p>This operation follows the specification of the conversion of IEEE 754 Decimal128 values to strings (external character sequences) discussed in Section 5.12 of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal.prototype.tofixed">
    <h1>Decimal128.prototype.toFixed ( [ _options_ ] )</h1>
    <p>This method generates a String representation of the current Decimal128 object, in decimal format, with a specified number of digits after the decimal point.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Let _shouldCanonicalize_ be *true*.
      1. Let _numDigits_ be *+0*<sub>𝔽</sub>.
      1. If _options_ is not *undefined*, then
        1. If _options_ is not an Object, throw a *TypeError* exception.
        1. Set _shouldCanonicalize_ to ? Get(_options_, *"canonicalize"*).
        1. Set _numDigits_ to ? Get(_options_, *"digits"*).
        1. If _numDigits_ is not a Number, throw a *TypeError* exception.
        1. If _shouldCanonicalize_ is not a Boolean value, throw a *TypeError* exception.
      1. If _numDigits_ < 0, throw a *RangeError* exception.
      1. If _numDigits_ is not an integer, throw a *RangeError* exception.
      1. If _shouldCanonicalize_ is not a Boolean value, throw a *TypeError* exception.
      1. Let _s_ be Decimal128ToDecimalString(_O_, _shouldCanonicalize_).
      1. If _s_ is *"NaN"*, *"Infinity"*, or *"-Infinity"*, return _s_.
      1. Let _integerDigits_ be *""*.
      1. Let _nonIntegerDigits_ be *""*.
      1. If _s_ contains a *"."*, then
        1. Set _integerDigits_ to the substring of _s_ up to the first occurrence of *"."* in _s_.
        1. Set _nonIntegerDigits_ to the substring of _s_ after the first occurrence of *"."* in _s_.
        1. If _numDigits_ > 0, set _nonIntegerDigits_ to the substring of _nonIntegerDigits_ from 0 to _numDigits_.
      1. Else,
        1. Set _integerDigits_ to _s_.
      1. If _numDigits_ is 0, return _integerDigits_.
      1. Return the concatenation of _integerDigits_, *"."*, and _nonIntegerDigits_.
    </emu-alg>
    <emu-note>
      <p>This operation follows the specification of the conversion of IEEE 754 Decimal128 values to strings (external character sequences) discussed in Section 5.12 of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal.prototype.toprecision">
    <h1>Decimal128.prototype.toPrecision ( [ _options_ ] )</h1>
    <p>This method generates a String representation of the current Decimal128 object, in decimal format, with a specified number of significant digits. If the _precision_ argument is omitted or is *undefined*, this method is equivalent to <emu-xref href="#sec-decimal.prototype.tostring">toString</emu-xref>. This method may produce results in exponential notation or decimal notation.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Let _shouldCanonicalize_ be *true*.
      1. If _shouldCanonicalize_ is neither *undefined* nor a Boolean value, throw a *TypeError* exception.
      1. If _precision_ is neither *undefined* nor a Number, throw a *TypeError* exception.
      1. If _precision_ is *undefined*, return return Decimal128ToDecimalString(_O_, _shouldCanonicalize_).
      1. If _precision_ is not an integer, throw a *RangeError* exception.
      1. If _precision_ < 1, throw a *RangeError* exception.
      1. Let _d_ be _O_.[[Decimal128Data]].
      1. If _d_ is *NaN*<sub>𝔻</sub>, return *"NaN"*.
      1. If _d_ is *+∞*<sub>𝔻</sub>, return *"Infinity"*.
      1. If _d_ is *-∞*<sub>𝔻</sub>, return *"-Infinity"*.
      1. Let _v_ be cohort(_d_).
      1. Let _q_ be quantum(_d_).
      1. If _v_ is *+0*<sub>𝔻</sub>, return *"0"*.
      1. If _v_ is *-0*<sub>𝔻</sub>, return *"-0"*.
      1. If -_q_ < _precision_, then
        1. Let _s_ be Decimal128ToDecimalString(_O_, _shouldCanonicalize_).
        1. Let _integerDigits_ be the substring of _s_ up to the first occurrence of *"."* in _s_.
        1. Let _nonIntegerDigits_ be the substring of _s_ after the first occurrence of *"."* in _s_.
        1. Let _numTrailingZeroesToAdd_ be _precision_ minus the length of _nonIntegerDigits_.
        1. Let _trailingZeroes_ be the string *"0"* repeated _numTrailingZeroesToAdd_ times.
        1. Return the concatenation of _integerDigits_, *"."*, _nonIntegerDigits_, and _trailingZeroes_.
      1. Let _n_ be the integer such that v × 10<sup>-_q_</sup> = _n_ and 0 < abs(_n_) < 10<sup>34</sup>.
      1. Let _n1_ be the largest multiple of 10 such that _n_ - _n1_ is less than 10<sup>_precision_</sup>.
      1. Let _v1_ be _v_ - (_n1_ / 10<sup>_precision_</sup>).
      1. Let _N_ be ? EnsureDecimal128Value(_v1_, _precision_, *"halfEven"*).
      1. Return Decimal128ToDecimalString(_N_, _shouldCanonicalize_).
    </emu-alg>
    <emu-note>
      <p>This operation follows the specification of the conversion of IEEE 754 Decimal128 values to strings (external character sequences) discussed in Section 5.12 of <emu-xref href="#sec-bibliography">IEEE 754-2019</emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-decimal.prototype.valueof">
    <h1>Decimal128.prototype.valueOf ( _x_ )</h1>
    <p>This method performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Decimal128Data]]).
      1. Throw a *TypeError* exception.
    </emu-alg>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-numbers-and-dates">
  <h1>Numbers and Dates</h1>
  <emu-clause id="sec-number-objects">
    <h1>Number Objects</h1>

    <emu-clause id="sec-number-constructor">
      <h1>The Number Constructor</h1>
      <emu-clause id="sec-number-constructor-number-value">
        <h1>Number ( _value_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If _value_ is present, then
            1. <ins>If _value_ is an object that has an [[Decimal128Data]] internal slot, then</ins>
              1. <ins>Let _d_ be _value_.[[Decimal128Data]].</ins>
              1. <ins>Let _serialized_ be Decimal128ToExponentialString(_d_, *false*).</ins>
              1. <ins>Return ! ToNumber(_serialized_).</ins>
            1. Let _prim_ be ? ToNumeric(_value_).
            1. If _prim_ is a BigInt, let _n_ be 𝔽(ℝ(_prim_)).
            1. Otherwise, let _n_ be _prim_.
          1. Else,
            1. Let _n_ be *+0*<sub>𝔽</sub>.
          1. If NewTarget is *undefined*, return _n_.
          1. Let _O_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%Number.prototype%"*, « [[NumberData]] »).
          1. Set _O_.[[NumberData]] to _n_.
          1. Return _O_.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-bigint-objects">
    <h1>BigInt Objects</h1>
    <emu-clause id="sec-bigint-constructor">
      <h1>The BigInt Constructor</h1>
      <emu-clause id="sec-bigint-constructor-number-value">
        <h1>BigInt ( _value_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If NewTarget is not *undefined*, throw a *TypeError* exception.
          1. <ins>If _value_ is a Decimal128 object, return ? Decimal128ToBigInt(_value_).</ins>
          1. Let _prim_ be ? ToPrimitive(_value_, ~number~).
          1. If _prim_ is a Number, return ? NumberToBigInt(_prim_).
          1. Otherwise, return ? <emu-meta suppress-effects="user-code">ToBigInt(_prim_)</emu-meta>.
        </emu-alg>

         <emu-clause id="sec-numbertobigint" type="abstract operation">
          <h1>
            <ins>Decimal128ToBigInt (
            _number_: a Decimal128 object,
            ): either a normal completion containing a BigInt or a throw completion</ins>
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. If IsIntegralDecimal128(_number_) is *false*, throw a *RangeError* exception.
            1. Return ℤ(ℝ(_number_)).
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-import href="./intl.emu"></emu-import>
