<!doctype html>
<meta charset="utf8">
<link rel="stylesheet" href="./spec.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">
<script src="./spec.js"></script>
<pre class="metadata">
title: Decimal
status: proposal
stage: 1
contributors: Jesse Alama
location: https://github.com/tc39/proposal-decimal/
</pre>

<emu-clause id="sec-scope">
  <h1>Scope</h1>
  <p>
    This is the spec text of the <a href="https://github.com/tc39/proposal-decimal/" title="Decimal proposal (GitHub)">Decimal proposal</a> in ECMAScript.
  </p>
</emu-clause>

<emu-clause id="sec-abstract-operations">
  <h1>Abstract Operations</h1>
  <emu-clause id="sec-type-conversion">
    <h1>Type Conversion</h1>
    <emu-clause id="sec-tostring" type="abstract operation">
      <h1>
        ToString (
          _argument_: an ECMAScript language value,
        ): either a normal completion containing a String or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It converts _argument_ to a value of type String.</dd>
      </dl>
      <emu-alg>
        1. If _argument_ is a String, return _argument_.
        1. If _argument_ is a Symbol, throw a *TypeError* exception.
        1. If _argument_ is *undefined*, return *"undefined"*.
        1. If _argument_ is *null*, return *"null"*.
        1. If _argument_ is *true*, return *"true"*.
        1. If _argument_ is *false*, return *"false"*.
        1. If _argument_ is a Number, return Number::toString(_argument_, 10).
        1. If _argument_ is a BigInt, return BigInt::toString(_argument_, 10).
        1. <ins>If _argument_ is a Decimal128 object, return ! Call([_argument_].[[toString]], _argument_).</ins>
        1. Assert: _argument_ is an Object.
        1. Let _primValue_ be ? ToPrimitive(_argument_, ~string~).
        1. Assert: _primValue_ is not an Object.
        1. Return ? ToString(_primValue_).
      </emu-alg>
    </emu-clause>
</emu-clause>

<emu-clause id="sec-the-decimal-object">
  <h1>The Decimal128 Object</h1>
  <emu-intro id="sec-decimal-intro">
    <h1>Introduction</h1>
    <p>Decimal128 objects, as specified here, are intended represent base-10 (decimal) numbers as specified in <emu-xref href="#sec-bibliography">IEEE 754> Decimal128</emu-xref>. A Decimal128 value, as specified here, is a value:</p>
    <ul>
      <li>NaN<sub>𝔻</sub>, represending a decimal not-a-number</li>
      <li>+∞<sub>𝔻</sub>, representing positive infinity as a decimal,</li>
      <li>-∞<sub>𝔻</sub>, representing negative infinity as a decimal,</li>
      <li>« _v_, _q_ »<sub>𝔻</sub>, where _v_ and _q_ satisfy</li>
      <ul>
	<li>_v_ is either
	<ul>
	  <li>0<sub>𝔻</sub>, represending non-negative zero as a decimal value</li>
	  <li>-0<sub>𝔻</sub>, representing negative zero as a decimal value, or</li>
	  <li>a real number</li>
	</ul></li>
	<li>_q_ is an integer satisfying -6176 ≤ _q_ ≤ 6111,</li>
	<li>If _v_ is a real number, then v × 10<sup>-_q_</sup> is an integer _n_ such that 0 < _n_ < 10<sup>34</sup></li>
      </ul>
    </ul>
    <p>Decimal128 values are distinct from Numbers and BigInt values.</p>
    <p>The <dfn id="dfn-decimal128-mathematical-value">mathematical value</dfn> of a finite Decimal128 value _x_ = « _v_, _q_ »<sub>𝔻</sub> is defined as follows:</p>
    <ul>
      <li>If _x_ is zero, the mathematical value of _x_ is 0</li>
      <li>If _x_ is non-zero, the mathematical value of _x_ is v × 10<sup>_q_</sup></li>
    </ul>
    <p>A Decimal128 value is said to be <dfn id="dfn-decimal128-finite">finite</dfn> if it has the form « _v_, _q_ »<sub>𝔻</sub>. A <dfn id="dfn-decimal128-zero">zero</dfn> Decimal128 value is a finite Decimal128 value of the form « 0<sub>𝔻</sub>, _q_ »<sub>𝔻</sub> or « -0<sub>𝔻</sub>, _q_ »<sub>𝔻</sub>. A finite non-zero Decimal128 value is one of the form « _v_, _q_ »<sub>𝔻</sub> where _v_ is a real number.</p>
    <emu-note>
      <p>The _v_ component of a finite non-zero Decimal128 value « _v_, _q_ »<sub>𝔻</sub> is a rational number.</p>
    </emu-note>
    <p>Decimal128 values defined in this section are ECMAScript analogues of <emu-xref href="#sec-bibliography">IEEE-754 Decimal128 values</emu-xref>. The full spectrum of values defined by Decimal128 are available here, though there is only one Decimal128 value, NaN<sub>𝔻</sub>, representing all possible IEEE 754 Decimal128 NaN values.</p>
    <p>A <dfn id="dfn-decimal128-rounding-mode">rounding mode</dfn> is one of the String values *"roundTowardPositive"*, *"roundTowardNegative"*, *"roundTowardZero"*, *"roundTiesToAway"*, and *"roundTiesToEven"*. The <dfn id="dfn-decimal128-default-rounding-mode">default rounding mode</dfn> is the String value *"roundTiesToEven"*.</p>
    <p>The <dfn id="dfn-decimal128-cohort">cohort</dfn> of a Decimal128 value is defined as follows:</p>
    <dl>
      <dt>cohort(NaN<sub>𝔻</sub>)</dt>
      <dd>NaN<sub>𝔻</sub></dd>
      <dt>cohort(+∞<sub>𝔻</sub>)</dt>
      <dd>+∞<sub>𝔻</sub></dd>
      <dt>cohort(-∞<sub>𝔻</sub>)</dt>
      <dd>-∞<sub>𝔻</sub></dd>
      <dt>cohort(« _v_, _q_ »<sub>𝔻</sub>)</dt>
      <dd>_v_</dd>
    </dl>
    <p>For every finite non-zero Decimal128 value « _v_, _q_ »<sub>𝔻</sub> there exists a unique integer _e_ and real number _s_ such that</p>
    <ol>
      <li>_v_ = _s_ × 10<sup>_e_</sup></li>
      <li>1 ≤ |_s_| < 10</li>
    </ol>
    <p>We call _e_ the <dfn>exponent</dfn> and _s_ the <dfn>significand</dfn> of « _v_, _q_ »<sub>𝔻</sub>. The exponent and significand for NaN and non-finite, and zero Decimal128 values is not defined.</p>
    <emu-note>
      <p>The sigfnificand of finite non-zero Decimal128 values is a rational number.</p>
    </emu-note>
    <emu-note>
      <p>The exponent _e_ of finite non-zero Decimal128 values is an integer satisfying 6144 ≥ _e_ ≥ -6176.</p>
    </emu-note>
    <p>A finite non-zero Decimal128 value is <dfn>normalized</dfn> if its exponent _e_ satisfies 6144 ≥ _e_ ≥ -6143. A finite non-zero Decimal128 value is <dfn>denormalized</dfn> if its exponent _e_ satisfies -6144 ≥ _e_ ≥ -6176.</p>
    <p>For a proper discussion of rounding, we need to separate how rounding occurs with normalized compared with denormlized values. For a normalized Decimal128 value we define its <dfn>truncated exponent</dfn> as equal to its exponent. For zero or denormalized Decimal128 values we define the truncated exponent as the constant -6143. Given this, we define the <dfn>scaled significand</dfn> of a finite Decimal128 value as follows:</p>
    <ul>
      <li>The scaled significand of a zero Decimal128 value is 0</li>
      <li>The scaled significand of a non-zero Decimal128 value _x = « _v_, _q_ »<sub>𝔻</sub> is v × 10<sup>33 - _te_</sup>, where _t_ is the truncated exponent of _x_.</li>
    </ul>
    <emu-note>
      <p>The scaled significand of a finite Decimal128 value is always an integer whose absolute value is less than 10<sup>34</sup>.</p>
    </emu-note>
  </emu-intro>
  <emu-clause id="sec-decimal-abstract-ops">
    <h1>Abstract Operations</h1>
    <emu-clause id="sec-isintegraldecimal128" type="abstract operation">
      <h1>
        IsIntegralDecimal128 (
          _argument_: an ECMAScript language value,
        ): a Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It determines if _argument_ is a finite integral Decimal128 value.</dd>
      </dl>
      <emu-alg>
        1. If _argument_ is not a Decimal128 object, return *false*.
        1. If [_argument_].[[isNaN]] is *true*, return *false*.
        1. If [_argument_].[[isFinite]] is *false*, return *false*.
        1. Let _rounded_ be the result of ! Call ([_argument_].[[round]], 0, *"roundTowardZero"*).
        1. Return the result of Call ([_argument_].[[equals]], _rounded_).
      </emu-alg>
    </emu-clause>
  </emu-clause>
  <emu-clause id="sec-the-decimal-constructor">
    <h1>The Decimal128 Constructor</h1>
    <p>The constructor for the Decimal128 object takes a single argument and an optional second argument. Three types of argument are accepted:</p>
    <ul>
      <li>Number,</li>
      <li>BigInt, and</li>
      <li>String</li>
    </ul>
    <p>If the argument is not a String, BigInt, or Number, throw a *TypeError*.</p>
    <p>If the argument _x_ is a BigInt or a String, reconsider the call to the constructor as a call where the first argument is ToString(_x_).</p>
    <p>The String argument must match one of the following four syntaxes:</p>
    <emu-grammar name="decimal-syntax">
      <emu-production name="DigitString" type="lexical">
        <emu-rhs><emu-prodref href="#prod-Decimal128Digit"></emu-prodref>+</emu-rhs>
      </emu-production>
      <emu-production name="UnsignedDecimal128DigitString" type="lexical" oneof>
        <emu-rhs><emu-prodref href="#prod-Decimal128Digits"></emu-prodref></emu-rhs>
        <emu-rhs><emu-prodref href="#prod-Decimal128Digits"></emu-prodref> "." <emu-prodref href="#prod-Decimal128Digits"></emu-prodref></emu-rhs>
      </emu-production>
      <emu-production name="SignedDecimal128DigitString" type="lexical" oneof>
        <emu-rhs>-? <emu-prodref name="UnsignedDecimal128DigitString"></emu-prodref></emu-rhs>
      </emu-production>
    </emu-grammar>
    <emu-grammar>
      <emu-production name="UnsignedDecimal128DigitString" type="lexical" oneof>
        <emu-rhs><emu-prodref href="#prod-Decimal128Digits"></emu-prodref></emu-rhs>
        <emu-rhs><emu-prodref href="#prod-Decimal128Digits"></emu-prodref> "." <emu-prodref href="#prod-Decimal128Digits"></emu-prodref></emu-rhs>
      </emu-production>
      <emu-production name="SignedDecimal128DigitString" type="lexical" oneof>
        <emu-rhs>[+-]? <emu-prodref name="UnsignedDigitString"></emu-prodref></emu-rhs>
      </emu-production>
    </emu-grammar>
    <emu-grammar name="exponential-syntax">
      <emu-production name="ExponentialDigitStringLHS" type="lexical" oneof>
        <emu-rhs><emu-prodref href="#prod-NonZeroDigit"></emu-prodref></emu-rhs>
        <emu-rhs><emu-prodref href="#prod-NonZeroDigit"></emu-prodref> "." <emu-prodref href="#prod-Decimal128Digits"></emu-prodref></emu-rhs>
      </emu-production>
      <emu-production name="ExponentialDigitStringRHS" type="lexical">
        <emu-rhs>[-+]? <emu-prodref href="#prod-Decimal128Digits"></emu-prodref></emu-rhs>
      </emu-production>
    </emu-grammar>
    <emu-grammar name="infinity" oneof>
      <emu-production>`-` ? `Inf` [> or any token that is an ASCII case-insensitive match]</emu-production>
      <emu-production>`-` ? `Infinity` [> or any token that is an ASCII case-insensitive match]</emu-production>
    </emu-grammar>
    <emu-grammar name="nan">
      <emu-production>("N" | "n") | ("A" | "a") | ("N" | "n")</emu-production>
    </emu-grammar>
    <p>If *_x_* does not match any of these syntaxes, throw a *SyntaxError*.</p>
    <p>Multiple leading zeros will be reduced to a single zero.</p>
  </emu-clause>
</emu-clause>
  <emu-clause id="sec-decimal-prototype-properties">
    <h1>Properties of the Decimal128 Prototype</h1>
    <emu-clause id="sec-decimal.prototype.isnan">
      <h1>Decimal128.prototype.isNaN</h1>
      <p>A property indicating whether *this* value represents a Decimal128 NaN value. The possible values are *true* and *false*.</p>
    </emu-clause>
    <emu-clause id="sec-decimal.prototype.isfinite">
      <h1>Decimale128.prototype.isFinite</h1>
      <p>A property indicating whether *this* value represents a finite value. The possible values are *true* and *false*. Decimal128 NaN values are considered finite.</p>
    </emu-clause>
    <emu-clause id="sec-decimal.prototype.significand">
      <h1>Decimale128.prototype.significand</h1>
      <p>A property that stores the significand of *this* value. Its type is BigInt. This property should be a BigInt even if *this* value is NaN or infinite.</p>
    </emu-clause>
    <emu-clause id="sec-decimal.prototype.exponent">
      <h1>Decimale128.prototype.exponent</h1>
      <p>A property that stores the exponent of *this* value. Its type is Number. It should always be an integer. This property should be a Number even if *this* value is NaN or infinite.</p>
    </emu-clause>
    <emu-clause id="sec-decimal.prototype.abs">
      <h1>Decimal128.prototype.abs ( )</h1>
      <p>Computes the absolute value of *this* value according to the rules specified in the IEEE 754 Decimal128. *this* value is not modified.</p>
    </emu-clause>
    <emu-clause id="sec-decimal.prototype.neg">
      <h1>Decimal128.prototype.neg ( )</h1>
      <p>Computes the negation of *this* value.</p>
    </emu-clause>
    <emu-clause id="sec-decimal.prototype.add">
      <h1>Decimal128.prototype.add ( _x_ )</h1>
      <p>Adds *this* value to *_x_* according to the rules specified in the IEEE 754 Decimal128 specification. If, in the computation, more significant are generated than can be stored in an IEEE 754 Decimal128 value, the final digit will be computed by rounding according to <emu-xref href="#dfn-decimal128-default-rounding-mode">the default rounding mode</emu-xref>.</p>
    </emu-clause>
    <emu-clause id="sec-decimal.prototype.subtract">
      <h1>Decimal128.prototype.subtract ( _x_ )</h1>
      <p>Subtracts *_x_* from *this* value according to the rules specified in the IEEE 754 Decimal128 specification. Neither *this* value nor *_x_* is modified. If, in the computation, more significant digits are generated than can be stored in an IEEE 754 Decimal128 value, the final digit will be computed by rounding according to <emu-xref href="#dfn-decimal128-default-rounding-mode">the default rounding mode</emu-xref>.</p>
    </emu-clause>
    <emu-clause id="sec-decimal.prototype.multiply">
      <h1>Decimal128.prototype.multiply ( _x_ )</h1>
      <p>Multiplies *this* value by *_x_* according to the rules specified in the IEEE 754 Decimal128 specification. Neither argument is modified. If, in the computation, more significant digits are generated than can be stored in an IEEE 754 Decimal128 value, the final digit will be computed by rounding according to <emu-xref href="#dfn-decimal128-default-rounding-mode">the default rounding mode</emu-xref>.</p>
    </emu-clause>
    <emu-clause id="sec-decimal.prototype.divide">
      <h1>Decimal128.prototype.divide ( _x_ )</h1>
      <p>Divides *this* value by *_y_* according to the rules specified in the IEEE 754 Decimal128 specification. Neither *this* value nor *_x_* is modified. If, in the computation, more significant digits are generated than can be stored in an IEEE 754 Decimal128 value, the final digit will be computed by rounding according to <emu-xref href="#dfn-decimal128-default-rounding-mode">the default rounding mode</emu-xref>.</p>
    </emu-clause>
    <emu-clause id="sec-decimal.prototype.remainder">
      <h1>Decimal128.prototype.remainder ( _x_ )</h1>
      <p>Computes the remainder of dividing *this* value by *_x_*. Exact division of *this* by *_x_* is carried out until the computation stops; the residue of that computation is returned. The sign of the result is the sign of *this* value. Returns a fresh result.</p>
      <emu-note>
        <p>The remainder operation specified here deviates from the IEEE 754 remainder operation. We follow the <emu-xref href="#sec-numeric-types-number-remainder">the remainder operation for Number</emu-xref> rather than IEEE 754, which specifies that, for example, the remainder 46 and 10 is -4 rather than 6.</p>
      </emu-note>
    </emu-clause>
    <emu-clause id="sec-decimal.prototype.equals">
      <h1>Decimal128.prototype.equals ( _x_ )</h1>
      <p>Compares the <emu-xref href="#dfn-decimal128-mathematical-value">mathematical value</emu-xref> of *this* value with the mathematical value of *_x_*, which is supposed to be a Decimal128 object. Returns *true* or *false*.</p>
      <emu-alg>
        1. If _x_ is not a Decimal128 object, then
          1. throw a *TypeError* exception.
        1. If [*this*][[isNaN]], then
          1. If [*_x_*][[isNaN]] is *true*, return *true*.
          1. Return *false*.
        1. If [*_x_*][[isNaN]] is *true*, return *false*.
        1. Let *_c_* be the result of calling the IEEE 754 Decimal128 <code>compare</code> operation on *this* value and *_x_*.
        1. If *_c_* is 0, return *true*, else return *false*.
      </emu-alg>
    </emu-clause>
    <emu-clause id="sec-decimal.prototype.lessthan">
      <h1>Decimal128.prototype.lessThan ( _x_ )</h1>
      <p>Compares the <emu-xref href="#dfn-decimal128-mathematical-value">mathematical value</emu-xref> of *this* value with the mathematical value of *_x_*, which is supposed to be a Decimal128 object. If *_x_* is not a Decimal128 object, throws a *TypeError*. Returns *true* or *false* according as the mathematical value of *this* value is strictly less than the mathematical value of *_x_*.</p>
      <emu-alg>
        1. If _x_ is not a Decimal128 object, then
          1. throw a *TypeError* exception.
        1. If [*this*][[isNaN]], throw a *RangeError* exception.
        1. If [*_x_*][[isNaN]], throw a *RangeError* exception.
        1. Let *_c_* be the result of calling the IEEE 754 Decimal128 <code>compare</code> operation on *this* value and *_x_*.
        1. If *_c_* is -1, return *true*, else return *false*.
      </emu-alg>
    </emu-clause>
    <emu-clause id="sec-decimal.prototype.compare">
      <h1>Decimal128.prototype.compare ( _x_ )</h1>
      <p>Compares *this* value with of *_x_* according to the specification of the IEEE 754 <code>compare_total</code> operation. Returns -1, 0, or 1 according as *this* value is greater than, equal, or less than *_x_* according to the ordering specified by IEEE 754’s <code>compare_total</code> operation.</p>
      <emu-alg>
        1. If _x_ is not a Decimal128 object, then
          1. throw a *TypeError* exception.
        1. Let *_c_* be the result of calling the IEEE 754 Decimal128 compare_total procedure on *this* value and *_x_*.
        1. Assert: *_c_* is in « -1, 0, 1 ».
        1. Return *_c_*.
      </emu-alg>
      <emu-note>
        <p>This operation compares Decimal128 values as digit strings. Thus, for example, 1.2 and 1.20 are considered distinct values for this operation. To compare by mathematical value, see <emu-xref href="#sec-decimal.prototype.lessthan">lessThan</emu-xref> and <emu-xref href="#sec-decimal.prototype.equals">equals</emu-xref>.</p>
      </emu-note>
    </emu-clause>
    <emu-clause id="sec-decimal-method-round">
      <h1>Decimal128.prototype.round ( _numFractionalDigits_ [ , _mode_ ] )</h1>
      <p>Rounds *this* value according to the specified rounding mode, returning a fresh result. The result will have at most _numFractionalDigits_ after the decimal point.</p>
      <emu-note>
        <p>If _mode_ is neither *undefined* nor a String, throw a *TypeError* exception.</p>
        <p>If _mode_ is not a <emu-xref href="#dfn-decimal128-rounding-mode">rounding mode</emu-xref>, throw a *RangeError* exception.</p>
      </emu-note>
    </emu-clause>
    <emu-clause id="sec-decimal.prototype.tostring">
      <h1>Decimal128.prototype.toString ( [ _options_ ] )</h1>
      <p>Renders *this* value as a signed decimal string. _options_, is defined, is supposed to be a plain object. If _options_ has the property *numDecimal128Digits* and the value of that property is a non-negative Number, the return value will be a string that has exactly that many digits after the decimal point, possibly with the addition of trailing zeros.</p>
      <emu-alg>
        1. Let _roundingMode_ be [[_options_]][roundingMode]].
        1. If _roundingMode_ is not a rounding mode, then
          1. set _roundingMode_ to *"roundTiesToEven"*.
        1. Let _format_ be [[_options_]][format]].
        1. If _format_ is not one of *"decimal"* or *"exponential"*, then
          1. set _format_ to *"decimal"*.
        1. If _format_ is *"decimal*", then
          1. return the result of calling IEEE 754’s convertToDecimalCharacter with a second argument ensuring that a signed decimal string is generated. TODO convertToDecimalCharacter is unspecified, so we need to do that work here.
        1. Return the result of calling IEEE 754’s convertToDecimalCharacter with a second argument ensuring that a signed exponential string is generated. TODO convertToDecimalCharacter is unspecified, so we need to do that work here.
      </emu-alg>
    </emu-clause>
    <emu-clause id="sec-decimal.prototype.tobigint">
      <h1>Decimal128.prototype.toBigInt ( )</h1>
      <p>Converts *this* value into a BigInt. The mathematical value of the result is equal to the mathematical value of *this* value.</p>
      <emu-alg>
        1. If ! IsIntegralDecimal128 (*this*), is *false*, throw a RangeError.
        1. Return ! ToBigInt(Call (*this*.[[toString]], *this*)).
      </emu-alg>
    </emu-clause>
    <emu-clause id="sec-decimal.prototype.tonumber">
      <h1>Decimal128.prototype.toNumber ( )</h1>
      <p>Converts *this* value into a Number.</p>
      <emu-alg>
        1. Return StringToNumber(Call (*this*.[[toString]], *this*)).
      </emu-alg>
    </emu-clause>
    <emu-clause id="sec-decimal.prototype.valueof">
      <h1>Decimal128.prototype.valueOf ( _x_ )</h1>
      <p>Throw *TypeError*.</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-numbers-and-dates">
  <h1>Numbers and Dates</h1>
  <emu-clause id="sec-number-objects">
    <h1>Number Objects</h1>
    <emu-clause id="sec-number-constructor">
      <h1>The Number Constructor</h1>
      <emu-clause id="sec-number-constructor-number-value">
	<h1>Number ( _value_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If _value_ is present, then
            1. Let _serialized_ be the result of ! Call([_value_].[[toString]], _value_).
            1. If _value_ is a Decimal128 object, return ! ToNumber(_serialized_).
            1. Let _prim_ be ? ToNumeric(_value_).
            1. If _prim_ is a BigInt, let _n_ be 𝔽(ℝ(_prim_)).
            1. Otherwise, let _n_ be _prim_.
          1. Else,
            1. Let _n_ be *+0*<sub>𝔽</sub>.
          1. If NewTarget is *undefined*, return _n_.
          1. Let _O_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%Number.prototype%"*, « [[NumberData]] »).
          1. Set _O_.[[NumberData]] to _n_.
          1. Return _O_.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
  <emu-clause id="sec-bigint-objects">
    <h1>BigInt Objects</h1>
    <emu-clause id="sec-bigint-constructor">
      <h1>The BigInt Constructor</h1>
      <emu-clause id="sec-bigint-constructor-number-value">
        <h1>BigInt ( _value_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If NewTarget is not *undefined*, throw a *TypeError* exception.
          1. <ins>If _value_ is a Decimal128 object, return ? Decimal128ToBigInt(_value_).</ins>
          1. Let _prim_ be ? ToPrimitive(_value_, ~number~).
          1. If _prim_ is a Number, return ? NumberToBigInt(_prim_).
          1. Otherwise, return ? <emu-meta suppress-effects="user-code">ToBigInt(_prim_)</emu-meta>.
        </emu-alg>

         <emu-clause id="sec-numbertobigint" type="abstract operation">
          <h1>
            <ins>Decimal128ToBigInt (
            _number_: a Decimal128 object,
            ): either a normal completion containing a BigInt or a throw completion</ins>
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. If IsIntegralDecimal128(_number_) is *false*, throw a *RangeError* exception.
            1. Return ℤ(ℝ(_number_)).
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>
